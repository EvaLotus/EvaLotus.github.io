<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>「 极简 」你是什么样的人，就会选择什么样的路</title>
      <link href="/2018/12/19/%E6%9E%81%E7%AE%801/"/>
      <url>/2018/12/19/%E6%9E%81%E7%AE%801/</url>
      
        <content type="html"><![CDATA[<p>经常会听到这么一句话，你看到的都是别人想让你看到的，但是现在想得更多的却是，你看到的都是你愿意看到的。<br>最近豆瓣上风行消费降级，极简主义也跟着火了起来，timeline上十篇文章有九篇是教你如何消费降级的。我不知道是因为豆瓣的个性化推荐做的太好，我看过一篇极简的文章之后就各种推这种类型的，还是大家真的开始认真的极简起来。<br>虽然你可能并不是极简主义，根据你看到的都是你愿意看到的逻辑，当你主动点开看这篇文章的时候，就说明你内心还是有极简的星星之火。<br><a id="more"></a></p><p>我走上极简道路的原因并不复杂，因为从小就有这样的观念，家楼下常年堆着父亲卖不出去的货物，我常想，这腾出来可以给狗子搭一间多宽敞的窝呀。加上求学，幼儿园在北京，小学在镇里，初中去县里，高中去市里，大学又去北京（走出大山的孩子，噗），搬家是家常便饭，早就习惯了轻装前行。<br>其实还是因为脑子也就花生米那么大，装太多东西，真的装不下。<br>而且我这人讨厌麻烦，给自己留坑的事万万不愿意做。<br>大学的时候知乎上最火的问题就是，百元以内提升生活质量的好物，<br>理财规划之路都走的轻松一些，因为没有那么多的障碍。<br>我抱着手机一条一条的看<br>把床品换成了五星级酒店专用的康尔馨四件套，<br>扔掉了牙刷换成电动牙刷入门款<br>死机再也打不开的三星被换成了iPhone<br>因为学习iOS开发换成了MacBook。<br>物质道路已经成型，对未来我丝毫不害怕，不发生大的变故，我一定会是一个财务清爽，每天进步的人。<br>长久养成的习惯从来不会担心反弹。就像减肥的办法，从来不是短时间的节食，而是你内心形成观念，知道吃多少算是多。<br>只是有时候确实会想起来，咦，这件衣服咋找不到了，我记得没捐掉啊！那就是告别仪式做的还不够。没有认认真真的感谢它，谢谢你陪伴我的这一路，但是我长大了，你现在可能没那么适合我啦，已经xx天没穿你了，实在是不尊重你，送你去别的珍惜你的人身边发挥更大的价值吧。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 极简 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「 生活 」冬日学车的碎碎念</title>
      <link href="/2018/12/18/%E5%86%AC%E6%97%A5%E5%AD%A6%E8%BD%A6%E7%9A%84%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
      <url>/2018/12/18/%E5%86%AC%E6%97%A5%E5%AD%A6%E8%BD%A6%E7%9A%84%E7%A2%8E%E7%A2%8E%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<p>大家一般都喜欢在高考一毕业就开始学车，最次也是在大学里尽量拿本，因为工作了学车就比较难了，时间，精力各项都不太够。</p><p>但是这次学车，却有很多意想不到的收获。<br><a id="more"></a></p><h4 id="一些人生感悟碎碎念"><a href="#一些人生感悟碎碎念" class="headerlink" title="一些人生感悟碎碎念"></a>一些人生感悟碎碎念</h4><p>坐在车上思维就开始天马行空，随手记录一些零碎的想法。</p><p>1.每天六点就得起，所以必须睡够8小时的我一般十点就睡了，学个车习惯了早睡早起，皮肤都变好了。</p><p>2.学车找回了学习的乐趣。有些人上了大学之后就再也不学习，再也没看过一本书，（我自己本来说的一年20本书的计划只完成了1本），这真的是件<strong>很可怕</strong>的事情，除了上班时候的被动学习，在工作中学习，自己回到家居然再也不想打开电脑，只在手机里零零碎碎的看些段子。如果人生是在游乐场，你就玩个旋转木马就够了吗？不，还有那么多的项目，不管你怎么想，反正我都要玩一遍。</p><p>3.不用为了应付考试的学习真幸福呀。考试考十分你就要准备二十分。正如面试造火箭，入职拧螺丝。所以自己凭兴趣，重拾学习的乐趣，为了让人生路走的更远而学习，真的是一件快乐安心的事。</p><p>4.唯有努力最心安。</p><p>5.碎片化的时间利用好了更有意义。</p><h4 id="好玩的段子，笑点低"><a href="#好玩的段子，笑点低" class="headerlink" title="好玩的段子，笑点低"></a>好玩的段子，笑点低</h4><p>1.学车的时候倒库很快就找到了感觉，怎么着都能倒进去，有一次没按教练的意思做也成功了</p><p>教练：“哟呵，怎么着，都有自己的意识了是吧”。</p><p>感觉自己是个AI，我大喊一句：“<strong>人工智能觉醒啦！</strong>”</p><p>中二病犯了，噗。</p><p>2.开始准备科二考试了，因为开得太稳，每次模拟考教练坐我边上都没过一会儿就睡着了，<strong>发出均匀的打呼声</strong>。</p><p>想起了之前的段子，交警拦下一辆车，乘客没驾照，司机在睡觉。</p><p>这就是人与人之间的信任吧嘻嘻。</p><p>3.科二虽然练得很好，但是还是紧张的每天晚上睡不着觉，心里素质好差。</p><p>到考试了，反正我的原则是长痛不如短痛，早死早超生，第一个冲上去，一把过满分过了。</p><p>我：“稳如狗就是我~满分一把过”，</p><p>Pango：“考前紧张如鸡，现在稳如狗”。</p><p>4.开始上道路实训了</p><p>我忍不住笑问教练：“咱这车上了保险么？”</p><p>教练惊恐：“你想咋滴？”</p><p>我：“嘻嘻，旁边有个保时捷”。</p><p>教练：“这破车能上多少保险，你要撞了我裤衩都卖了也赔不起了，我们是拿生命在陪你们练车啊啊啊”。</p><p>5.道路实训，郭郭开车老是跑到两条道路中间，教练刹车踩得飞起。</p><p>他俩都有安全带，我一会儿被甩到这边，一会儿被甩到那边。</p><p>6.道路实训，前车太慢了</p><p>我开始嘀咕：“要不要超过去呀，太磨叽了”，</p><p>教练：“哟呵，看不出来脾气还挺爆的”，</p><p>我：“哈哈，每次男票开车我坐副驾，我俩就讨论，前面哪个是sb，这个叫耳濡目染~”。</p><p>7.和同事聊天</p><p>我：“要是大学的时候不一赌气就放弃了学车，或者不为了省钱和近报了东方时尚，大概早都摇到号了吧，我舍友大学的时候就摇到了。啊，被偷走的那五年”，</p><p>pm狗：“<strong>我从12年开始摇的</strong>”，</p><p>我掐指一算：“哦，我想多了”。</p><p>8.跟Pango说起摇号的事</p><p>我：“我希望可以摇到尾号6，车牌号是EVA666，咱俩还可以避过单双号限行”，</p><p>Pango：“现在只能P，Q开头了，404也不错啊”，</p><p>我：“或者JS666也行”，</p><p>Pango：“为啥不是JS404”，</p><p>我：“403比较好，403forbidden，401也不错，401 unauthorized，500 server error…”</p><p>9.还是摇号的事</p><p>Pango：“做生意的冬冬说他们家一共五辆车，哪天限行都可以，A是摇号后一个月中的，B是三个月”</p><p>我：“好羡慕呀，C呢”，</p><p>Pango：“摇号最疯狂的那一阵提前买的。就是马上要出摇号政策了，北京的车都被买完了，4s店来一辆车就被预订了，有的人直接守在4s店门口，来一辆车直接操起一凳子就把车窗砸了，说不好意思，那这辆是我的了。然后另一人立马就把前挡风砸了，说怎么tmd就是你的了”。</p><p>我：“哦”。</p><p>10.三环路上，心想马上要拿本了，好憧憬。</p><p>我：“哼，拿到本我就开你的破车，居然说这个小破车是你的小情人。”，</p><p>Pango：“下周我可能要去出差，给妈妈过生日我不在，你就载着妈妈自己开去刘家窑接上三姨吧”，</p><p>我秒怂：“你不在北京罩着我，臣妾tmd做不到啊”</p><h4 id="驾考独家笔记"><a href="#驾考独家笔记" class="headerlink" title="驾考独家笔记"></a>驾考独家笔记</h4><p>下面是一些驾考笔记，我感觉和年龄相近的小伙伴应该都用不上了吧，但是还是随手记录分享给想看的小伙伴。</p><p>其实说到底，还是因为懒，拿到本了还是有很多小伙伴问我一些信息，本着文档拯救世界的观念，记录下来这些看似无用之用的知识。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>微信开发实用指南4-openId，unionId，首先要明白OAuth那些事儿</title>
      <link href="/2018/12/18/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E6%8C%87%E5%8D%974-openId%EF%BC%8CunionId%EF%BC%8C%E9%A6%96%E5%85%88%E8%A6%81%E6%98%8E%E7%99%BDOAuth%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"/>
      <url>/2018/12/18/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E6%8C%87%E5%8D%974-openId%EF%BC%8CunionId%EF%BC%8C%E9%A6%96%E5%85%88%E8%A6%81%E6%98%8E%E7%99%BDOAuth%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/</url>
      
        <content type="html"><![CDATA[<p><a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421140842" target="_blank" rel="noopener">微信的OAuth文档</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 微信开发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JS事件循环机制5-webwork</title>
      <link href="/2018/12/18/JS%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B65-webwork/"/>
      <url>/2018/12/18/JS%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B65-webwork/</url>
      
        <content type="html"><![CDATA[<p>占坑TODO</p>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>城市选择启示录</title>
      <link href="/2018/11/18/%E5%9F%8E%E5%B8%82%E9%80%89%E6%8B%A9%E5%90%AF%E7%A4%BA%E5%BD%95/"/>
      <url>/2018/11/18/%E5%9F%8E%E5%B8%82%E9%80%89%E6%8B%A9%E5%90%AF%E7%A4%BA%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>最近公司出了去转岗武汉的好政策，3万元的安家费，不降薪，不落户也可以随时买房。<br>小伙伴问我咋不回去，也不是没想过，只不过男票肯定不同意，也难以下定决心。<br>几乎所有的人都说，男票不同意那就换个同意的男票（逃~）。</p><a id="more"></a><p>昨天华为的小伙伴问我要不要去深圳，空气好，离香港近，随时出国玩耍，生活成本低。<br>我说买不起房啊。其实去深圳肯定不如去武汉的，毕竟是湖北人。<br>大学的时候学的管理学派上了用场，我用SWOT分析法分析下城市选择的优劣势，你看到了也可以帮我分析分析，或者希望我的分析对你也有用处。</p><p>TODO</p><h4 id="武汉迁户口攻略："><a href="#武汉迁户口攻略：" class="headerlink" title="武汉迁户口攻略："></a>武汉迁户口攻略：</h4><p>1.关注光谷公安公众号，填写信息，看看是否符合条件<br>2.选借住，让有房的朋友给写个借住证明，其他材料必须齐全，不齐全谁也没办法，都是拍照上传的<br>3.提交材料之后，材料都没问题的话，大概一天内就有回复了。<br>4.审核通过后会你可以选择寄准迁证明到户口所在地的亲人那边，让亲人拿到准迁证明去你原户口所在地去办迁出，给你寄材料，然后你就可以去武汉了</p>]]></content>
      
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>前端静态发布系统探索</title>
      <link href="/2018/10/25/%E5%89%8D%E7%AB%AF%E9%9D%99%E6%80%81%E5%8F%91%E5%B8%83%E7%B3%BB%E7%BB%9F%E6%8E%A2%E7%B4%A2/"/>
      <url>/2018/10/25/%E5%89%8D%E7%AB%AF%E9%9D%99%E6%80%81%E5%8F%91%E5%B8%83%E7%B3%BB%E7%BB%9F%E6%8E%A2%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<p>现代的静态发布系统探索<br><a id="more"></a></p><h4 id="建议的发布方式："><a href="#建议的发布方式：" class="headerlink" title="建议的发布方式："></a>建议的发布方式：</h4><p>1.前后端分离，npm run build，将静态资源上cdn</p><p>2.将入口文件index放在server端返回。</p><h4 id="代码层面："><a href="#代码层面：" class="headerlink" title="代码层面："></a>代码层面：</h4><p>在webpack中，不仅仅分离vendor.js，对于稳定的功能，也可以在webpack中动静分离，分成经常改的文件和不经常修改的。</p><h4 id="覆盖式发布还是非覆盖式发布？"><a href="#覆盖式发布还是非覆盖式发布？" class="headerlink" title="覆盖式发布还是非覆盖式发布？"></a>覆盖式发布还是非覆盖式发布？</h4><p>如果每次发布都在原来的文件基础上修改，每次都覆盖式发布文件，只是在访问时 <a href="http://evacode.com/static/a.js?v=1.0" target="_blank" rel="noopener">http://evacode.com/static/a.js?v=1.0</a> ,修改v后面的版本号。这样不仅回滚时不好操作，而且版本非常容易混淆。</p><p>mi使用的发布系统是与git关联的，后来和sre沟通，发现真的是每个版本都留着，现在7年多了，其实占用的磁盘资源并没有想象的那么多。但是静态资源上cdn，cdn上还是需要定期清理。</p><p>更新资源发布路径实现非覆盖式发布。</p><h4 id="静态资源的入口文件index放在server项目中还是不放？"><a href="#静态资源的入口文件index放在server项目中还是不放？" class="headerlink" title="静态资源的入口文件index放在server项目中还是不放？"></a>静态资源的入口文件index放在server项目中还是不放？</h4><p>思考场景：</p><p>1.后端修改了接口，增加了参数，如果后端先上线了，前端后上线的话，中间时间点访问网站的用户因为缺少参数就不可用了。</p><p>2.后端新增了一个接口，前端先上线，后端还没部署，中间时间点访问网站的用户就会发现404了。</p><p>一个功能需要前后端协同开发，功能上有依赖，如果不能一起发布的话，总是会出现用户暂时访问有问题的情况。</p><p>但是如果放在一起的话，前端修改个css，后端需要几百台机器全部上个线，总不好意思每次都让后端同学那么辛苦的上线。</p><p>前端的静态资源入口文件，不管是index.htm还是index.jsp等等，在开发过程中，都可以直接scp到服务器上，并不需要后台编译。</p><p>所以结论是：</p><p>静态资源的入口文件应该放在server端项目。但是在部署系统上，应该同时实现两种情况的部署系统：</p><p>1.前后端同时发布，主要用于一个需要前后端协同开发的功能发布。</p><p>2.前端简单的发布index.html，主要用在与后端无关的前端发布上，如文案，css等。此时只需要把入口文件scp到项目中即可。</p><p>每次部署先发布静态资源再发布server端项目</p><h4 id="打包上线去本地化："><a href="#打包上线去本地化：" class="headerlink" title="打包上线去本地化："></a>打包上线去本地化：</h4><p>发布机上有docker image，在发布机上进行<code>npm run build</code>，将文件部署到cdn上。</p><p>TODO，文件丢到cdn，我们需要做什么。</p><h4 id="回滚操作："><a href="#回滚操作：" class="headerlink" title="回滚操作："></a>回滚操作：</h4><p>前后端有依赖的功能，全量回滚。</p><p>前后端无依赖的功能，直接回滚index到上个版本。</p><p>全程不用回滚静态资源发布，因为是非覆盖式发布，只需要修改index中的版本即可。</p><h4 id="缓存设置："><a href="#缓存设置：" class="headerlink" title="缓存设置："></a>缓存设置：</h4><p>静态资源因为有版本号，可以全部都设超长缓存时间。</p><p>index设置no-cache。</p><h5 id="公司的xbox系统"><a href="#公司的xbox系统" class="headerlink" title="公司的xbox系统"></a>公司的xbox系统</h5><p><a href="https://www.ibm.com/developerworks/cn/opensource/os-cn-puppet/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/opensource/os-cn-puppet/index.html</a></p><p><a href="https://puppet.com/" target="_blank" rel="noopener">https://puppet.com/</a></p><p>封装了puppet等开源项目，在Git项目中加上deploy文件之后，xbox就可以从git上拉代码，选择git版本进行编译</p><p>#!/bin/bash<br>set -x<br>job=$1</p><p>get_env_name() {<br>tag_env=<code>echo $1 | sed &#39;s/.*cluster\.\([^._]*\).*/\1/&#39;</code><br>echo ${tag_env}<br>}</p><p>get_job_name() {<br>echo $1 | sed ‘s/.<em>job.([^._]</em>).*/\1/‘<br>}</p><p>get_service_name() {<br>echo $1 | sed ‘s/.<em>service.([^._]</em>).*/\1/‘<br>}</p><p>env_name=<code>get_env_name $job</code><br>job_name=<code>get_job_name $job</code><br>service_name=<code>get_service_name $job</code></p><p>[ -d release ] &amp;&amp; rm -rf release</p><h1 id="需要什么文件夹就加什么文件夹"><a href="#需要什么文件夹就加什么文件夹" class="headerlink" title="需要什么文件夹就加什么文件夹."></a>需要什么文件夹就加什么文件夹.</h1><p>mkdir -p release &amp;&amp; cp -r ./dist/* release/<br>cp -r deploy release</p><p>exit 0</p><p>deploy和build.sh</p><h4 id="前端静态文件发布的过程："><a href="#前端静态文件发布的过程：" class="headerlink" title="前端静态文件发布的过程："></a>前端静态文件发布的过程：</h4><p>由sre来创建job</p><p>job要属于资源所在产品线</p><p>静态发布需要创建job，从部署系统发布，不要私自copy到机器上</p><p>发布时启停只能是update</p><p>申请机器权限：</p><p><a href="http://apply.pt.xiaomi.com/apply" target="_blank" rel="noopener">http://apply.pt.xiaomi.com/apply</a></p><p>在发布系统中docker的使用</p><p>docker镜像编译</p><p><a href="http://v9.git.n.xiaomi.com/mcfe/goku" target="_blank" rel="noopener">http://v9.git.n.xiaomi.com/mcfe/goku</a></p><p>稳定性和编译能力</p><p>git拉代码，文件copy，机器打通</p>]]></content>
      
      
      
        <tags>
            
            <tag> frontend team </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JS事件循环机制2-throttle和debounce</title>
      <link href="/2018/10/15/JS%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B62-throttle%E5%92%8Cdebounce/"/>
      <url>/2018/10/15/JS%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B62-throttle%E5%92%8Cdebounce/</url>
      
        <content type="html"><![CDATA[<p>函数的debounce和throttle<br><a id="more"></a></p><table><thead><tr><th style="text-align:left"></th><th style="text-align:left">throttle</th><th style="text-align:left">debounce</th></tr></thead><tbody><tr><td style="text-align:left">释义</td><td style="text-align:left">节流（整个事件所用的时间）</td><td style="text-align:left">去抖动（整个事件的单次循环之间的时间间隔）</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">水龙头打开本来是连续不断的出水，但是我们将水龙头不断拧紧，直到水龙头以一滴一滴的形式流出。使某个连续不断的动作在某个规定时间段只调用一次，叫做节流throttle</td><td style="text-align:left">从按下弹簧到弹簧恢复松弛状态需要一定的时间，每次按下弹簧必须要一定时间等其恢复到原状之后才可以进行下一次按压，这才是一次完整的循环。为两次循环动作设定最短的时间间隔，叫做防抖debounce</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">在某时间段只调用一次</td><td style="text-align:left">两次触发时间间隔超过设定值才会调用</td></tr><tr><td style="text-align:left">实例</td><td style="text-align:left">window.resize事件虽然一直触发，但是我们其实只需要某时间段内最后一次</td><td style="text-align:left">图形验证码刷新，用户一直点击刷新，但是我们设定只有点击间隔大于500ms时才会触发</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">window.scroll事件滑动时一直触发，但是我们需要控制</td><td style="text-align:left">input中输入关键字查询，每次keydown输入关键字都触发ajax查询，我们可以设定两次请求的最小间隔</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">mouseMove事件</td><td style="text-align:left">多次点击按钮放重复提交</td></tr><tr><td style="text-align:left">对于时间的理解</td><td style="text-align:left">interval是对于整个事件所占用的时间</td><td style="text-align:left">interval是对于不断循环往复的事件之间的时间间隔</td></tr><tr><td style="text-align:left">调用方式</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">差别</td><td style="text-align:left">每3000ms只调用一次和两次调用时间间隔大于3000ms,差别在于前者两次调用时间可能很近</td><td style="text-align:left">防抖用的多一点。还是要看具体的使用场景。其实很多场景差别并不那么大</td></tr></tbody></table><h4 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h4><h4 id="debounce"><a href="#debounce" class="headerlink" title="debounce"></a>debounce</h4><p>eg:input中输入字符来搜索，如果用户连续keydown，造成大量ajax，正确的做法是设置一个门槛值，两次请求的最小间隔</p><p>debounce：返回一个新函数，两次触发的时间间隔大于事先设定的值才运行实际任务</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ========================</span></span><br><span class="line"><span class="comment">// debounce</span></span><br><span class="line"><span class="comment">// 一般是一些用户操作</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, delay</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> timer = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> context = <span class="keyword">this</span>;</span><br><span class="line"><span class="keyword">var</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">clearTimeout(timer);</span><br><span class="line">timer = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">fn.apply(context, args);</span><br><span class="line">&#125;, delay);</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 得到fn的防抖版本</span></span><br><span class="line"><span class="keyword">var</span> lazyLayout = debounce(calLayout, <span class="number">3000</span>);</span><br><span class="line">$(<span class="built_in">window</span>).rezise(lazyLayout);</span><br></pre></td></tr></table></figure><h4 id="Throttle"><a href="#Throttle" class="headerlink" title="Throttle"></a>Throttle</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ========================</span></span><br><span class="line"><span class="comment">// throttle</span></span><br><span class="line"><span class="comment">// 一般是对于一些延续性的动作</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn,interval</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> last;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> curr = <span class="keyword">new</span> <span class="built_in">Date</span>().valueOf();</span><br><span class="line"><span class="keyword">if</span> (curr - last &gt; interval) &#123;</span><br><span class="line">fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">last = curr;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> throttle = throttle(updatePosition, <span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个延续性动作的停止时间</span></span><br><span class="line"><span class="comment">// TODO 注意延续性动作的停止时间和debounce也是差不多的</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">end</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> timer;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (timer) clearTimeout(timer);</span><br><span class="line">timer = setTimeout(func, <span class="number">100</span>, event);</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不要设置太多setTimeout，因为其特别耗费CPU，比较理想的做法是，将要推迟执行的代码都放在一个函数里，然后只对这个函数使用setTimeout或setInterval。</p><p>可以用于模块的生命周期<br>_.defer:延迟调用fn直到当前调用栈清空，类似setTimeout(fn,0)。对于执行开销大的计算和无阻塞UI线程的HTML渲染时候非常有用</p><p>由于事件频繁被触发，因而频繁执行DOM操作、资源加载等重行为，导致UI停顿甚至浏览器崩溃</p><p>比如：</p><ol><li><p>window对象的resize、scroll事件</p></li><li><p>拖拽时的mousemove事件</p></li><li><p>射击游戏中的mousedown、keydown事件</p></li><li><p>文字输入、自动完成的keyup事件</p></li></ol><p>实际上对于window的resize事件，实际需求大多为停止改变大小n毫秒后执行后续处理；而其他事件大多的需求是以一定的频率执行后续处理。针对这两种需求就出现了debounce和throttle两种解决办法。</p><p>这两者本质都是函数调用的频度控制器。</p><p>参考文献：</p><p><a href="http://www.cnblogs.com/fsjohnhuang/p/4147810.html" target="_blank" rel="noopener">http://www.cnblogs.com/fsjohnhuang/p/4147810.html</a></p><p><a href="https://zhuanlan.zhihu.com/p/26054718" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/26054718</a></p><p>用于测试js的性能</p><p><a href="https://jsperf.com/" target="_blank" rel="noopener">https://jsperf.com/</a><br><a href="http://www.alloyteam.com/2012/11/javascript-throttle/" target="_blank" rel="noopener">http://www.alloyteam.com/2012/11/javascript-throttle/</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JS事件循环机制1</title>
      <link href="/2018/10/13/JS%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B61/"/>
      <url>/2018/10/13/JS%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B61/</url>
      
        <content type="html"><![CDATA[<p>单线程和异步</p><a id="more"></a><h4 id="js为啥是单线程的？"><a href="#js为啥是单线程的？" class="headerlink" title="js为啥是单线程的？"></a>js为啥是单线程的？</h4><p>作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？</p><p>所以，为了避免复杂性，从一诞生，JavaScript就是单线程，这已经成了这门语言的核心特征，将来也不会改变。</p><p>为了利用多核CPU的计算能力，HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。所以，这个新标准并没有改变JavaScript单线程的本质。</p><p>单线程<br>优点：免去了频繁切换线程的开销，减少资源互抢问题。不用如多线程那样处处在意状态的同步，没有死锁的概念。<br>缺点：容易阻塞，无法利用多核CPU。</p><h4 id="为啥有异步？"><a href="#为啥有异步？" class="headerlink" title="为啥有异步？"></a>为啥有异步？</h4><p>异步编程的四种方式：<br>回调，事件监听，观察者模式（发布订阅），Promise（为异步编程提供统一的接口）</p><p>是<strong>浏览器</strong>提供了多线程的环境<br>网络请求，定时器，事件监听等任务是非常耗时的，都老老实实的排队等待执行的话，执行效率会非常的低，甚至导致页面的假死。所以，浏览器为这些耗时任务开辟了另外的线程，主要包括<strong>http请求线程</strong>，<strong>浏览器定时器线程</strong>，<strong>浏览器事件触发线程</strong>，<strong>页面渲染线程</strong><br>浏览器主线程用来页面渲染？</p><p>浏览器中js和UI共用一个线程</p><p>主线程排队执行同步任务</p><p>主线程之外有个<strong>任务队列</strong>（callback queue），任务队列中都是异步任务，主线程空了就会读取任务队列里的任务，将其加入主线程执行，如<code>setTimeout(fn,0)</code>也是在主线程所有的代码都执行完毕之后才执行，意思是尽可能早的执行fn，而不是马上执行fn。</p><p>任务产生事件：<br>http请求线程：网络请求事件，ajax success failure的回调<br>浏览器定时器线程：setTimeout的回调<br>浏览器事件触发线程：用户交互事件，如click，keypress等事件的回调</p><p>这些callback都被加入callback queue中，<strong>浏览器是多线程的，但是js是异步的</strong>，将这些任务放在任务队列里等待执行而已</p><h4 id="无阻塞Never-Blocking"><a href="#无阻塞Never-Blocking" class="headerlink" title="无阻塞Never Blocking"></a>无阻塞Never Blocking</h4><p>Event<br>JS通过events和callbacks来处理I/O,所以在等待ajax返回时依然可以处理用户输入</p><p>Event loop事件循环：主线程不断从任务队列中读取任务的过程，是实现异步的一种方式。js宿主环境的机制</p><h4 id="setTimeout运行机制"><a href="#setTimeout运行机制" class="headerlink" title="setTimeout运行机制"></a>setTimeout运行机制</h4><p>setTimeout和setInterval的运行机制：将指定的代码添加到任务队列中，等到下一轮EventLoop（主线程从任务队列中读取任务）时，再检查是否到了指定时间，如果到了就执行对应的代码，否则就等下一次Event Loop重新判断，setTimeout指定的代码，必须等到本次EventLoop执行完所有代码执行才执行</p><p>setTimeout()只是将事件插入了”任务队列”，必须等到当前代码（执行栈）执行完，主线程才会去执行它指定的回调函数。要是当前代码耗时很长，有可能要等很久，所以并没有办法保证，回调函数一定会在setTimeout()指定的时间执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(waitTask,1000)// 10000+100?还是1000</span><br><span class="line">veryLongTask();// 耗时10000</span><br></pre></td></tr></table></figure><p>setTimeout(fn,0)是立即执行吗</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(fn1,0);// fn2先执行</span><br><span class="line">fn2();</span><br></pre></td></tr></table></figure><p>必须等主线程中的同步任务和任务队列中已有事件全部处理完之后才执行setTimeout</p><p>setTimeout(fn,0)只能做到尽可能早的执行指定任务，H5新标准规定，setTimeout推迟执行的事件最少是4毫秒，小于4会自动增加到4，为了防止多个setTimeout(fn,0)连续执行造成性能问题</p><p>setTimeout(fn,0)加在你要延迟执行的函数上，或者需要页面渲染完毕才执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">document.getElementById(&apos;my-ok&apos;).onkeypress = function() &#123;</span><br><span class="line">var self = this;</span><br><span class="line">setTimeout(function() &#123;</span><br><span class="line">self.value = self.value.toUpperCase();</span><br><span class="line">&#125;, 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>js是单线程的，容易阻塞<br>将复杂的操作分片放在setTimeout(fn,0)中执行</p><p>setTimeout(fn,1000)返回一个int，可以clearTimeout来取消对应定时器</p><p>setTimeout和setInterval返回的整数值是连续的(一定环境下，比如浏览器控制台，或者js执行环境等)，也就是说，第二个setTimeout方法返回的整数值，将比第一个的整数值大1。利用这一点，可以写一个函数，取消当前所有的setTimeout。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(function() &#123;</span><br><span class="line">var gid = setInterval(clearAllTimeouts, 0);</span><br><span class="line"></span><br><span class="line">function clearAllTimeouts() &#123;</span><br><span class="line">var id = setTimeout(function() &#123;&#125;, 0);</span><br><span class="line">while (id &gt; 0) &#123;</span><br><span class="line">if (id !== gid) &#123;</span><br><span class="line">clearTimeout(id);</span><br><span class="line">&#125;</span><br><span class="line">id--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h4 id="setTimeout和Promise"><a href="#setTimeout和Promise" class="headerlink" title="setTimeout和Promise"></a>setTimeout和Promise</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(function() &#123;</span><br><span class="line">console.log(1)</span><br><span class="line">&#125;, 0);</span><br><span class="line">new Promise(function executor(resolve) &#123;</span><br><span class="line">console.log(2);</span><br><span class="line">for( var i=0 ; i&lt;10000 ; i++ ) &#123;</span><br><span class="line">i == 9999 &amp;&amp; resolve();</span><br><span class="line">&#125;</span><br><span class="line">console.log(3);</span><br><span class="line">&#125;).then(function() &#123;</span><br><span class="line">console.log(4);</span><br><span class="line">&#125;);</span><br><span class="line">console.log(5);</span><br><span class="line">// 2 3 5 4 1</span><br></pre></td></tr></table></figure><p>promise虽然是异步操作但是setTimeout是等所有的同步操作加任务队列里所有的任务都执行完之后才执行的</p><h4 id="nodejs"><a href="#nodejs" class="headerlink" title="nodejs"></a>nodejs</h4><p>i/o密集和cpu密集型<br>适合io密集型而不适合cpu密集型操作</p><p>不必耗费过多的系统开销，把精力放在处理多线程<br>宿主环境和事件驱动机制使它实现了非阻塞IO</p><p>进程-&gt;线程-&gt;协程</p><p>很多让nodejs支持多线程的方法是使用C++的addon实现，在需要进行cpu密集型计算的地方，把js代码改写成c/c++代码，但是如果开发人员对c++不是很熟悉，一来开发效率会降低不少，二来也容易出bug，而且我们知道在addon中的c++代码除了编译出错外，是很难调试的，毕竟没有vs调试c++代码方便。</p><p>v8引擎是c++写的，解析js的</p><p>js处理并发就是排队</p><p>reactor模式：NIO，selector多路复用，</p><p>nodejs为啥要用js来写呢：没有历史包袱</p><p>线程process 进程thread</p><h1 id="从setTimeout来理解事件循环"><a href="#从setTimeout来理解事件循环" class="headerlink" title="从setTimeout来理解事件循环"></a>从setTimeout来理解事件循环</h1><p>基于event loop（事件循环）的concurrency model（并发模型）</p><p>runtime（运行时）的概念：<br>由stack（栈），heap（堆），queue（队列）来组成</p><p>stack:函数执行<br>heap：Object 的allocated内存分配<br>queue：runtime有message queue，每个message对应处理这条message的function<br>event loop：在某些时间点，runtime开始处理queue上的message，message从queue中移除，其对应的function被调用，message会被作为参数传递进去，调用函数也会产生新的stack frame</p><p>一般主线程都空了之后就同步的等待messgage，来一条处理一条</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while (queue.waitForMessage()) &#123;</span><br><span class="line">queue.processNextMessage();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不可以像C那样切换线程，如果处理一条messgae比较耗时，就无法处理用户交互了，可以将messgage分片处理<br>message queue空了之后event loop再次执行？？？</p><p>message和function对应，事件发生时就会产生message，如果click事件没有handler，事件就丢弃了，不产生message</p><p>理解：<br>普通的代码都是在stack中执行的，setTimeout是加在queue中的</p><p>感觉event loop并不是主线程读取queue，主线程即stack中的代码在js加载时就一行行执行完毕了，其他的如网络请求，事件点击等，都是用户交互之后通过事件和message加入在queue中，通过和message关联的function来进行处理的</p><p>因为你不可能在stack中新增function吗？</p><p>Queue：<br>Callback queue：任务队列<br>Single thread：单线程<br>Event Loop：事件循环<br>macroTask：</p><p>microTask：</p><p>callstack：<br>I/O<br>JS V8 engine</p><p>Stack，heap，message queue，runtimes（web worker 或 cross-origin iframe）</p><p>runtimes：不同的运行时环境有不同的Stack，heap，message queue。可以通过postMessage来传递消息</p><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop</a></p><p>参考文献：<br><a href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2014/10/event-loop.html</a></p><p><a href="http://caibaojian.com/interesting-interview.html" target="_blank" rel="noopener">关于setTimeout的面试</a></p><p><a href="http://caibaojian.com/about-settimeout.html" target="_blank" rel="noopener">关于setTimeout你不知道的事</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>微信开发实用指南3-手机浏览器唤起微信app登录的可行性</title>
      <link href="/2018/10/12/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E6%8C%87%E5%8D%973-%E6%89%8B%E6%9C%BA%E6%B5%8F%E8%A7%88%E5%99%A8%E5%94%A4%E8%B5%B7%E5%BE%AE%E4%BF%A1app%E7%99%BB%E5%BD%95%E7%9A%84%E5%8F%AF%E8%A1%8C%E6%80%A7/"/>
      <url>/2018/10/12/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E6%8C%87%E5%8D%973-%E6%89%8B%E6%9C%BA%E6%B5%8F%E8%A7%88%E5%99%A8%E5%94%A4%E8%B5%B7%E5%BE%AE%E4%BF%A1app%E7%99%BB%E5%BD%95%E7%9A%84%E5%8F%AF%E8%A1%8C%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<p>微信的地位越来越高，隔不了多久就有大佬问，为什么你们的手机端H5没有微信登录的入口，压力很大呀。</p><p>可能是安全问题或者其他考虑，微信在网页端只提供了扫码登录的入口，即使在手机端集成了微信登录，用户点开也会很奇怪，这个码只有PC端的样式，看起来很奇怪，而且怎么用我的手机微信来扫这个手机浏览器这个码呢？而且即使可以扫码成功也无法登录成功，所以看了大部分的公司都选择在手机浏览器隐藏了微信登录的入口。</p><p>但是细心的PM发现，京东居然有微信登录的入口，但是一般也只是在QQ浏览器或者系统浏览器中支持，可以直接打开手机上的微信app，但是在无痕模式或者其他的浏览器也无法成功。</p><p>前端无隐私，让我们来F12来看看他们是怎么做到的。</p><p><img src="/assets/wap_wxlogin.png" alt=""></p><p>可以发现，京东的微信登录并没有什么特别的，也是各种302跳转最后到了 <a href="https://open.weixin.qq.com/sns/explorer_broker?appid=wx2f5d8f9715c59d10&amp;redirect_uri=https%3A%2F%2Fplogin.m.jd.com%2Fcgi-bin%2Fml%2Fwxcallback%3Flsid%3Dq9ibchzrnbivxypneji7r4sxusp24wrv&amp;response_type=code&amp;scope=snsapi_userinfo&amp;state=smr1qm3p&amp;connect_redirect=1的" target="_blank" rel="noopener">https://open.weixin.qq.com/sns/explorer_broker?appid=wx2f5d8f9715c59d10&amp;redirect_uri=https%3A%2F%2Fplogin.m.jd.com%2Fcgi-bin%2Fml%2Fwxcallback%3Flsid%3Dq9ibchzrnbivxypneji7r4sxusp24wrv&amp;response_type=code&amp;scope=snsapi_userinfo&amp;state=smr1qm3p&amp;connect_redirect=1 </a>这个页面。最重要的是这个是微信的域名，所以我们可以知道，这个跳转是微信主动触发的。</p><p>怪不得说京东是微信亲儿子嘛。让我们看看这个页面做了什么事。</p><p><img src="/assets/wap_wxlogin2.png" alt="">前面都是一些环境的判断，而且这些都是微信方帮忙实现的。最重要的是<code>location.href = &#39;weixin://dl/business/?ticket=tb15388ef1a6e07db69a0d57a87345f93&#39;</code></p><p>前端是可以实现打开微信app的，但是如何打开某个特定的页面就需要app端来支持了，而微信端为京东做了特殊的处理，可以做到直接打开微信的app中京东的微信授权页面。</p><p>所以如果我们的业务也需要实现这个功能，就需要向微信申请了。</p><p>另外一个更激进的就是QQ了，公告说是为了一些不安全因素，在18年年初完全下掉了wap端网页登录的方式，现在wap端的QQ登录都采用直接打开QQ app的方式来授权登录。在某些非系统浏览器中因为无法打开app就悲剧了。还是觉得有些激进了些。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 微信开发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>微信开发实用指南3-微信分享功能</title>
      <link href="/2018/09/28/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E6%8C%87%E5%8D%973-%E5%BE%AE%E4%BF%A1%E5%88%86%E4%BA%AB%E5%8A%9F%E8%83%BD/"/>
      <url>/2018/09/28/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E6%8C%87%E5%8D%973-%E5%BE%AE%E4%BF%A1%E5%88%86%E4%BA%AB%E5%8A%9F%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<p>接入js-sdk的分享功能，分享出去的地址会变成</p><p><a href="https://i.mi.com/static2?filename=MicloudWebBill/event/recruit/index.html&amp;from=singlemessage&amp;isappinstalled=0" target="_blank" rel="noopener">https://i.mi.com/static2?filename=MicloudWebBill/event/recruit/index.html&amp;from=singlemessage&amp;isappinstalled=0</a></p><p>后台签名如果是写死url的话，第二次分享就会有签名错误的问题，导致分享出去用户看到的description和头图都没有了，变成了默认的url地址。</p><p>所以后端需要实时获取url地址来加密签名，以免导致二次分享出错的问题</p><p>一般给后端传入当前<code>location.href</code></p><p>建议查看<a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421141115" target="_blank" rel="noopener">https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421141115</a>中的<strong>附录5-常见错误及解决方法</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> 微信开发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>微信开发实用指南2-小程序的入口</title>
      <link href="/2018/09/22/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E6%8C%87%E5%8D%972-%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%85%A5%E5%8F%A3/"/>
      <url>/2018/09/22/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E6%8C%87%E5%8D%972-%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%85%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<p>用户在使用微信时，打开小程序的体验要比打开H5页面的体验要好得多，老板希望在H5页面可以直接打开小程序。</p><p>查阅资料发现，至目前为止，现在H5和小程序互相跳转的唯二方式如下：<br><a id="more"></a></p><p>1.可以在H5的页面中放一个小程序的二维码，用户<strong>长按识别</strong>小程序二维码就可以跳转到小程序中</p><p>2.或者把H5页面嵌入到小程序的web-view中，在H5页面中通过调用JS-SDK的<code>wx.navigateToMiniProgram</code>跳转到小程序的native页面中。注意此时行为都发生在小程序中，H5的域名需要在小程序的域名校验名单中。</p><p>除了以上入口，还有：</p><p>1.用户在小程序中点分享给朋友，还可以把小程序发在消息中。</p><p>2.在公众号文章中可以直接打开小程序。</p><p>但是非小程序内嵌的H5是不能直接打开小程序的。</p><p>参考文档：</p><p><a href="https://developers.weixin.qq.com/miniprogram/dev/component/web-view.html" target="_blank" rel="noopener">微信的web-view API</a></p><p><a href="https://www.jianshu.com/p/50657f9af5b4" target="_blank" rel="noopener">小程序内嵌网页的方法</a></p><p>这下可以不用担心啦。</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>微信开发实用指南1-前言</title>
      <link href="/2018/09/18/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E6%8C%87%E5%8D%971-%E5%89%8D%E8%A8%80/"/>
      <url>/2018/09/18/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E6%8C%87%E5%8D%971-%E5%89%8D%E8%A8%80/</url>
      
        <content type="html"><![CDATA[<p>现在经济不景气，小公司拿不到投资，连iOS开发和andriod开发都招不起，而微信凭借着众多的用户，成为了开发的热土，一个创业公司可以没有App，但一定会需要先在微信里试水，是公司获客的最佳渠道。</p><p>这个系列记录了微信开发遇到的问题，和产品狗相爱相杀的往事。</p><p>目录（也是产品狗的那些呐喊）：</p><p>0.开发前的了解</p><p>1.我想要在微信的H5页面里直接打开小程序</p><p>2.我想要做活动页分享给好友</p><p>3.我想小程序和webview的登录态互相传递</p><p>…</p><h4 id="关于H5的那些争执"><a href="#关于H5的那些争执" class="headerlink" title="关于H5的那些争执"></a>关于H5的那些争执</h4><p>H5，在我们大前端眼中实际是HTML5的缩写，其实HTML已经是缩写了，缩完再缩，就变成了他们口中的H5，实际上只有中国人才会这么称呼，要是跟老外说H5，H five，他们就懵逼了。</p><p>比如App，并不是任何词组的缩写，而是Application的简读，只有中国人才会读APP。还有那个UGG的鞋子，实际上应该念‘阿哥’，但是呢，你开心就好。嗯，啥时候出一个程序员英语装逼指南应该会更受欢迎吧。</p><p>说回H5，对于FE来说，HTML5只不过是一种语言而已。</p><p>对于PM还有其他非前端的开发人员来说，H5指的是手机端上的网页。</p><p>对于运营妹子来说，嗯，H5呀，我也会做哦。实际上他们说的是，可以拖拖拽拽，像做PPT一样生成的页面，便于在微信里快速传播。</p><p>虽然他们说的都不对，但他们开心就好，能听懂就好。</p><h4 id="关于微信公众平台和开放平台"><a href="#关于微信公众平台和开放平台" class="headerlink" title="关于微信公众平台和开放平台"></a>关于微信公众平台和开放平台</h4><p>公众平台：<a href="https://mp.weixin.qq.com/" target="_blank" rel="noopener">https://mp.weixin.qq.com/</a> 主要用在公众号，运营妹子登的多，我们需要开发微信公众号的一些活动页面时也需要在里面配置一些东西</p><p>开放平台：<a href="https://open.weixin.qq.com/" target="_blank" rel="noopener">https://open.weixin.qq.com/</a> 主要用在各种开发上，app，小程序，公众号都包括</p><h4 id="开发公众号页面的配置"><a href="#开发公众号页面的配置" class="headerlink" title="开发公众号页面的配置"></a>开发公众号页面的配置</h4><p>有的公号后台都是运营或PM来管，都不让我们FE来登录。下面是我们开发必要的一些信息。</p><p><img src="/assets/微信公众平台-基本配置.png" alt=""></p><h5 id="首页-gt-开发-gt-基本配置"><a href="#首页-gt-开发-gt-基本配置" class="headerlink" title="首页=&gt;开发=&gt;基本配置"></a>首页=&gt;开发=&gt;基本配置</h5><h6 id="公众号开发信息"><a href="#公众号开发信息" class="headerlink" title="公众号开发信息"></a>公众号开发信息</h6><p>AppId用在很多地方</p><p>AppSecret只能放在服务端，前端代码对攻击者来说完全是透明的，只要是跟AppSecret相关的接口都一定是后端调微信的接口。</p><p>需要添加你的IP在Ip白名单里，这样才可以获取acces_token来测试</p><h6 id="服务器配置"><a href="#服务器配置" class="headerlink" title="服务器配置"></a>服务器配置</h6><p>不要配置这个，以免运营妹子的自动回复没了</p><h6 id="已绑定的微信开放平台帐号"><a href="#已绑定的微信开放平台帐号" class="headerlink" title="已绑定的微信开放平台帐号"></a>已绑定的微信开放平台帐号</h6><p>有用到unionId的话会需要这部分</p><h5 id="首页-gt-开发-gt-开发者工具"><a href="#首页-gt-开发-gt-开发者工具" class="headerlink" title="首页=&gt;开发=&gt;开发者工具"></a>首页=&gt;开发=&gt;开发者工具</h5><p><img src="/assets/微信公众平台-开发者工具.png" alt=""></p><p>下载一个微信开发者工具</p><p>开发者工具相关信息：<a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1455784140" target="_blank" rel="noopener">https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1455784140</a></p><p>关注公众平台安全助手</p><p>让管理者开通公号开发者权限</p><p>基本工作完成就可以用开发者工具调试公号页面啦</p><h4 id="完成需求的步骤"><a href="#完成需求的步骤" class="headerlink" title="完成需求的步骤"></a>完成需求的步骤</h4><p>1.当PM抛出一个需求时，我们应该看看<strong>当前的公众号是否有相应的权限</strong>。</p><p>不要设计接口、讨论开发了半天才发现这个公号根本没有这个接口权限。</p><p>登录微信公众平台=&gt;开发=&gt;接口权限</p><p>或者综合的接口权限说明： <a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1433401084" target="_blank" rel="noopener">https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1433401084</a></p><p>选择设置=&gt;系统代理时，fiddler代理并不能生效。可以选择手动设置代理，ipconfig获取本机ip，ip:8888。</p><h5 id="订阅号和服务号的区别："><a href="#订阅号和服务号的区别：" class="headerlink" title="订阅号和服务号的区别："></a>订阅号和服务号的区别：</h5><p>简言之，订阅号会被收纳起来，服务号推送消息会直接出现的你的消息列表中</p><p>订阅号比如：咪蒙。。。这类写文章的。</p><p>服务号比如：小米商城，招行信用卡，京医通等等。</p><p>其他的区别参见：<br><a href="https://www.zhihu.com/question/21289814" target="_blank" rel="noopener">https://www.zhihu.com/question/21289814</a></p><p>2.思索一下在生活中有没有看到过类似的别人完成的需求。</p><p>PM也是人，他们设计肯定也是看别人发了啥他们也要，他见过的咱们也肯定见过啊，没有见过就让他给找例子。</p><p>3.在chrome中打开链接，F12看下源码</p><p>反正咱们前端都是小透明，如果运气好没压缩的话，很easy就可以看懂了。</p><p>其实最大的问题是刚开始因为刚上手，不太明确前端和后端的职责，看看别人页面的network就可以胸有成竹的指使后端我需要这个你得给我返回啦~</p><p>有套路，不迷路。</p><h4 id="经常需要查看的文档们，google不如看文档："><a href="#经常需要查看的文档们，google不如看文档：" class="headerlink" title="经常需要查看的文档们，google不如看文档："></a>经常需要查看的文档们，google不如看文档：</h4><p>公众平台综合技术文档：<a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1472017492_58YV5" target="_blank" rel="noopener">https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1472017492_58YV5</a></p><p>JS-SDK：<a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421141115" target="_blank" rel="noopener">https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421141115</a></p><p>JS接口签名校验工具：<a href="https://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=jsapisign&amp;token=&amp;lang=zh_CN" target="_blank" rel="noopener">https://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=jsapisign&amp;token=⟨=zh_CN</a></p><p>接口调试工具：<a href="https://mp.weixin.qq.com/debug?token=1156200581&amp;lang=zh_CN" target="_blank" rel="noopener">https://mp.weixin.qq.com/debug?token=1156200581⟨=zh_CN</a></p><p>获取JSTicket：<a href="https://api.weixin.qq.com/cgi-bin/ticket/getticket?access_token={Access_TOKEN}&amp;type=jsapi" target="_blank" rel="noopener">https://api.weixin.qq.com/cgi-bin/ticket/getticket?access_token={Access_TOKEN}&amp;type=jsapi</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 微信开发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JS异步加载和script标签属性的深层解析</title>
      <link href="/2018/09/18/JS%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD%E5%92%8Cscript%E6%A0%87%E7%AD%BE%E5%B1%9E%E6%80%A7%E7%9A%84%E6%B7%B1%E5%B1%82%E8%A7%A3%E6%9E%90/"/>
      <url>/2018/09/18/JS%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD%E5%92%8Cscript%E6%A0%87%E7%AD%BE%E5%B1%9E%E6%80%A7%E7%9A%84%E6%B7%B1%E5%B1%82%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>JS异步加载和script标签属性的深层解析<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">&lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;script src=&quot;https://www.evacoder.com/404.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">// console还是会执行，但是会先返回js 404之后才执行。</span><br><span class="line">// 浏览器确实是按script标签的顺序，依次加载执行的，所以经常说需要将script放在body的底部，防止阻塞页面。</span><br><span class="line">console.log(1);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p>只要不存在defer和async属性，浏览器都会按照script出现的顺序依次解析。</p><p>script加上defer或async属性之后，会先console，才返回404</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;https://www.evacoder.com/b.js&quot; async defer=&quot;defer&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h4><p>脚本可以延迟到<strong>文档完全被解析</strong>和显示之后才执行。表示脚本在执行时不会影响页面的构造。立即下载，延迟解析（遇到<code>&lt;/html&gt;</code>之后才执行）。</p><p>出现多个script defer时，延迟解析也是按照出现的顺序来解析的？在DOMContentLoaded之前解析？</p><p>规定是这么规定，但是现实却是无法确定谁先解析，甚至都不一定在DOMContentLoaded之前解析。所以一般最好只包含一个defer script。</p><p>浏览器兼容性：</p><p>IE4-不支持，兼容性不错，但是最好还是将defer script放在body底部。</p><p>那请求发出的时机呢？？</p><p>下载时机：立即下载</p><p>执行时机：</p><h4 id="async"><a href="#async" class="headerlink" title="async"></a>async</h4><p>async的意思是应该立即下载脚本，但是不应妨碍页面其他的操作。注意是<strong>下载</strong>而不是<strong>加载</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;https://www.evacoder.com/1.js&quot; async&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;https://www.evacoder.com/2.js&quot; async&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>不能保证1.js在2.js之前解析，所以需要保证两者之间互不依赖。</p><p>一定会在document.load之前执行，但是可能会在DOMContentLoaded触发之前或之后执行。</p><p>下载和解析：</p><p>aynsc：立即下载，到底何时执行？加载完就执行？遇到阻塞的情况就最后执行？不阻塞就立刻执行吗？</p><p>defer：立即下载，遇到<code>&lt;/html&gt;</code>之后才执行？所有元素解析完成之后，DOMContentLoaded触发之前执行。类似放在最底部，但是是先下载的。</p><p>最大6个资源一起下载</p><p>window.onload:</p><p>document.onload：</p><p>DOMLoading：浏览器开始解析dom</p><p>DOMInteractive：浏览器解析好dom树</p><p>DOMContentLoaded：同步的js执行完毕</p><h4 id="sdk的版本控制"><a href="#sdk的版本控制" class="headerlink" title="sdk的版本控制"></a>sdk的版本控制</h4><p>引入一个不变的小的js，设置超长缓存或不设置缓存？</p><p>在其中通过document.createElement(‘script’)来异步加载js，这个时候生成的js本来就是aynsc的，何时加载完已经和window.onload等一点关系都没有了，此时可以通过script.onload来获取加载完成的状态，ie可以使用onreadystatechange</p><p>业务方加载了你的js sdk，如何在不用通知业务的情况下，就可以进行版本更新?</p><p>JS sdk load完成之前，如何调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">load js</span><br><span class="line"></span><br><span class="line">loadSDK(function()&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>通过动态插入script标签的方式</p><p>加载完成之前会阻止onload事件的出发，而现在很多页面的代码都在onload时</p><p>DOMContentLoaded：页面(document)已经解析完成，页面中的dom元素已经可用。但是页面中引用的图片、subframe可能还没有加载完</p><p>onLoad：页面的所有资源都加载完毕（包括图片）</p><p>async是html5的新属性，async 属性规定一旦脚本可用，则会异步执行（一旦下载完毕就会立刻执行）。</p><p>需要注意的是async 属性仅适用于外部脚本（只有在使用 src 属性时）</p><p>noscript 元素用来定义在脚本未被执行时的替代内容（文本）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;noscript&gt;Your browser does not support JavaScript!&lt;/noscript&gt;</span><br></pre></td></tr></table></figure><h4 id="readyState"><a href="#readyState" class="headerlink" title="readyState"></a>readyState</h4><p><a href="https://blog.csdn.net/u011700203/article/details/47656857" target="_blank" rel="noopener">https://blog.csdn.net/u011700203/article/details/47656857</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JS中的面向对象5-Object.create和new Object</title>
      <link href="/2018/07/18/JS%E4%B8%AD%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A15-Object-create%E5%92%8Cnew-Object/"/>
      <url>/2018/07/18/JS%E4%B8%AD%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A15-Object-create%E5%92%8Cnew-Object/</url>
      
        <content type="html"><![CDATA[<p>Object.create和new Object的区别<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var Person = function(age) &#123;</span><br><span class="line">this.age=age;</span><br><span class="line">this.say=function()&#123;console.log(&apos;hello&apos;);&#125;</span><br><span class="line">&#125;;</span><br><span class="line">var p=new Person(11);</span><br><span class="line">var p1 = Object.create(p);</span><br></pre></td></tr></table></figure></p><p><img src="/assets/proto1.png" alt=""></p><p><img src="/assets/proto2.png" alt=""></p><p>从console中可以发现，p成了p1的原型对象，p中的属性和方法都成了p1的原型方法。</p><p>Object.create的作用就是传入一个对象，给创建的新对象提供<code>__proto__</code>引用</p><p>多用在对象的继承中。</p><p>Object.create的实现方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">if (!Object.create) &#123;</span><br><span class="line">Object.create = function(proto, propertiesObject) &#123;</span><br><span class="line">if (typeof proto !== &apos;object&apos; &amp;&amp; typeof proto !== &apos;function&apos;) &#123;</span><br><span class="line">throw new TypeError(&apos;Object prototype may only be an Object:&apos; + proto);</span><br><span class="line">&#125; else if (proto === null) &#123;</span><br><span class="line">throw new Error(&quot;This browser&apos;s implementation of Object.create is a shim and doesn&apos;t support &apos;null&apos;&quot;);</span><br><span class="line">&#125;</span><br><span class="line">if (typeof propertiesObject != &apos;undefined&apos;) &#123;</span><br><span class="line">throw new Error(&quot;This browser&apos;s implementation of Object.create is a shim and doesn&apos;t support a second argument&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function F() &#123;&#125;;</span><br><span class="line">F.prototype = proto;</span><br><span class="line">return new F();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JS中的面向对象4-继承的实现</title>
      <link href="/2018/07/15/JS%E4%B8%AD%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A14-%E7%BB%A7%E6%89%BF%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
      <url>/2018/07/15/JS%E4%B8%AD%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A14-%E7%BB%A7%E6%89%BF%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>理解了基本发展历史和深层原理，接下来就是生生不息的原因，继承部分啦。<br><a id="more"></a></p><p>我们知道JS是单继承的，Object.prototype是原型链的顶端，所有对象从它继承了包括toString等方法和属性。</p><p>Object本身是类当然也是构造函数，构造函数嘛当然是继承自Function.prototype</p><p>而Function也是对象，继承自Object.prototype。</p><p>这里就有一个鸡和蛋的问题：到底是先有Object还是先有Function。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span> <span class="keyword">instanceof</span> <span class="built_in">Function</span> <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Function</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Function</span>.prototype===<span class="built_in">Function</span>.__proto__ <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.__proto__ === <span class="literal">null</span> <span class="comment">// true 说明原型链到Object.prototype终止。</span></span><br></pre></td></tr></table></figure><p>上篇中我们了解到原型链是实现继承的主要方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.property = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype = &#123;</span><br><span class="line"><span class="keyword">constructor</span>: SubType,</span><br><span class="line">getSuperVal: function() &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.property;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.subProperty = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType(); <span class="comment">// 重点</span></span><br><span class="line">SubType.property.getSubVal = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.subProperty;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sub1 = <span class="keyword">new</span> SubType();</span><br><span class="line">sub1.getSuperVal(); <span class="comment">// true</span></span><br><span class="line">sub1.getSubVal(); <span class="comment">// false</span></span><br><span class="line">sub1 <span class="keyword">instanceof</span> SubType; <span class="comment">// true</span></span><br><span class="line">sub1 <span class="keyword">instanceof</span> SuperType; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>回顾下new的作用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> instance=<span class="keyword">new</span> Person();</span><br><span class="line"><span class="comment">// 实际经历了如下四步：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.创建空对象</span></span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.设置原型链，指向类【构造函数】的原型</span></span><br><span class="line">instance.__proto__ = Person.prototype;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.让构造函数Person的this指向实例instance,执行构造函数Person的函数体</span></span><br><span class="line"><span class="keyword">var</span> p = Person.call(instance);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.判断Person的返回值类型</span></span><br><span class="line"><span class="comment">// 值类型就不要了，还是返回instance</span></span><br><span class="line"><span class="comment">// 如果是引用类型，替换掉instance返回引用类型</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span> p ==<span class="string">'object'</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> p</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以上文中重点new实现了如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SubType.prototype.__proto__ = SuperType.prototype;</span><br><span class="line">SuperType.call(SubType.prototype);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JS中的面向对象3-原型和构造函数的关系</title>
      <link href="/2018/06/30/JS%E4%B8%AD%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A13-%E5%8E%9F%E5%9E%8B%E5%92%8C%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%85%B3%E7%B3%BB/"/>
      <url>/2018/06/30/JS%E4%B8%AD%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A13-%E5%8E%9F%E5%9E%8B%E5%92%8C%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%85%B3%E7%B3%BB/</url>
      
        <content type="html"><![CDATA[<p>本系列是学习整理js中的面向对象的第3篇，原型和构造函数的关系，接下来就要更深入的探究其中的原理了。<br><a id="more"></a></p><h4 id="原型和构造函数到底有什么关系？"><a href="#原型和构造函数到底有什么关系？" class="headerlink" title="原型和构造函数到底有什么关系？"></a>原型和构造函数到底有什么关系？</h4><p><img src="/assets/proto3.png" alt=""></p><p>构造函数有原型对象，Person.prototype，此对象中有属性constructor，指向了构造函数Person，构造函数又有原型…。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person.prototype.constructor===Person;//true</span><br><span class="line">Person.prototype.constructor.prototype.constructor.prototype===Person.prototype; // true 两者相依相存</span><br></pre></td></tr></table></figure><p>构造函数是为了方便创建对象。</p><p>构造函数通过prototype来存储要共享的属性和方法。</p><h4 id="prototype和-proto-（-Prototype-）又有什么关系？"><a href="#prototype和-proto-（-Prototype-）又有什么关系？" class="headerlink" title="prototype和__proto__（[[Prototype]]）又有什么关系？"></a>prototype和__proto__（[[Prototype]]）又有什么关系？</h4><p><strong>类和构造函数</strong>：比如Array你可以看做一个类，也可以看成是Array的构造函数。</p><p><code>__proto__</code>:是<strong>实例</strong>的属性，指向构造函数的原型 constructor.prototype，每个对象都有。所以我们暂且称它为原型引用。</p><p><code>prototype</code>:原型对象，只有函数才有prototype，所以<strong>原型是构造函数（类）的原型</strong>。</p><p>我们先来回忆下new操作符到底做了什么【参见js中的面向对象2】。</p><p>就是new操作符实现了实例的<code>__proto__</code>指向类的原型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// __proto__是new出来的实例内部包含的一个指针，指向constructor.prototype。每个对象都有</span></span><br><span class="line">p.__proto__ === Person.prototype <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">p.prototype <span class="comment">// undefined 只有函数才有prototype</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(p)=== p.__proto__===Person.prototype <span class="comment">// Object.getPrototypeOf得到实例的__proto__</span></span><br><span class="line"><span class="comment">// 字面意思是获取实例的原型prototype，实际是获取原型的引用。</span></span><br><span class="line"><span class="comment">// 因为实例没有原型，只有原型引用__proto__，类（构造函数）才有原型prototype</span></span><br><span class="line"></span><br><span class="line">Person.prototype.isPrototypeOf(p) <span class="comment">// true isPrototypeOf 原型对象是构造函数的原型</span></span><br></pre></td></tr></table></figure><h4 id="prototype和实例又有什么关系呢？"><a href="#prototype和实例又有什么关系呢？" class="headerlink" title="prototype和实例又有什么关系呢？"></a>prototype和实例又有什么关系呢？</h4><p>prototype是用来保存类的公共属性和方法的，其实也是个特殊的对象，可以理解为和实例是一个level的。但是他们之间有什么关系和区别呢</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 联系</span><br><span class="line">p.constructor === Person.prototype.constructor === Person; // true 两者具有相同的构造函数</span><br><span class="line"></span><br><span class="line">p.__proto__ === Person.prototype; // true 实例的原型引用指向了原型对象</span><br><span class="line"></span><br><span class="line">// 区别</span><br><span class="line">Person.prototype.__proto__===Person.prototype; // flase 原型的原型引用不再是原型对象啦</span><br></pre></td></tr></table></figure><p>既然是一个level为啥不相等呢？因为原型肩负了继承的重要责任。</p><p>正是通过<code>Person.prototype.__proto__.__proto__.__proto__.__proto__.__proto__</code>来一层层向上查找父类，这就是所谓的<strong>原型链</strong></p><p>所以继承的写法就是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person.prototype=new Parent();</span><br></pre></td></tr></table></figure><p>结合前面new的作用，可以明白此处实际上的最重要的作用就是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person.prototype.__proto__=Parent.prototype;// 将原型引用指向父类的原型</span><br><span class="line">// Person.__proto__总是指向父类</span><br></pre></td></tr></table></figure><p>调用p.name时，会从p自身的属性中寻找是否有name，没有则到p对应的原型中寻找<br><code>obj.__proto__.__proto__.__proto__</code>形成原型链，可以通过instanceof来验证obj是否是构造函数（类）的实例</p><p>继承的细节将在下节来详细解释</p><h4 id="Object和Function的关系及特殊的原型对象"><a href="#Object和Function的关系及特殊的原型对象" class="headerlink" title="Object和Function的关系及特殊的原型对象"></a>Object和Function的关系及特殊的原型对象</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1= &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> obj2= <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">obj1.__proto__ === <span class="built_in">Object</span>.prototype <span class="comment">// true 指向构造函数的原型</span></span><br><span class="line">obj2.__proto__ === <span class="built_in">Object</span>.prototype <span class="comment">// true</span></span><br><span class="line">obj1.toString === <span class="built_in">Object</span>.prototype.toString === obj2.__proto__.toString <span class="comment">// true 调用实例方法实际上是调用原型的方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fn1=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> fn2=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">fn1.constructor===<span class="built_in">Function</span></span><br><span class="line">fn1.__proto__===<span class="built_in">Function</span>.prototype</span><br><span class="line">fn1__proto__===fn2.__proto__ <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">fn1.prototype.constructor=fn1;</span><br><span class="line">fn1.prototype.constructor.name <span class="comment">// fn1</span></span><br><span class="line">fn2.prototype.constructor.name <span class="comment">// fn2</span></span><br><span class="line">fn1.prototype===fn2.prototype <span class="comment">// false</span></span><br><span class="line">fn1.prototype===&#123;</span><br><span class="line"><span class="comment">// fn1</span></span><br><span class="line"><span class="keyword">constructor</span>:function()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="comment">// 指向了Object.prototype</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fn1.prototype.__proto__ === <span class="built_in">Object</span>.prototype</span><br><span class="line"><span class="comment">// 所以Function 继承自Object</span></span><br></pre></td></tr></table></figure><h4 id="原型的相关方法"><a href="#原型的相关方法" class="headerlink" title="原型的相关方法"></a>原型的相关方法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// prototype相关方法</span></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(p) === Person.prototype; <span class="comment">// true</span></span><br><span class="line">Person.prototype.isPrototypeOf(p); <span class="comment">// true</span></span><br><span class="line">p.hasOwnProperty(<span class="string">'name'</span>); <span class="comment">// false 是原型属性</span></span><br><span class="line">p.salary = <span class="number">25000</span>;</span><br><span class="line">p.hasOwnProperty(<span class="string">'salary'</span>); <span class="comment">// true 是实例属性</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过in操作符和hasOwnProperty可以判断属性到底是在实例还是原型中</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasPrototypeProperty</span>(<span class="params">obj, name</span>) </span>&#123; <span class="comment">// 判断是否是原型属性</span></span><br><span class="line"><span class="keyword">return</span> !obj.hasOwnProperty(name) &amp;&amp; (name <span class="keyword">in</span> obj);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 因为in操作符包括原型属性，所以在遍历时eslint不建议使用for-in，如果必须使用也需要用hasOwnProperty来过滤下</span></span><br><span class="line"></span><br><span class="line">p <span class="keyword">instanceof</span> Person; <span class="comment">// true 实例是否是类的实例</span></span><br></pre></td></tr></table></figure><h4 id="基本类型判断"><a href="#基本类型判断" class="headerlink" title="基本类型判断"></a>基本类型判断</h4><p>但是instanceof也有力不从心的时候，回忆下我们判断isArray，isDate等类型的方法，instanceof假定只有一个全局作用域，在页面中有多个frame时，存在两个以上的全局执行环境，一个框架向另一个框架传值时，会有不一样的构造函数。建议使用以下方式来判断。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isType</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="params">obj</span> =&gt;</span> <span class="built_in">Object</span>.prototype.toString.call(obj) === <span class="string">`[object <span class="subst">$&#123;type&#125;</span>]`</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> isObject = isType(<span class="string">'Object'</span>);</span><br><span class="line"><span class="keyword">const</span> isString = isType(<span class="string">'String'</span>);</span><br><span class="line"><span class="keyword">const</span> isArray = <span class="built_in">Array</span>.isArray || isType(<span class="string">'Array'</span>);</span><br><span class="line"><span class="keyword">const</span> isFunction = isType(<span class="string">'Function'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; isObject, isString, isArray, isFunction &#125;;</span><br><span class="line"><span class="comment">// toString只能通过Object.prototype.toString.call来调用才能判断类型</span></span><br></pre></td></tr></table></figure><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">age, name, friends</span>) </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line"><span class="keyword">this</span>.friends = friends;</span><br><span class="line"><span class="comment">// 只在初始化时判断，不需要把每个方法都判断TODO</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.sayName != <span class="string">'function'</span>) &#123;</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 局部添加方法和属性会立即生效，重写整个原型对象会切断现有实例和原型的关系</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在已经创建实例的情况下，使用Person.prototype=&#123;&#125;这种对象字面量，相当于重写原型</span></span><br><span class="line"><span class="comment">// 会切断现有实例和原型之间的关联</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考文献：<br><a href="https://github.com/creeperyang/blog/issues/9" target="_blank" rel="noopener">https://github.com/creeperyang/blog/issues/9</a><br><a href="https://www.zhihu.com/question/34183746" target="_blank" rel="noopener">https://www.zhihu.com/question/34183746</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JS中的面向对象2-new操作符做了什么</title>
      <link href="/2018/06/22/JS%E4%B8%AD%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A12-new%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88/"/>
      <url>/2018/06/22/JS%E4%B8%AD%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A12-new%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88/</url>
      
        <content type="html"><![CDATA[<p>本系列是学习整理js中的面向对象的第2篇，new操作符做了什么<br><a id="more"></a></p><p>new运算符的作用是创建一个类的实例（类可以是我们自定义的对象类型Person，也可以是具有构造函数的内置对象（如Object，Array，Function））</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function Person(age,name)&#123;</span><br><span class="line">this.age = age;</span><br><span class="line">this.name = name;</span><br><span class="line">&#125;</span><br><span class="line">var instance =new Person();</span><br><span class="line"></span><br><span class="line">var o1 = new Object();</span><br></pre></td></tr></table></figure><p>实际经历4个步骤</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var instance=new Person();</span><br><span class="line">// 实际经历了如下四步：</span><br><span class="line"></span><br><span class="line">// 1.创建空对象</span><br><span class="line">var instance = new Object();</span><br><span class="line"></span><br><span class="line">// 2.设置原型链，指向类【构造函数】的原型</span><br><span class="line">instance.__proto__ = Person.prototype;</span><br><span class="line"></span><br><span class="line">// 3.让构造函数Person的this指向实例instance,执行构造函数Person的函数体</span><br><span class="line">var p = Person.call(instance);</span><br><span class="line"></span><br><span class="line">// 4.判断Person的返回值类型</span><br><span class="line">// 值类型就不要了，还是返回instance</span><br><span class="line">// 如果是引用类型，替换掉instance返回引用类型</span><br><span class="line">if(typeof p ==&apos;object&apos;)&#123;</span><br><span class="line">return p</span><br><span class="line">&#125;else&#123;</span><br><span class="line">return instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="如果把随便一个函数当作构造函数，用new来调用"><a href="#如果把随便一个函数当作构造函数，用new来调用" class="headerlink" title="如果把随便一个函数当作构造函数，用new来调用"></a>如果把随便一个函数当作构造函数，用new来调用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 返回值类型</span><br><span class="line">function say(name) &#123;</span><br><span class="line">console.log(name);</span><br><span class="line">// return name; 加不加这个都返回空的say类型的obj:&#123;&#125;,没有return 相当于return undefined，值类型，丢弃。</span><br><span class="line">&#125;</span><br><span class="line">var instance = new say(&apos;Eva&apos;); // 同上返回say类型的obj:&#123;&#125;</span><br><span class="line"></span><br><span class="line">instance instanceof say; // true</span><br><span class="line">instance.__proto__ === say.prototype; // true</span><br><span class="line"></span><br><span class="line">function CreatePerson(age, name) &#123;</span><br><span class="line">var p = &#123; age: age, name: name &#125;;</span><br><span class="line">return p; // 返回引用类型，原有的实例被丢弃，因为原有的instance被丢弃</span><br><span class="line">// 此处的实例和CreatPerson并无原型链的关系，只是普通的Object对象</span><br><span class="line">// 所以可以理解上文中的寄生模式和稳妥模式都不再有原型链关系的原因啦。简言之，new无效则原型无效</span><br><span class="line">&#125;</span><br><span class="line">var p = new CreatePerson(11, &apos;Eva&apos;); // &#123;age: 11, name: &quot;Eva&quot;&#125; 但是注意此处不是CreatePerson类的对象了，就是普通的Object对象</span><br><span class="line"></span><br><span class="line">p.__proto__ == CreatePerson.prototype // false;</span><br></pre></td></tr></table></figure><h4 id="new的实现"><a href="#new的实现" class="headerlink" title="new的实现"></a>new的实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">function New(fn) &#123;</span><br><span class="line"></span><br><span class="line">/*1*/</span><br><span class="line">var instance = &#123; &apos;__proto__&apos;: fn.prototype &#125;; // 每个对象天生自带__proto__属性，此处只是重新指定了</span><br><span class="line"></span><br><span class="line">return function() &#123;</span><br><span class="line">/*2*/</span><br><span class="line">var res = fn.apply(instance, arguments);</span><br><span class="line">/*3*/</span><br><span class="line">if (typeof res == &apos;object&apos;) &#123;</span><br><span class="line">return res;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">return instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Person(age, name) &#123;</span><br><span class="line">this.age = age;</span><br><span class="line">this.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 调用</span><br><span class="line">New(Person)(11, &apos;Eva&apos;);</span><br></pre></td></tr></table></figure><h4 id="无new调用"><a href="#无new调用" class="headerlink" title="无new调用"></a>无new调用</h4><p>构造函数也是函数，可以直接调用，为了避免忘记通过new来调用构造函数，导致属性和方法添加在window对象上，污染全局变量，一般会在构造函数中检查当前作用域，这样即使不通过new来生成实例也可以得到正确的结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function Person(age, name) &#123;</span><br><span class="line">if (this instanceof Person) &#123;</span><br><span class="line">this.age = age;</span><br><span class="line">this.name = name;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">return new Person(age, name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>理解了new的实际作用，就不难理解原型对象的实现了</p><p>参考文献：</p><p><a href="https://www.zhihu.com/question/36440948" target="_blank" rel="noopener">https://www.zhihu.com/question/36440948</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JS中的面向对象1-面向对象写法的进化</title>
      <link href="/2018/06/18/JS%E4%B8%AD%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A11-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%86%99%E6%B3%95%E7%9A%84%E8%BF%9B%E5%8C%96/"/>
      <url>/2018/06/18/JS%E4%B8%AD%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A11-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%86%99%E6%B3%95%E7%9A%84%E8%BF%9B%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>本系列是学习整理js中的面向对象的第一篇，面向对象写法的进化<br><a id="more"></a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ===========================</span></span><br><span class="line"><span class="comment">// 1.最原始的创建对象</span></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">person.name = <span class="string">'Eva'</span>;</span><br><span class="line">person.age = <span class="number">12</span>;</span><br><span class="line">person.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ===========================</span></span><br><span class="line"><span class="comment">// 2.使用对象字面量来创建对象</span></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">name: <span class="string">'Eva'</span>,</span><br><span class="line">age: <span class="number">12</span>,</span><br><span class="line">sayName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ===========================</span></span><br><span class="line"><span class="comment">// 3.工厂方法来创建对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">o.name = name;</span><br><span class="line">o.age = age;</span><br><span class="line">o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 缺点是：无法知道对象的类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ===========================</span></span><br><span class="line"><span class="comment">// 4.构造函数模式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">age, name</span>) </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.age = age; <span class="comment">// 为实例添加属性和方法</span></span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 本质是如下:每个方法在每个实例上都需要重新创建一遍</span></span><br><span class="line"><span class="keyword">this</span>.sayName=<span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'console.log(this.name)'</span>);</span><br><span class="line"><span class="comment">// this指向：如果是无new调用，this就会指向window || global</span></span><br><span class="line"><span class="comment">// new 调用：new做了什么</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="number">11</span>, <span class="string">'Eve'</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Person(<span class="number">12</span>, <span class="string">'Tom'</span>);</span><br><span class="line">p1.constructor === p2.constructor === Person;</span><br><span class="line">p1 <span class="keyword">instanceof</span> Person; <span class="comment">// true</span></span><br><span class="line">p2 <span class="keyword">instanceof</span> Person; <span class="comment">// true</span></span><br><span class="line">p1.sayName == p2.sayName <span class="comment">// false 每个方法在每个实例上都需要重新创建一遍</span></span><br><span class="line"><span class="comment">// 相比前者：可以将实例标志成某种特定的类型</span></span><br><span class="line"><span class="comment">// 缺点是：每个方法在每个实例上都需要重新创建一遍,直接写成全局函数又会污染全局变量，无封装性可言</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ===========================</span></span><br><span class="line"><span class="comment">// 5.原型模式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">age,name</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">Person.prototype.name = <span class="string">'Eva'</span>;</span><br><span class="line">Person.prototype.age = <span class="number">8</span>;</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="number">11</span>, <span class="string">'Eve'</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Person(<span class="number">12</span>, <span class="string">'Tom'</span>);</span><br><span class="line">p1.constructor === p2.constructor === Person;</span><br><span class="line">p1 <span class="keyword">instanceof</span> Person; <span class="comment">// true</span></span><br><span class="line">p2 <span class="keyword">instanceof</span> Person; <span class="comment">// true</span></span><br><span class="line">p1.sayName == p2.sayName <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 简写</span></span><br><span class="line"><span class="comment">// 缺点：constructor会指向Object构造函数</span></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line"><span class="keyword">constructor</span>: Person,// 手动指定</span><br><span class="line">name: 'Eva',</span><br><span class="line">age: 18,</span><br><span class="line">sayName: function() &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ===========================</span></span><br><span class="line"><span class="comment">// 6.构造函数和原型模式组合使用，解决引用类型属性的共享问题：最常用的写法</span></span><br><span class="line">Person.prototype.toys = [<span class="string">'toy1'</span>,<span class="string">'toy2'</span>];</span><br><span class="line">p1.toys.push(<span class="string">'toy3'</span>);</span><br><span class="line">p2.toys.length == <span class="number">3</span><span class="comment">// true</span></span><br><span class="line"><span class="comment">// 改为</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">age, name, toys</span>) </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.age = age; <span class="comment">// 为实例添加属性和方法</span></span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.toys = toys;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype=&#123;</span><br><span class="line"><span class="keyword">constructor</span>:Person,</span><br><span class="line">sayName:function() &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ===========================</span></span><br><span class="line"><span class="comment">// 7.动态原型模式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">age, name</span>) </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span>.sayName!=<span class="string">'function'</span>)&#123;</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不能再使用对象字面量重写Person.prototype,在已经创建了实例之后再重写原型，就会切断实例与新原型的关系</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ===========================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 8.寄生构造函数模式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">age, name</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">o.name = name;</span><br><span class="line">o.age = age;</span><br><span class="line">o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如何把Object换成Array就更好理解了，创建的新对象是基于Array的，所以是寄生模式。</span></span><br><span class="line"><span class="comment">// 因为创造出的对象并不是Person类，而是还是Object类，所以没办法使用instanceof来判断类型，不建议使用这种方式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ===========================</span></span><br><span class="line"><span class="comment">// 9.稳妥构造函数模式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">age, name</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">o.name = name;</span><br><span class="line">o.age = age;</span><br><span class="line">o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p=Person(<span class="number">11</span>,<span class="string">'Eva'</span>);</span><br><span class="line"><span class="comment">// 与上面的区别在于，1.不引用this，2.无new构造</span></span><br><span class="line"><span class="comment">// 同上：创建对象与构造函数没什么关系，也不能使用instanceof</span></span><br><span class="line"><span class="comment">// 重点在于安全性：除了通过sayName无法访问name属性</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JS函数之美2-函数柯里化和this那些事</title>
      <link href="/2018/02/27/JS%E5%87%BD%E6%95%B0%E4%B9%8B%E7%BE%8E2-this%E9%82%A3%E4%BA%9B%E4%BA%8B/"/>
      <url>/2018/02/27/JS%E5%87%BD%E6%95%B0%E4%B9%8B%E7%BE%8E2-this%E9%82%A3%E4%BA%9B%E4%BA%8B/</url>
      
        <content type="html"><![CDATA[<p>#</p><h2 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h2><p>函数柯里化：创建一个已经设置好了一个或多个参数的函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 柯里化</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line"><span class="comment">// arguments=[fn,...args];</span></span><br><span class="line"><span class="keyword">var</span> args = [].slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">// 柯里化之后的函数的arguments转array</span></span><br><span class="line"><span class="keyword">var</span> innerArgs = [].slice.call(<span class="built_in">arguments</span>);</span><br><span class="line"><span class="keyword">var</span> finalArgs = args.concat(innerArgs);</span><br><span class="line"><span class="keyword">return</span> fn.apply(<span class="literal">null</span>, finalArgs);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(a + b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">curry(add, <span class="number">2</span>)(<span class="number">6</span>); <span class="comment">// 设置一个固定参数</span></span><br><span class="line">curry(add, <span class="number">1</span>, <span class="number">4</span>)(); <span class="comment">// 设置两个固定参数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数绑定</span></span><br><span class="line"><span class="comment">// ES5有原生的bind，但是支持ie9+ polyfill</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">Function</span>.prototype.bind) &#123;</span><br><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line"><span class="comment">// arguments是bind的</span></span><br><span class="line"><span class="keyword">var</span> args = [].slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> fn = <span class="keyword">this</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> innerArgs = [].slice.call(<span class="built_in">arguments</span>);</span><br><span class="line"><span class="keyword">var</span> finalArgs = args.concat(innerArgs);</span><br><span class="line"><span class="comment">// 除了此处和curry非常相似</span></span><br><span class="line">fn.apply(context, finalArgs);</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只获取到了绑定后的函数传入的参数</span></span><br><span class="line"><span class="comment">// 结合了柯里化的函数绑定</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bind</span>(<span class="params">fn, context</span>) </span>&#123;</span><br><span class="line"><span class="comment">// arguments=[fn,context,...args];</span></span><br><span class="line"><span class="keyword">var</span> args = [].slice.call(<span class="built_in">arguments</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> innerArgs = [].slice.call(<span class="built_in">arguments</span>);</span><br><span class="line"><span class="keyword">var</span> finalArgs = args.concat(innerArgs);</span><br><span class="line"><span class="keyword">return</span> fn.apply(context, finalArgs);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">bind(a.addTwoNum,&#123;<span class="attr">num</span>:<span class="number">2</span>&#125;,<span class="string">'1'</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数绑定主要就是为了改变this的指向</span></span><br><span class="line"><span class="comment">// 函数绑定和函数柯里化提供了强大的【动态函数创建】的能力，但是使用时会有额外的性能开销</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// TODO</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">partial</span>(<span class="params">fn, ...args</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...partialArgs</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> finalArgs = args.concat(partialArgs);</span><br><span class="line"><span class="keyword">return</span> fn.apply(<span class="keyword">this</span>, finalArgs);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="bind，apply和call的区别"><a href="#bind，apply和call的区别" class="headerlink" title="bind，apply和call的区别"></a>bind，apply和call的区别</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">num: <span class="number">1</span>,</span><br><span class="line">addNum: <span class="function"><span class="keyword">function</span>(<span class="params">b</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(b + <span class="keyword">this</span>.num);</span><br><span class="line"><span class="keyword">return</span> b + <span class="keyword">this</span>.num</span><br><span class="line">&#125;,</span><br><span class="line">addTwoNum: <span class="function"><span class="keyword">function</span>(<span class="params">b,c</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> b + <span class="keyword">this</span>.num+c</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">a.addNum(<span class="number">2</span>); <span class="comment">// 1+2</span></span><br><span class="line"></span><br><span class="line">a.addNum.bind(&#123; <span class="attr">num</span>: <span class="number">3</span> &#125;)(<span class="number">5</span>); <span class="comment">// 3+5 改变了this的指向</span></span><br><span class="line"><span class="comment">// bind得到的是一个this指向变化的【函数】，还是需要调用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// apply和call的区别在于调用方式不同，前者传入参数数组，后者传入参数列表</span></span><br><span class="line"><span class="comment">// bind，apply和call都是用来改变this的指向</span></span><br><span class="line">a.addNum.apply(&#123; <span class="attr">num</span>: <span class="number">4</span> &#125;, [<span class="number">6</span>]); <span class="comment">// 4+6 改变了this的指向 【调用方法】fn.apply(context,args);</span></span><br><span class="line">a.addNum.call(&#123; <span class="attr">num</span>: <span class="number">5</span> &#125;, <span class="number">6</span>); <span class="comment">// 4+6 改变了this的指向 【调用方法】fn.apply(context,...args);</span></span><br></pre></td></tr></table></figure><p>jQuery中$.proxy也是改变this的指向</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">name: &quot;John&quot;,</span><br><span class="line">test: function() &#123;</span><br><span class="line">alert( this.name );</span><br><span class="line">$(&quot;#test&quot;).unbind(&quot;click&quot;, obj.test);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">$(&quot;#test&quot;).click( jQuery.proxy( obj, &quot;test&quot; ) );</span><br></pre></td></tr></table></figure><p>call,apply,bind的区别<br><a id="more"></a></p><h4 id="为什么要使用call和apply"><a href="#为什么要使用call和apply" class="headerlink" title="为什么要使用call和apply"></a>为什么要使用call和apply</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 可以改变this的指向</span><br><span class="line">[].slice.call(document.getElementsByClassName(&apos;btn&apos;));</span><br><span class="line">[].slice.call(arguments);</span><br></pre></td></tr></table></figure><p>比如需要将常见的arrayLike：arguments，nodeList这种类array转为array。可以直接调用原型方法，将this指向这些arrayLike即可调用</p><h4 id="call和apply的区别"><a href="#call和apply的区别" class="headerlink" title="call和apply的区别"></a>call和apply的区别</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Math.max.call(null,1,2,3,4);</span><br><span class="line">Math.max.apply(null,[1,2,3,4]);</span><br></pre></td></tr></table></figure><p>区别：</p><p>call是直接参数，apply是参数列表</p><p>apply的参数list需要进一步解析，call的性能会更好</p><p>函数bind</p><p>也是改变this的指向</p><h4 id="call，apply是直接调用对应函数，bind会生成新函数"><a href="#call，apply是直接调用对应函数，bind会生成新函数" class="headerlink" title="call，apply是直接调用对应函数，bind会生成新函数"></a>call，apply是直接调用对应函数，bind会生成新函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var m=&#123;x:1&#125;;</span><br><span class="line">function fn(y)&#123;</span><br><span class="line">alert(this.x+y);</span><br><span class="line">&#125;</span><br><span class="line">fn.apply(m,[5]);</span><br><span class="line">fn.call(m,5);</span><br><span class="line">var fn1=fn.bind(m,5);</span><br><span class="line">// fn.bind(conext,arguments);</span><br><span class="line">fn1();</span><br><span class="line"></span><br><span class="line">// bind实现</span><br><span class="line">function bind(fn,context)&#123;</span><br><span class="line">return function()&#123;</span><br><span class="line">return fn.apply(context,arguments);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 常用方式</span><br><span class="line">document.getElementById(&apos;btn&apos;).onclick=bind(handler.handlerFn,handler);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JS函数之美1-闭包的理解</title>
      <link href="/2018/02/18/JS%E5%87%BD%E6%95%B0%E4%B9%8B%E7%BE%8E1-%E9%97%AD%E5%8C%85%E7%9A%84%E7%90%86%E8%A7%A3/"/>
      <url>/2018/02/18/JS%E5%87%BD%E6%95%B0%E4%B9%8B%E7%BE%8E1-%E9%97%AD%E5%8C%85%E7%9A%84%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问：不改变fn的函数体，怎么把变量a的值变成2呢？</p><p>你肯定想说a都没return出来，我根本获取不到呀，怎么可能改a的值。</p><p>那么如果我把<code>a</code>return出来，你有办法修改a的值吗？<br><a id="more"></a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// a++; a依然是私有变量,外部访问不到</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b=fn(); <span class="comment">// 1</span></span><br><span class="line">b++; <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c=fn(); <span class="comment">// 1 a的值依然没有改变</span></span><br></pre></td></tr></table></figure><p>b++之后 a的值变化了吗？我感觉因为a是基本数据类型，存在堆内存里，b应该是指向a的，所以应该是修改成功了a的值，但是确实没办法验证。</p><p>因为你想要获取a的实时状态，只能通过fn来获取，但是var c=fn()调用过后，a又被重新赋值了，所以没办法验证。</p><p>你可能觉得这个问题比较傻，局部变量的值怎么可能被改变呢？改了又有什么意义呢？</p><p>我就遇到过，iOS开发过程中前人封装了一个framework，只暴露了获取a的方法，实现却被打包了，framework打包前的代码也没有，无法修改函数体。但是遇到一个bug，必须要修改a的值才能解决。</p><p>我想了好久也想不出来办法，现在想想其实根本没必要费这个劲儿，只能去找前人找找打包framework之前的源码，改了a重新打包一遍。</p><p>类比js的场景，其实就相当于引了个第三方的加密混淆过的js，改了a的值你就能免费使用第三方的服务，但是人家是个私有局部变量，任你外面的代码写出花儿来，也没办法改变a的值。</p><p>那我们就应该放弃吗？可以得出私有局部变量的值是肯定不能改的结论吗？</p><p>来试试暴露出修改a的接口看看能不能成功。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="keyword">return</span> a++;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line">f1()(); <span class="comment">// 1</span></span><br><span class="line">f1()(); <span class="comment">// 1</span></span><br><span class="line">f1()(); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>很显然失败了。</p><p>调用一百次得到的值也都是a=1，其实很好理解，和上一个例子一样，每次调用都重新走了一下var a=1，重新声明了a的值。那如果想办法不调用a的重新声明呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f2=f1();</span><br><span class="line">f2(); <span class="comment">// 1</span></span><br><span class="line">f2(); <span class="comment">// 2</span></span><br><span class="line">f2(); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>哇，居然真的成功了！得到的值果然符合我们的预期，但是a的值真的改变了吗？这个a还是原来的那个a吗？一脸懵逼，有点怀疑人生了。</p><p>在函数外也可以调用，难道a变成了全局变量吗？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">233</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 代码是一行一行执行的，走到这里一定会是1</span></span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="keyword">return</span> a++;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f2 = f1();</span><br><span class="line">f2(); <span class="comment">// 1</span></span><br><span class="line">f2(); <span class="comment">// 2</span></span><br><span class="line">f2(); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>看起来并没有，f2的操作还是围绕着局部变量a来进行的。可能相比于上一个例子，实际上一个例子也修改成功了只是无法验证而已。</p><p>静静的思考一下，开发者用局部变量而不是全局变量，就是为了不让别人不经过同意就随便改自己的代码。</p><p>其实说到底还是变量作用域的问题。</p><p>虽然变量名相同，但是在函数中，总是<strong>从内到外</strong>去寻找变量的声明，找到最近的声明就用最近的那个值，即使是undefined也是一样。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">333</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再说说<strong>变量提升</strong>的问题。</p><p>其实这就是js中的闭包。闭包可以简单的理解成是<strong>函数内部的函数</strong>，核心作用是<strong>读取到其他函数内部变量的函数</strong>。</p><p>因为a被return出来，随时可能会被操作，不会在调用结束后马上被垃圾回收机制回收，而是被保存在内存中，内存消耗很大，，所以不能滥用闭包，否则会造成网页的性能问题。在IE中可能会导致内存泄漏的问题。解决方法是，在退出函数之前，将不使用的局部变量全部删除。</p><p>主要就是变量提升，变量作用域的问题。</p><p>如果改成es6，变成大括号作用域，那会有什么不同吗？</p><p>如果加上this呢？会让人更怀疑人生吗？</p><p>另一个重要的作用是：让这些变量的值始终保持在内存中。</p><p>闭包中的变量的生存周期很长。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function closure() &#123;</span><br><span class="line">var v = 1;</span><br><span class="line"></span><br><span class="line">function f2() &#123;</span><br><span class="line">// 重点在这里，</span><br><span class="line">return v++;</span><br><span class="line">&#125;</span><br><span class="line">return f2;</span><br><span class="line">// return function() &#123;</span><br><span class="line">// return v++;</span><br><span class="line">// &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const result = closure();</span><br><span class="line">console.log(result()); // 1</span><br><span class="line">console.log(result()); // 2</span><br><span class="line">console.log(result()); // 3</span><br><span class="line">console.log(v); // error</span><br></pre></td></tr></table></figure><p>改变函数内部变量的值。</p><p>f2始终在内存中？而f2依赖于f1，所以f1也始终存在内存中，不会在调用结束后被垃圾回收机制回收。</p><p>那如果改成匿名函数呢？匿名函数也是全局变量吗</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// f是个匿名函数</span><br><span class="line">var f=function()&#123;&#125;</span><br><span class="line"></span><br><span class="line">function f()&#123;&#125;</span><br></pre></td></tr></table></figure><p>两种声明函数方式的区别是很大的。</p><p>作用：</p><p>私有方法有利于限制代码的访问</p><p>管理全局命名空间</p><p>数据隐藏和封装</p>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JS正则备忘</title>
      <link href="/2017/12/14/JS%E6%AD%A3%E5%88%99%E5%A4%87%E5%BF%98/"/>
      <url>/2017/12/14/JS%E6%AD%A3%E5%88%99%E5%A4%87%E5%BF%98/</url>
      
        <content type="html"><![CDATA[<p>#</p><h2 id="JS正则"><a href="#JS正则" class="headerlink" title="JS正则"></a>JS正则</h2><h4 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h4><h5 id="定头定尾（-）"><a href="#定头定尾（-）" class="headerlink" title="定头定尾（^,$）"></a>定头定尾（^,$）</h5><p>^abc表示以此开头，定头<br>abc$以此结尾，定尾<br>^abc$以abc开头和结尾，定头定尾，<strong>完整匹配</strong><br>abc匹配：abc</p><h5 id="2-2-字符的个数"><a href="#2-2-字符的个数" class="headerlink" title="?,*,+,{2,},{2} 字符的个数"></a>?,*,+,{2,},{2} 字符的个数</h5><p>ab?匹配：（a后面跟着0个或1个b）<br><code>ab*</code>匹配：（a后跟着0个或多个b）<br>ab+匹配：（a后跟着至少一个b）<br>a?b+$匹配：末尾是0或1个a和至少一个b结尾<br>ab{2}匹配：abb<br>ab{2,}匹配：a跟着至少2个b<br>ab{3,5}匹配：a跟着3到5个b</p><h5 id="或"><a href="#或" class="headerlink" title="|或"></a>|或</h5><p>（）分组</p><p>.表示任意字符</p><p>a|b匹配：a或b<br>(b|cd)ef匹配：bef或cdef<br><code>(a|b)*c</code> a或b出现任意次 后跟一个c<br><code>a.[0-9]</code>匹配：a后任意字符和一个数字<br>^.{3}$匹配任意三个字符</p><h5 id="表示包含-的"><a href="#表示包含-的" class="headerlink" title="[]表示包含[]的"></a>[]表示包含[]的</h5><p>[ab]匹配：a或b<br>[a-z]匹配：a到z中一个<br>^[a-zA-Z]匹配：开头是字母<br><code>[0-9]%</code>匹配：%前一位数字<br><code>[a-zA-Z0-9]$</code> 匹配：末尾是数字或字母</p><h4 id="出现在-括号中表示匹配不出现某字符"><a href="#出现在-括号中表示匹配不出现某字符" class="headerlink" title="^出现在[ ]括号中表示匹配不出现某字符"></a>^出现在[ ]括号中表示匹配不出现某字符</h4><p><code>[^XXX]</code>表示不希望出现XXX</p><p><code>%[^a-zA-Z]%</code>表示两个%间不希望出现字母</p><h4 id="元字符和转义"><a href="#元字符和转义" class="headerlink" title="元字符和转义"></a>元字符和转义</h4><p>([{\^$|)?*+.}这些都是元字符，有特殊的功能，如果需要匹配字符串中的这些字符，必须要加转移符\</p><p>但如果在[ ]中则不需要加转义字符</p><h4 id="一些简单表达"><a href="#一些简单表达" class="headerlink" title="一些简单表达"></a>一些简单表达</h4><p><code>\W</code>匹配：非字母数字或下划线，等价于[^a-zA-Z0-9]<br><code>\w</code>匹配：字母数字，等价于[a-zA-Z0-9]<br><code>[._]</code>匹配：特殊字符集<br><code>\D</code>匹配：非数字,等价于[^0-9]<br><code>\d</code>匹配：数字，等价于[0-9]<br><code>\b</code>匹配：一个单词的边界<br><code>\B</code>匹配：非一个单词的边界<br><code>\s</code>匹配： 任何空白符,等价于<code>[ \t \n \r \f \v]</code><br><code>\S</code>匹配： 任何非空白符,等价于<code>[^\ t \ n \ r \ f \ v]</code><br>.匹配：除了换行符之外的任意字符，等价于<code>[^\n]</code>：</p><p>^既表示定头，在<code>[]</code>中又表示不允许出现</p><p><code>/^[a-zA-Z]{1}([a-zA-Z0-9]|[._]){4,19}$/</code><br>第一位是字母，后面是4到19个数字或字母或任意字符串或_</p><p><code>^\d+$</code>匹配：正整数+0还有0999这样的<br><code>^[0-9][1-9][0-9]</code>匹配：正整数还是有00100这样的<br>^((-\d+)|(0+))负整数还有000这样的<br>^[\W-]+(.[\w-]+)*@[\W-]+(.[\w-]+)+$</p><p>https?//[\w./]+可以出现数字字母和-及，或/</p><h3 id="js中的正则"><a href="#js中的正则" class="headerlink" title="js中的正则"></a>js中的正则</h3><p>new RegExp(‘pattern’,[flags])</p><h4 id="RegExp的实例属性："><a href="#RegExp的实例属性：" class="headerlink" title="RegExp的实例属性："></a>RegExp的实例属性：</h4><p>global:对应g flage，全局匹配</p><p>ignoreCase:对应i flag，忽略大小写匹配</p><p>multiline:对应 m flag，跨行多行匹配</p><p>source:pattern的字面值，/\d+/g.source==”\d+”// false</p><p>lastIndex:开始搜索下一个匹配项的字符位置，从0开始。主要在exec中会有变化</p><p>可以直接写字符串，也可new RegExp，或者不带引号匹配：在/中/<br>{}等价于&gt;=和&lt;=</p><p>js中的正则：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var pattern=new RegExp(/\d+/);</span><br><span class="line">// flags:g,i,m,全局，忽略大小写，多行查找</span><br><span class="line">var pattern=/\d+/gi;</span><br></pre></td></tr></table></figure><h4 id="RegExp的实例方法："><a href="#RegExp的实例方法：" class="headerlink" title="RegExp的实例方法："></a>RegExp的实例方法：</h4><h4 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var matches = /.ay(.hs)(.ds)/g.exec(&apos;syeuwyaydhsidsh2&apos;);</span><br><span class="line"></span><br><span class="line">// [&quot;yaydhsids&quot;, &quot;dhs&quot;, &quot;ids&quot;, index: 5, input: &quot;syeuwyaydhsidsh2&quot;, groups: undefined]</span><br><span class="line"></span><br><span class="line">// 返回的是有index属性和input属性的数组</span><br><span class="line"></span><br><span class="line">// index是匹配的字符串的首字符的index</span><br><span class="line"></span><br><span class="line">// input是输入的字符串</span><br><span class="line"></span><br><span class="line">// matches[0]是匹配的到字符串</span><br><span class="line"></span><br><span class="line">// matches[1,2...]是捕获组即(XXX)捕获到的字符串$1,$2</span><br><span class="line">// 即使有g全局匹配，每次也只返回一个匹配项</span><br><span class="line">var text=&apos;cat,fat,hat,bat&apos;</span><br><span class="line">var pattern=/.at/g;</span><br><span class="line">var matches = pattern.exec(text); // cat</span><br><span class="line">matches = pattern.exec(text); // fat</span><br><span class="line">// pattern必须要带有g标志，且pattern和text都必须要保存在对象中，才可以多次执行，匹配下一个</span><br></pre></td></tr></table></figure><h4 id="match"><a href="#match" class="headerlink" title="match"></a>match</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var matches=str.match(regexp)</span><br><span class="line">// 得到的结果和exec完全一致</span><br><span class="line">var str = &apos;For more information, see Chapter 3.4.5.1&apos;;</span><br><span class="line">var re = /see (chapter \d+(\.\d)*)/i;</span><br><span class="line">var found = str.match(re);</span><br><span class="line">// [&quot;see Chapter 3.4.5.1&quot;, &quot;Chapter 3.4.5.1&quot;, &quot;.1&quot;, index: 22, input: &quot;For more information, see Chapter 3.4.5.1&quot;];</span><br></pre></td></tr></table></figure><h4 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">str.replace(regexp|substr, newSubstr|function)</span><br><span class="line">// 注意不修改原来的字符串，而是返回处理后的字符串</span><br><span class="line"></span><br><span class="line">function replacer(match, p1, p2, p3, offset, string) &#123;</span><br><span class="line">// p1 is nondigits, p2 digits, and p3 non-alphanumerics</span><br><span class="line">return [p1, p2, p3].join(&apos; - &apos;);</span><br><span class="line">&#125;</span><br><span class="line">var newString = &apos;abc12345#$*%&apos;.replace(/([^\d]*)(\d*)([^\w]*)/, replacer);</span><br><span class="line">console.log(newString); // abc - 12345 - #$*%</span><br><span class="line"></span><br><span class="line">// 交换单词，主要用到了(XX)捕获组,$1</span><br><span class="line">var re = /(\w+)\s(\w+)/;</span><br><span class="line">var str = &apos;John Smith&apos;;</span><br><span class="line">var newstr = str.replace(re, &apos;$2, $1&apos;);</span><br><span class="line">console.log(newstr); // Smith, John</span><br></pre></td></tr></table></figure><h4 id="test"><a href="#test" class="headerlink" title="test"></a>test</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/.at/g.test(&apos;cat&apos;)// true 返回是否匹配</span><br></pre></td></tr></table></figure><h3 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h3><h4 id="lookahead"><a href="#lookahead" class="headerlink" title="lookahead"></a>lookahead</h4><p>js只支持前瞻（也称零宽断言）lookahead向前查找，不支持后顾lookbehind</p><p><strong>注意正则是从尾部向头部解析的</strong></p><p>判断一个单词字符之后是否是数字（正向前瞻），是的话，则符合匹配进行替换</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// exp1(?=exp2) 正向前瞻，匹配后面满足exp2的exp1</span><br><span class="line">// 匹配后面满足\d的前面满足\w的\w对应的字符</span><br><span class="line">&apos;a2*3&apos;.replace(/\w(?=\d)/g, &quot;X&quot;); // &apos;X2*3&apos;</span><br><span class="line"></span><br><span class="line">// exp1(?=exp2) 负向前瞻，匹配后面不满足exp2的exp1</span><br><span class="line">// 匹配后面不满足\d的前面满足\w的\w对应的字符</span><br><span class="line">&apos;a2c*3&apos;.replace(/\w(?!=\d)/g, &quot;X&quot;); // XXX*X&quot;</span><br><span class="line"></span><br><span class="line">// 要注意前瞻是非捕获性分组，不能通过$1来获取</span><br><span class="line">&apos;a2c*3&apos;.replace(/\w(?!=\d)/g, &quot;$1&quot;); // $1$1$1*$1</span><br></pre></td></tr></table></figure><p>后顾不支持就不写了</p><p>注意正则是从尾部向头部解析的，前瞻是指正则从后往前解析，后顾则是从前往后解析。</p><p>从后往前解析的意思是先满足()中的exp2，再看前面的exp1是否符合</p><h4 id="贪婪模式"><a href="#贪婪模式" class="headerlink" title="贪婪模式"></a>贪婪模式</h4><p>/\d{3,6}/一般匹配6，/\d{3,6}?/在量词后加上?即可非贪婪模式</p><p>引用：$捕获到分组的内容<br>$1对应每个()分组的内容</p><h4 id="ES6中的扩展"><a href="#ES6中的扩展" class="headerlink" title="ES6中的扩展"></a>ES6中的扩展</h4><h3 id="常用正则："><a href="#常用正则：" class="headerlink" title="常用正则："></a>常用正则：</h3><p>在sublime中输入commd+ shift+enter就可以替换为\r\n</p><p>[^\x00-\xff] 匹配中文</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var str = &quot;https://www.runoob.com:80/html/html-tutorial.html&quot;;</span><br><span class="line">var patt1 = /(\w+):\/\/([^/:]+)(:\d*)?([^# ]*)/;</span><br><span class="line">matches = str.match(patt1);</span><br><span class="line">matches[0] // 得到匹配的url</span><br><span class="line">matches[1] // scheme</span><br><span class="line">matches[2] // domain</span><br><span class="line">matches[3] // port</span><br><span class="line">matches[4] // path</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>homebrew的使用</title>
      <link href="/2017/11/18/homebrew%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2017/11/18/homebrew%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>Home-brew是mac上的软件安装管理工具，有了它每次安装软件都不用去google了，直接<code>brew install</code>就可以啦。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 安装home-brew</span><br><span class="line">ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</span><br></pre></td></tr></table></figure><p>拥有安装、卸载、更新、查看、搜索等很多实用的功能。简单的一条指令，就可以实现包管理，而不用你关心各种依赖和文件路径的情况，十分方便快捷。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># 版本</span><br><span class="line">brew -v</span><br><span class="line"></span><br><span class="line"># 更新 Homebrew版本</span><br><span class="line">brew update</span><br><span class="line"></span><br><span class="line"># 帮助</span><br><span class="line">brew -h</span><br><span class="line"></span><br><span class="line"># 检查问题</span><br><span class="line">brew doctor</span><br><span class="line"></span><br><span class="line"># 查看所有包</span><br><span class="line">brew list</span><br><span class="line"></span><br><span class="line"># 查看你的包是否需要更新</span><br><span class="line">brew outdated</span><br><span class="line"></span><br><span class="line"># 更新包</span><br><span class="line">brew upgrade &lt;package_name&gt;</span><br><span class="line"></span><br><span class="line"># 安装包</span><br><span class="line">brew install &lt;package_name&gt;</span><br></pre></td></tr></table></figure><p>Homebrew 将会把老版本的包缓存下来，以便当你想回滚至旧版本时使用。但这是比较少使用的情况，当你想清理旧版本的包缓存时，可以运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew cleanup</span><br></pre></td></tr></table></figure><p>常用包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew install openssl mongodb</span><br><span class="line">brew rm docker</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> tool </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>移动端UI自适应最佳实践</title>
      <link href="/2017/08/18/%E7%A7%BB%E5%8A%A8%E7%AB%AFUI%E8%87%AA%E9%80%82%E5%BA%94%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
      <url>/2017/08/18/%E7%A7%BB%E5%8A%A8%E7%AB%AFUI%E8%87%AA%E9%80%82%E5%BA%94%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<p>我们的工作少不了要和UI设计师打交道，一般设计小姐姐给的图都是iPhone6尺寸750*1334px，这样我们在切图时，只需要将像素值/2作为元素的宽高，字体的尺寸即可。但是一般的设计图中border是1px，怎么把元素的border设置为0.5px呢？</p><p>有的小伙伴说，那是他们不专业，随便写个1px就可以了。但是我们rgb不变直接写成1px的话，会明显发现border显得太粗颜色太深。</p><p>作为一个有追求的前端工程师，应该怎么做到border的高保真呢？浏览器支持0.5px吗？<br><a id="more"></a></p><h3 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h3><p>我们先忽略这个0.5px的问题，思考下移动端适配的历史。</p><p>最开始我们适配时都是通过百分比来解决的。但是百分比只能解决宽度自适应，高度却不能自适应，小尺寸屏幕上按钮过高，显得臃肿</p><p>对于不同屏幕上宽高比一致的方案，使用百分比达不到效果</p><p>其他的解决方案<br>px：px相对于屏幕分辨率而言（与物理设备有关），普通屏是1px对应1个物理像素点，高清屏是1px对应4个物理像素点<br>em：相对长度单位，相对于当前对象内的字体尺寸，em的值不固定，继承父级字体大小<br>rem：相对于html根元素的尺寸。只修改根元素html就可以成比例的调整所有字体大小。</p><h3 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h3><p>rem兼容性：</p><p>iOS6.1+都支持<br>Android 2.1+都支持<br>主流浏览器都支持</p><h3 id="em和rem"><a href="#em和rem" class="headerlink" title="em和rem"></a>em和rem</h3><p>em：相对于当前元素内的字体尺寸。当前元素font-size=20px，当前元素中的1em=20px</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h1&#123;font-size:20px;&#125; // 1em=20px</span><br></pre></td></tr></table></figure><p>rem简单，1rem始终是那么大，但rem使组件不那么模块化。实际开发中可以结合使用:</p><p>1.当元素属性值需要根据元素字体尺寸缩放时，就使用em</p><p>2.其他情况都简单的使用rem</p><h3 id="rem"><a href="#rem" class="headerlink" title="rem"></a>rem</h3><p>rem：font-size of the root element</p><p>rem：期望字体/body-font-size rem</p><p>rem不仅适用于字体，也可以用于width height margin</p><p>使用scss可以直接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">html&#123;font-size:10px;&#125;1rem=10px;</span><br><span class="line">html&#123;font-size:62.5%;&#125; // =10px</span><br><span class="line"></span><br><span class="line">@mixin px2rem($px)&#123;</span><br><span class="line">$rem:37.5px;// window.innerWidth/10</span><br><span class="line">@return ($px/$rem)+rem;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">height:px2rem(90px);</span><br></pre></td></tr></table></figure><p>使用media query来设置根节点，上面的设置方法有一个很明显的问题font-size是在一个屏幕宽度的区间上有一个基准值。像安卓手机种类的繁多，屏幕大小就更多的情况下，上面的方法很鸡肋。</p><p>第二种解决方案，就是使用JavaScript根据当前屏幕的宽度动态计算font-size值，这种方法可以保证屏幕宽度连续变化的时候，font-size基准值也是连续变化的。</p><p>那么最后一个问题也来了：为什么将计算rem单位的js放在head标签里面？</p><p>一句话总结：在浏览器中文档流是从上往下加载渲染的。为了保证发生不必要的重绘或者是重排肯定是越早给根节点设置font-size值越好。</p><h3 id="rem适用场景"><a href="#rem适用场景" class="headerlink" title="rem适用场景"></a>rem适用场景</h3><p>整体的布局还是使用百分比<br>使用rem的最佳场景是,遇到例如多列带有图片的列表,常常需要图片固定宽高比例<br>研究了一些网站，比如淘宝，对字体字体一般情况建议使用px<br>出现1px像素线的地方，仍旧使用border-width:1px;而不是border-width:.1rem;</p><h3 id="5px的解决"><a href="#5px的解决" class="headerlink" title=".5px的解决"></a>.5px的解决</h3><p>设计稿中常常是iPhone6尺寸750*1334px,border是1px</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 移动端设置viewport</span></span><br><span class="line"><span class="comment">// 直接按照750*1334来切图</span></span><br><span class="line"><span class="comment">// 解决.5px border</span></span><br><span class="line"><span class="keyword">var</span> dpr = <span class="built_in">window</span>.devicePixelRatio,</span><br><span class="line">viewPort = <span class="built_in">document</span>.createElement(<span class="string">'meta'</span>),</span><br><span class="line">head = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'head'</span>)[<span class="number">0</span>];</span><br><span class="line">viewPort.setAttribute(<span class="string">'name'</span>, <span class="string">'viewport'</span>);</span><br><span class="line">viewPort.setAttribute(<span class="string">'content'</span>, <span class="string">'initial-scale='</span> + <span class="number">1</span> / dpr + <span class="string">', maximum-scale='</span> + <span class="number">1</span> / dpr + <span class="string">', minimum-scale='</span> + <span class="number">1</span> / dpr + <span class="string">', user-scalable=no'</span>);</span><br><span class="line">head.insertBefore(viewPort, <span class="built_in">document</span>.getElementsByTagName(<span class="string">'meta'</span>)[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 任意浏览器的默认font-size=16px; html&#123;font-size:6.25% // 10px;&#125;则=&gt;1rem=6.25%=10px;</span></span><br><span class="line"><span class="comment">// 按照750*1334来切图则 1rem=&gt;37.5px 设置好了rem可以直接在css中rem</span></span><br><span class="line"><span class="comment">// pxToRem中rem直接定为37.5px;尺寸都是照这个来的</span></span><br><span class="line"><span class="built_in">document</span>.getElementsByTagName(<span class="string">'html'</span>)[<span class="number">0</span>].style.fontSize = <span class="built_in">window</span>.innerWidth / <span class="number">10</span> + <span class="string">'px'</span>;</span><br></pre></td></tr></table></figure><h3 id="小程序中"><a href="#小程序中" class="headerlink" title="小程序中"></a>小程序中</h3><p>rpx是微信小程序专用尺寸单位，规定屏幕宽为750rpx<br>注：开发微信小程序时设计师可以用 iPhone6 作为视觉稿的标准。<br>建议：设计稿使用设备宽度750px比较容易计算750px的话1rpx=1px，这样的话，设计图上量出来的尺寸是多少px就是多少rpx，至于在不同的设备上实际上要换算成多少个rem就交给小程序自己换算</p><p>像素：</p><p>物理像素：</p><p>设备独立像素</p><p>设备像素比：dpr</p><h3 id="vm"><a href="#vm" class="headerlink" title="vm"></a>vm</h3><p>vw，vh，vmin和vmax是基于viewport的长度单位</p><ul><li><p>vw: viewport’s width,1vw等于window.innerWidth的1%</p></li><li><p>vh：viewport’s height，1vh等于window.innerHeihgt的1%</p></li><li><p>vmin: vmin的值是当前vw和vh中较小的值</p></li><li><p>vmax: vmax的值是当前vw和vh中较大的值</p></li></ul><p>针对750px的设计稿，将px值除以75得到vw的值</p><p>尽管在某些Android机型上还存在兼容问题，我们也可以使用Viewport Units Buggyfill，具体见《如何在Vue项目中使用vw实现移动端适配》</p><p>回顾与总结：</p><p>细节与思考：</p><p>面试中常问的.5px的实现，现在你会了吗？</p><p>参考文献：</p><p><a href="http://www.html-js.com/article/4771" target="_blank" rel="noopener">http://www.html-js.com/article/4771</a><br><a href="http://www.alloyteam.com/2016/03/mobile-web-adaptation-tool-rem/" target="_blank" rel="noopener">http://www.alloyteam.com/2016/03/mobile-web-adaptation-tool-rem/</a><br>移动端适配和.5px的由来<a href="http://mp.weixin.qq.com/s/5BpIpM6WAvWaX2Y8IrVETA" target="_blank" rel="noopener">http://mp.weixin.qq.com/s/5BpIpM6WAvWaX2Y8IrVETA</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>邮件中的HTML</title>
      <link href="/2017/07/18/%E9%82%AE%E4%BB%B6%E4%B8%AD%E7%9A%84HTML/"/>
      <url>/2017/07/18/%E9%82%AE%E4%BB%B6%E4%B8%AD%E7%9A%84HTML/</url>
      
        <content type="html"><![CDATA[<p>马上要举办iOT大会，突然来了个急需求，要把邀请函做成HTML嵌在邮件里发送给参会嘉宾，心里想这有何难，三下五除二写完发给了小伙伴，真正放在邮件里看都傻眼了。</p><a id="more"></a><p>outlook客户端里：css统统不生效</p><p>手机端显示更是惨不忍睹，各种手机表现形式完全不一样</p><p>真是狠狠打自己的脸</p><p>速google了一下，果然这种邮件内嵌html都是有固定的格式要求的，这种HTML Emial能否正常显示完全就取决于邮件客户端，而web技术发展了这么多年，这种邮件中的HTML却丝毫没有发展，各种邮件客户端都特别傲娇，简直可以称得上是面目全非。</p><p>一个准则就是：怎么原始怎么来。</p><p>不要再考虑css提取出来的问题，直接全部写在style里。</p>]]></content>
      
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>通过axios来理解http请求</title>
      <link href="/2017/05/18/%E9%80%9A%E8%BF%87axios%E6%9D%A5%E7%90%86%E8%A7%A3http%E8%AF%B7%E6%B1%82/"/>
      <url>/2017/05/18/%E9%80%9A%E8%BF%87axios%E6%9D%A5%E7%90%86%E8%A7%A3http%E8%AF%B7%E6%B1%82/</url>
      
        <content type="html"><![CDATA[<p>刚开始做小程序对接的时候，很多人一上来就问为啥这个接口请求不成功，完全都不知道自己看看HTTP的请求信息，因为<code>wx.request</code>没有设置<code>content-type</code>，默认的<code>content-type</code>是<code>application/json</code>。但是我们平常后端接受的一般都是<code>application/x-www-form-urlencoded</code>。有些人表面上开口闭口就vue，react，其实连最基本的http请求都没弄明白哦。<br><a id="more"></a></p><h4 id="1-Request-Payload-amp-FormData"><a href="#1-Request-Payload-amp-FormData" class="headerlink" title="1.Request Payload&amp; FormData"></a>1.Request Payload&amp; FormData</h4><ol><li>Request Payload</li></ol><p>对应content-type：application/json，<strong>axios默认使用的是此content-type</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST /some-path HTTP/1.1</span><br><span class="line">Content-Type: application/json</span><br><span class="line">Request Payload:</span><br><span class="line">view parsed: &#123; &quot;foo&quot; : &quot;bar&quot;, &quot;name&quot; : &quot;John&quot; &#125;</span><br><span class="line">view source：&#123; &quot;foo&quot; : &quot;bar&quot;, &quot;name&quot; : &quot;John&quot; &#125;</span><br><span class="line">没有viewencode，因为不encode</span><br></pre></td></tr></table></figure><p>content-type：application/json上传数据可以更多样，可以直接传递数组，对象<br>{ “foo” : “bar”, “name” : “John”，goods:[‘fish’,’beef’] }</p><p><strong>后台处理</strong></p><p>对于 Request Payload 请求， 必须加<code>@RequestBody</code>才能将请求正文解析到对应的 bean 中，且只能通过 request.getReader() 来获取请求正文内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@PostMapping(&quot;/accounts&quot;)</span><br><span class="line">public ResponseEntity&lt;?&gt; createAccount(@RequestBody SysAccount account) &#123;</span><br></pre></td></tr></table></figure><ol><li>FormData</li></ol><p><strong>常见的content-type一般都是application/x-www-form-urlencoded</strong>，这是jQuery默认的content-type</p><p>对应application/x-www-form-urlencoded：正文请求类似get url请求</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">POST /some-path HTTP/1.1</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">FormData:</span><br><span class="line">view source:foo=bar&amp;name=John</span><br><span class="line">view source中会encode之后直接上送</span><br></pre></td></tr></table></figure><p><strong>后台处理</strong></p><p>对于 Form Data 请求，无需任何注解，springmvc 会自动使用 MessageConverter 将请求参数解析到对应的 bean，且通过 request.getParameter(…) 能获取请求参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@PostMapping(&quot;/accounts&quot;)</span><br><span class="line">public ResponseEntity&lt;?&gt; createAccount(SysAccount account) &#123;</span><br></pre></td></tr></table></figure><p>前端可以通过qs来将request payload转为form data上送</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'Qs'</span>;</span><br><span class="line"><span class="comment">// axios默认将Content-type设为`application/json`</span></span><br><span class="line">axios.defaults.headers.post[<span class="string">'Content-Type'</span>] = <span class="string">'application/x-www-form-urlencoded'</span>;</span><br><span class="line">axios.post(url, &#123; <span class="attr">data</span>: Qs.stringify(para) &#125;).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">resolve(res);</span><br><span class="line">&#125;).catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>Qs.stringify和JSON.stringify的区别</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Qs.stringify( &#123;name:&apos;hehe&apos;,age:10&#125;)=&gt; name=hehe&amp;age=10</span><br><span class="line">JSON.stringify( &#123;name:&apos;hehe&apos;,age:10&#125;)=&gt;&quot;&#123;&quot;a&quot;:&quot;hehe&quot;,&quot;age&quot;:10&#125;&quot;</span><br></pre></td></tr></table></figure><h4 id="2-上传文件"><a href="#2-上传文件" class="headerlink" title="2.上传文件"></a>2.上传文件</h4><p>需要在header中设置<code>{ &#39;Content-Type&#39;: &#39;multipart/form-data&#39; }</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">POST /some-path HTTP/1.1</span><br><span class="line">Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryP1hWgP9UXLkUFJEd</span><br><span class="line"></span><br><span class="line">Request Payload</span><br><span class="line"></span><br><span class="line">------WebKitFormBoundaryP1hWgP9UXLkUFJEd</span><br><span class="line">Content-Disposition: form-data; name=&quot;id&quot;</span><br><span class="line"></span><br><span class="line">12345</span><br><span class="line">------WebKitFormBoundaryP1hWgP9UXLkUFJEd # 通过boundary来分隔各个请求参数</span><br><span class="line">Content-Disposition: form-data; name=&quot;ips&quot;</span><br><span class="line"></span><br><span class="line">[&quot;1.2.3.1&quot;,&quot;1.2.3.4&quot;] //注意在formData中无法上送实际list，都会被转为string</span><br><span class="line">------WebKitFormBoundaryP1hWgP9UXLkUFJEd</span><br><span class="line">Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;my.file&quot;</span><br><span class="line">Content-Type: text/plain</span><br><span class="line"></span><br><span class="line">------WebKitFormBoundaryP1hWgP9UXLkUFJEd--</span><br></pre></td></tr></table></figure><p>调用示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> formData = <span class="keyword">new</span> FormData();</span><br><span class="line">formData.append(<span class="string">'file'</span>, file);</span><br><span class="line">formData.append(<span class="string">'id'</span>, id);</span><br><span class="line">formData.append(<span class="string">'ips'</span>, <span class="built_in">JSON</span>.stringify([<span class="string">'1.2.1.1'</span>,<span class="string">'2.1.2.1'</span>]));<span class="comment">//后台还是需要配合解析</span></span><br><span class="line">axios(&#123;</span><br><span class="line">method: <span class="string">'post'</span>,</span><br><span class="line">url,</span><br><span class="line">data: formData,</span><br><span class="line">headers: &#123; <span class="string">'Content-Type'</span>: <span class="string">'multipart/form-data'</span> &#125;,<span class="comment">//需要设置Content-Type</span></span><br><span class="line">&#125;).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">&#125;).catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="3-DELETE的使用"><a href="#3-DELETE的使用" class="headerlink" title="3.DELETE的使用"></a>3.DELETE的使用</h4><p>可以看到axios中传参config中可以使用data和params</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `params` are the URL parameters to be sent with the request</span></span><br><span class="line"><span class="comment">// Must be a plain object or a URLSearchParams object</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">params: &#123;</span><br><span class="line">ID: <span class="number">12345</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// `data` is the data to be sent as the request body</span></span><br><span class="line"><span class="comment">// Only applicable for request methods 'PUT', 'POST', and 'PATCH'</span></span><br><span class="line"><span class="comment">// When no `transformRequest` is set, must be of one of the following types:</span></span><br><span class="line"><span class="comment">// - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams</span></span><br><span class="line"><span class="comment">// - Browser only: FormData, File, Blob</span></span><br><span class="line"><span class="comment">// - Node only: Stream, Buffer</span></span><br><span class="line"><span class="comment">// data传参是在request body中，是向服务器发送资源，只支持PUT，POST，PATCH。因为GET只支持在params中传参，显示时是Query String Parameters</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// DELETE也只支持在params的原因是一般都是只上送个id来删除，没有必要在request body中传递，直接在Query String Parameters中传递即可</span></span><br><span class="line">data: &#123;</span><br><span class="line">firstName: <span class="string">'Fred'</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>浏览器中显示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">POST /some-path HTTP/1.1</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">---------------Query String Parameters-----------------</span><br><span class="line">拼接在url后面的就是此种</span><br><span class="line">view source:</span><br><span class="line">id:12345</span><br><span class="line">view parsed:</span><br><span class="line">id=12345</span><br><span class="line">-----------FormData-----------------</span><br><span class="line">view parsed:</span><br><span class="line">foo:bar</span><br><span class="line">name:Eva</span><br><span class="line">view source：</span><br><span class="line">foo=bar&amp;name=Eva</span><br></pre></td></tr></table></figure><p>GET请求对应Query String Parameters，是没有对应的Content-type的</p><p>或对应Content-type：text/plain</p><p>在request body中传递是对应Request Payload或FormData</p><h4 id="4-支持CSRF攻击"><a href="#4-支持CSRF攻击" class="headerlink" title="4.支持CSRF攻击"></a>4.支持CSRF攻击</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 设置CSRFToken</span><br><span class="line">axios.defaults.xsrfCookieName = &apos;csrftoken&apos;;</span><br><span class="line">axios.defaults.xsrfHeaderName = &apos;X-CSRFToken&apos;;</span><br></pre></td></tr></table></figure><h4 id="5-关于urlencode"><a href="#5-关于urlencode" class="headerlink" title="5.关于urlencode"></a>5.关于urlencode</h4><p>前文提到FormData对应的Content-type为application/x-www-form-urlencoded以及GET请求对应的Query String Parameters，此类请求中上送参数都会被浏览器自动encode后上送</p><p>但是需要注意的是有时候浏览器encode的并不是我们想要的，比如下面这个陈年老坑</p><p><a href="https://mi.com?id=1+2+3" target="_blank" rel="noopener">https://mi.com?id=1+2+3</a><br>实际后台收到的参数是id=1 2 3,上送时+变成了空格，所以需要前端encodeURIComponent(‘1+2+3’)=&gt;1%2B2%2B3再上送</p><p><a href="https://mi.com?id=1" target="_blank" rel="noopener">https://mi.com?id=1</a> 2 3<br>实际上会encode成<a href="https://mi.com?id=1 2 3，参数还是id=1" target="_blank" rel="noopener">https://mi.com?id=1 2 3，参数还是id=1</a> 2 3</p><p>总之遇上+号时，前端最好encodeURIComponent后上送</p><p>参考文献：<br><a href="https://fed.renren.com/2018/02/03/http-request/" target="_blank" rel="noopener">https://fed.renren.com/2018/02/03/http-request/</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>国际化的一些思考和注意事项</title>
      <link href="/2017/04/18/%E5%9B%BD%E9%99%85%E5%8C%96%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83%E5%92%8C%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
      <url>/2017/04/18/%E5%9B%BD%E9%99%85%E5%8C%96%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83%E5%92%8C%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
      
        <content type="html"><![CDATA[<p>翻译同学一般使用 <a href="https://crowdin.com" target="_blank" rel="noopener">https://crowdin.com</a> 来提交翻译</p><p>和翻译同学合作需要注意以下几点：</p><p>1.注意尽量不要使用拼接的字符串</p><p>比如：</p><p>tips=请同意隐私政策和用户协议</p><p>千万不要因为用户协议和隐私政策需要在多处用到，就将字符串切分为多个：</p><p>agreement=用户协议</p><p>privacy=隐私政策</p><p>notice=请同意</p><p>and=和</p><p>这样翻译同学会和莫名其妙，而且不同语言因为语序不一样，我们生硬的组合起来，展示在网页上的整句话会完全不可读。</p><p>2.注意单复数的处理：</p><p>left_times=您还能发送{n}条短信</p><p>在其他语言中会有单复数的区分，1 message left，2 messages left。 在阿语中单复数的表达甚至有多达6种。 Android的resource是使用xml，处理单复数如下</p><p><plurals name="watch_face_count"></plurals></p><p><item quantity="one">%1$d个手盘</item></p><p><item quantity="other">%1$d个手盘</item><br><br>3.需要注意日期，金额等的处理：</p><p>4.需要注意rtl语言的特殊ui处理：</p><p>有很多语言，比如iw_IL，ar，等语言习惯都是从左到右的书写习惯，此时除了需要加上body{direction:rtl}</p><p>其他的布局也需要注意将left和right互换。</p><p>5.需要注意语言中单双引号的处理：</p><p>英语en_US和法语fr_FR有单引号，iw_IL希伯来语中有双引号作为字符。</p><p>如果出现在js的字符串中，导致语法错误，程序直接无法运行，此时我们需要用上转义字符来避免问题。</p><p>如果出现在html中，我们倒是没问题。</p><p>6.需要注意某些语言过长的处理：</p><p>有些语言，比如mr_IR一个单词就非常长，所以一点要做好超长的处理。</p><p>要注意：</p><p>一般情况下都是前端同学来维护国际化的资源文件，确实是一件费时费力枯燥无味的工作，但是在工作中切忌眼高手低，分配到你的工作一定要做好。随着语言的种类越来越多，为了方便维护，最开始就要考虑好上面的问题的解决方案。</p><p>注意发布前需要在crowdin上查看下语言翻译进度，是否达到100%了。</p><p>需要同步工具，将翻译同学的git项目内容分散copy到我们实际的项目中</p><p>国家地区码：<a href="https://www.jianshu.com/p/f425950a09c7" target="_blank" rel="noopener">https://www.jianshu.com/p/f425950a09c7</a></p><p>TODO:<br>前后端分离国际化应该怎么做</p><p>参考文献：</p><p><a href="http://taobaofed.org/blog/2016/03/21/internationalization/" target="_blank" rel="noopener">http://taobaofed.org/blog/2016/03/21/internationalization/</a></p><p><a href="https://github.com/ProtoTeam/blog/blob/master/201710/1.md" target="_blank" rel="noopener">https://github.com/ProtoTeam/blog/blob/master/201710/1.md</a></p><p><a href="https://segmentfault.com/a/1190000009058572" target="_blank" rel="noopener">https://segmentfault.com/a/1190000009058572</a></p><p><a href="https://github.com/DDFE/DDFE-blog/issues/14" target="_blank" rel="noopener">https://github.com/DDFE/DDFE-blog/issues/14</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> i18n </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>玩转sublime</title>
      <link href="/2017/04/18/%E7%8E%A9%E8%BD%ACsublime/"/>
      <url>/2017/04/18/%E7%8E%A9%E8%BD%ACsublime/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> tool </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「 CSS 」css布局规则和你不知道的BFC</title>
      <link href="/2017/04/18/css%E5%B8%83%E5%B1%80%E8%A7%84%E5%88%99%E5%92%8C%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84BFC/"/>
      <url>/2017/04/18/css%E5%B8%83%E5%B1%80%E8%A7%84%E5%88%99%E5%92%8C%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84BFC/</url>
      
        <content type="html"><![CDATA[<p>BFC的文章很多，但是大多翻译腔读起来佶屈聱牙，而且有些例子根本不符合场景。今天从一些常见基本问题入手，来全面的分析css布局的规则。大部分内容来自MDN及自己的理解。</p><a id="more"></a><h3 id="0-什么是盒模型？"><a href="#0-什么是盒模型？" class="headerlink" title="0.什么是盒模型？"></a>0.什么是盒模型？</h3><p>一个元素如何在页面中找准自己的位置，首先要知道定位，然后再根据padding，margin，border及内容来决定尺寸。</p><p>一个大盒子里放了小盒子，小盒子的定位首先是根据大盒子来的。外部发生什么只影响大盒子，但不会影响小盒子。</p><p>标准盒子模型：宽度=内容的宽度（content）+ border + padding + margin<br>低版本IE（&lt;6）盒子模型：宽度=内容宽度（content+border+padding）+ margin</p><p>box-sizing属性用来确定控制元素盒模型的解析模式，默认是content-box标准盒模型，定义了宽高是否包含border和padding。</p><p>(IE&gt;=8需要加上前缀)box-sizing:border-box</p><p>box-sizing:border-box没有广泛使用的原因？<br>IE6，7的标准模式下没有box-sizing，要使用box-sizing必须使用quirk mode<br>有了calc()之后，box-sizing用来避免无意义标签的不可替代性消失了，而且还有些bug</p><p>比如FF和IE在getComputedStyle得到的width/height是按照标准模式计算出来的），以及混合多种box model在开发中的理解成本（要随时记得width/height的表现取决于box-sizing的计算值——其实left/top也有类似的问题，调试的时候你得确定position的计算值），使用box-sizing的好处就不多了。<br>参考：<a href="https://www.zhihu.com/question/20691294" target="_blank" rel="noopener">https://www.zhihu.com/question/20691294</a></p><p>房子是一砖一瓦搭起来的，这一个个砖块就是一个个盒子。所以说我们就是搬砖工？</p><h3 id="1-盒（box）和元素（element）有什么关系？"><a href="#1-盒（box）和元素（element）有什么关系？" class="headerlink" title="1.盒（box）和元素（element）有什么关系？"></a>1.盒（box）和元素（element）有什么关系？</h3><p>看MDN上有时候提到块级盒，有时候又称为块级元素，本来简单的以为这两者是一致的，大多数情况下每个元素都可以被看作是一个盒子。但实际上两者并不是一一对应的关系。</p><p>多个元素可以组成一个盒。比较好理解，在css世界中本来就是大盒嵌套小盒。</p><p>一个元素也可以生成多个盒。主要的两种情况：</p><ul><li><p>比如<code>li</code>，一个元素会生成2个盒，前面的项目符号也是一个盒，主盒是<code>li</code>中的内容。</p></li><li><p><strong>匿名盒</strong>（anonymous box），<code>&lt;div&gt;Some inline text &lt;p&gt;followed by a paragraph&lt;/p&gt; followed by more inline text.&lt;/div&gt;</code></p></li></ul><p><code>Some inline text</code>这部分不能被选择器精确的选中，所有的属性都是<code>inherit</code>，整个<code>div</code>会生成一个盒，<code>Some inline text</code>这部分也会生成一个独立的盒，称作匿名盒。所以这种情况下一个元素生成了多个盒。匿名盒所有可继承的 CSS 属性值都为 <code>inherit</code> ，而所有不可继承的 CSS 属性值都为 <code>initial</code>。</p><p>元素只是对于HTML来说的，我们谈到<strong>布局（layout）时，都是在说盒的布局</strong>。可以说盒是css世界的基础，是css世界的最小单位。</p><p>大部分情况下盒和元素的关系是对应的，我们说属性时通常都是元素的属性，<del>盒的类型由最外层元素的</del><code>display</code><del>属性决定</del>。</p><p>盒主要有块级盒、行内级盒、匿名盒以及一些实验性的盒（未来可能添加到规范中）。我们主要分析块级盒和行内级盒。</p><h3 id="2-何为行内（inline），何为块（block），各有什么特性？"><a href="#2-何为行内（inline），何为块（block），各有什么特性？" class="headerlink" title="2.何为行内（inline），何为块（block），各有什么特性？"></a><strong>2.何为行内（inline），何为块（block），各有什么特性？</strong></h3><h4 id="块级"><a href="#块级" class="headerlink" title="块级"></a>块级</h4><ul><li><p><strong>块级元素 </strong>(block-level element)：<code>display</code>属性为<code>block</code>、<code>list-item</code>、<code>table</code> 的元素。主要对应的标签有:<code>div</code>，<code>p</code>，<code>h1</code>等。</p></li><li><p><strong>块级盒 </strong>(block-level box)：最外层元素是块级元素生成，对内部的子元素没有要求，子元素可以是行内元素。这个概念用来解释布局。【？？？又说内部元素要么都是块级盒，要么都是行内盒？？？】</p></li><li><p><strong>块容器盒</strong>（block containing box）：只是强调当前盒有包含其他的盒。</p></li><li><p><strong>块盒</strong>（block box）：既是块级盒又是块容器盒。</p></li></ul><h4 id="行内"><a href="#行内" class="headerlink" title="行内"></a>行内</h4><ul><li><p><strong>行内级元素</strong>（inline-level element）：<code>display</code>属性 为 <code>inline</code>、<code>inline-block</code>、<code>inline-table</code> 的元素。</p></li><li><p><strong>行内级盒</strong>（inline-level box）：由行内级元素生成。行内级盒包括行内盒子和原子行内级盒子两种，区别在于该盒子是否参与行内格式化上下文（IFC，inline formatting context）的创建。</p></li><li><p><strong>行内盒</strong>（inline box）：参与行内格式化上下文创建的行内级盒称为行内盒。与块盒类似，行内盒也分为具名行内盒和匿名行内盒（anonymous inline box）两种。</p></li><li><p><strong>原子行内级盒</strong>（atomic inline-level box）：不参与行内格式化上下文创建的行内级盒。原子行内级盒子一开始叫做原子行内盒（atomic inline box），后被修正。原子行内级盒的内容不会拆分成多行显示。</p></li></ul><p>空元素（empty element）：不存在子节点（子元素或元素内的内容）；</p><p>行内元素：<code>a b span img input select strong（强调的语气）</code></p><p>块级元素有：<code>div ul ol li dl dt dd h1 h2 h3 h4…p</code></p><p>常见的空元素： <code>&lt;br&gt; &lt;hr&gt; &lt;img&gt; &lt;input&gt; &lt;link&gt; &lt;meta&gt;</code>用的比较少的：<code>&lt;area&gt; &lt;base&gt; &lt;col&gt; &lt;command&gt; &lt;embed&gt; &lt;keygen&gt; &lt;param&gt; &lt;source&gt; &lt;track&gt; &lt;wbr&gt;</code></p><h3 id="3-页面是如何布局的？"><a href="#3-页面是如何布局的？" class="headerlink" title="3.页面是如何布局的？"></a><strong>3.页面是如何布局的？</strong></h3><p>谈布局时，实际上说的都是盒的定位。</p><p>主要有普通流（normal flow）、绝对定位(absolute)、浮动布局(float)三种情况。布局根据盒的<strong>display</strong>，<strong>postion</strong>和<strong>float</strong>属性来决定。</p><h4 id="普通流"><a href="#普通流" class="headerlink" title="普通流"></a>普通流</h4><p>元素的默认属性是<code>position:static,float:none</code>称为普通流，主要规则是：</p><blockquote><p>块级盒 垂直依次排列。行内盒水平依次排列。</p></blockquote><p>postion为static时，每个盒根据普通流所计算出的确切位置来定位。</p><p>position为relative时，相对定位，此时每个盒还根据top，bottom，left，right在<strong>原本的位置</strong>基础上进行偏移，也就是说不设置position为非static，四个偏移属性是不生效的。</p><p>普通流中的块级盒有一些规则：</p><ul><li><p>普通流中块级盒会独占一行，在垂直方向上，一个接一个放置。</p></li><li><p>块级盒<strong>垂直方向</strong>的距离由margin决定，相邻两个块级盒的会发生<strong>垂直方向的margin重叠</strong>，注意是垂直方向，水平方向不会有这个问题。</p></li></ul><p>解决margin重叠的方法在之后的BFC的规则中会解释。</p><p>让两个元素不属于一个BFC，层级不一样就可以避免这个问题。但是两个元素是平级的话还是会出现margin重叠，其实解决的方式是遵循了：BFC是独立的，不受到外部的影响。</p><h4 id="浮动布局"><a href="#浮动布局" class="headerlink" title="浮动布局"></a>浮动布局</h4><p>当position为static或relative，且float不为none时，为浮动定位，生成了<strong>浮动盒</strong>（floated/floating box）。浮动盒在垂直方向上会脱离文档流，水平方向上，还是一个个按顺序排列，有的靠左，有的靠右。</p><p>对于块级盒，本来是独占一行，宽度是100%，但是变成浮动盒之后，自身的宽度就开始变成由内部撑起来。</p><p>对周围其他盒的影响：</p><p>外层盒如果是行内盒，会伸缩来适应内部浮动盒的大小。</p><p>相邻盒会环绕在浮动盒周围。</p><h4 id="绝对定位"><a href="#绝对定位" class="headerlink" title="绝对定位"></a>绝对定位</h4><p>当元素的position为absolute或fixed时，为绝对定位。元素脱离文档流，位置上和其父元素及相邻元素不再有关系，其位置会使用 top、bottom、left 和 right 相对其包含块进行计算。</p><p>对固定位置的元素来说，其包含块为整个视口，该元素相对视口进行绝对定位，因此滚动时元素的位置并不会改变。</p><h3 id="4-BFC和IFC是什么？"><a href="#4-BFC和IFC是什么？" class="headerlink" title="4.BFC和IFC是什么？"></a>4.BFC和IFC是什么？</h3><p>除了上文提到的<strong>定位</strong>规则，视觉格式化模型（Visual Formatting Model）是页面布局的更细粒度的算法机制。</p><p>Formatting context 是 W3C CSS2.1 规范中的一个概念。它是页面中的一块<strong>独立的</strong>渲染区域，有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。核心作用在于这块<strong>区域内部独立，不受外部的影响也不影响外部</strong>。</p><p>最常见的 Formatting context 有 块级格式化上下文 Block fomatting context (简称BFC)和 内联格式化上下文Inline formatting context (简称IFC)。CSS2.1中只有BFC和IFC，CSS3中增加了GFC和FFC。</p><h4 id="形成BFC的条件"><a href="#形成BFC的条件" class="headerlink" title="形成BFC的条件"></a>形成BFC的条件</h4><p>一个BFC包含创建该上下文的所有子盒，但不包括创建了新BFC的子盒的内部元素，也是为了强调BFC的<strong>独立</strong>原则。</p><p>自身满足下列条件之一就可产生一个BFC</p><ul><li><p>root element 根元素</p></li><li><p>float:not none 存在浮动</p></li><li><p>position:absolute，fixed 绝对定位</p></li><li><p>display:inline-block, table-cell, table-caption, flex, inline-flex</p></li><li><p>overflow:not visible</p></li></ul><p><strong>那对于子元素有要求吗？</strong></p><p>我们知道context在英文中的含义是上下文，可以引申为是一种氛围，一种组成，一项规则。内部的盒形成了上下文，参与到上下文中，遵循上下文的规则。</p><p>BFC中的block-level box参与在BFC中，遵循BFC的规则。</p><p>IFC的inline-level box参与在IFC中，遵循IFC的规则。</p><p>父元素产生了一个BFC，虽然BFC的子元素中有span等行内元素，依然不影响这个BFC的存在，所以说内部盒可以不是块级盒的，但是只有块级盒会遵循BFC的规则。Formatting Context最重要的观念是强调<strong>内部独立，不受外界影响</strong>。</p><h4 id="BFC规则"><a href="#BFC规则" class="headerlink" title="BFC规则"></a>BFC规则</h4><ul><li><p>从左到右布局中，BFC的各个内部元素的左margin与包含块的左border内相接触，对于rtl布局相反。</p></li><li><p>BFC不与浮动盒重叠。</p></li><li><p>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。（但是容器本身还是会受到影响）。</p></li><li><p>计算整个BFC的高度时，浮动元素也参与计算（可以用来解决浮动情况下的高度崩塌，清浮动）。</p></li></ul><p>我们可以使用BFC和IFC的<strong>独立</strong>原则来解决一些问题。</p><h4 id="BFC的使用："><a href="#BFC的使用：" class="headerlink" title="BFC的使用："></a>BFC的使用：</h4><h5 id="1-清浮动"><a href="#1-清浮动" class="headerlink" title="1.清浮动"></a>1.清浮动</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">.parent&#123;width: 200px;border: 1px solid #e8e8e8;&#125;</span><br><span class="line">.child&#123;float: left;width:100px;height: 100px;border: 1px solid #666;&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;div class=&quot;parent&quot;&gt;</span><br><span class="line">&lt;div class=&quot;child&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;child&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>可以发现parent高度崩塌，根据<strong>计算BFC的高度时，浮动元素也参与计算，</strong>使parent成为BFC，加上<code>.parent{overflow:hidden}或float:not none;display:inline-block;position:absolute,fixed</code>都可清浮动</p><h5 id="2-解决margin重叠"><a href="#2-解决margin重叠" class="headerlink" title="2.解决margin重叠"></a>2.解决margin重叠</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">.parent&#123;width: 200px;border: 1px solid #e8e8e8;&#125;</span><br><span class="line">.child&#123;margin:100px;width:100px;height: 100px;border: 1px solid #666;&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;div class=&quot;parent&quot;&gt;</span><br><span class="line">&lt;div class=&quot;child&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;child&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>可以发现预期上下child之间的距离应该是400px但是实际是200px，所以想办法使其中一个child成为一个独立的BFC，不受到外界的影响，将其中一个child包一层<code>&lt;div class=&quot;wrap&quot;&gt;&lt;/div&gt;,.wrap{overflow:hidden;}</code></p><h5 id="3-两栏自适应实现"><a href="#3-两栏自适应实现" class="headerlink" title="3.两栏自适应实现"></a>3.两栏自适应实现</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">.content&#123;width: 200px;border: 1px solid #e8e8e8;&#125;</span><br><span class="line">.main&#123;height:200px;background: #fcc;&#125;</span><br><span class="line">.aside&#123;width: 100px; height: 150px; float: left; background: #f66;&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;div class=&quot;content&quot;&gt;</span><br><span class="line">&lt;div class=&quot;aside&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;main&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>现在的显示是content占一行，符合<strong>从左到右布局中，BFC的各个内部元素的左margin与包含块的左border内相接触</strong>。aside是浮动盒，想要实现两栏自适应，可以根据<strong>BFC不与浮动盒重叠可以</strong>加上<code>.main{overflow:hidden}</code>使main成为新的BFC即可。</p><p>以上所有的例子都体现了BFC最重要的<strong>独立</strong>原则。</p><p>BFC和浮动的关系：</p><p>浮动定位和清除浮动时只会应用于同一个BFC内的元素。</p><p>浮动不会影响其它BFC中元素的布局，而清除浮动只能清除同一BFC中在它前面的元素的浮动。</p><p>margin重叠也只会发生在属于同一BFC的块级元素之间。</p><h4 id="IFC"><a href="#IFC" class="headerlink" title="IFC"></a>IFC</h4><p>在IFC中，盒子从顶部开始一个接一个水平排列。</p><p>盒模型在IFC的元素中应用的不是很完全，给行内元素设置水平方向的padiding，border，margin会生效，但是垂直方向的margin并不会生效，而且垂直方向的padding和border看起来生效了，但是不会影响周围的元素，因为在IFC中，垂直方向上其他的inline box不会被padding和border推开。</p><p>一个包含着一些排成一条线的盒子的外层盒称为line box。（float元素也是排成一行呀？？？）</p><p>vertical-align对齐方式也多种多样：baseline，middle，top，bottom等。</p><p>IFC的规则很复杂，所以经常遇到vertical-align根本不生效的情况，根本没有text-align那么好用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">strong &#123;</span><br><span class="line">margin: 20px;</span><br><span class="line">padding: 20px;</span><br><span class="line">border: 5px solid #ff6700;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;p&gt;即使给</span><br><span class="line">&lt;strong&gt;这里&lt;/strong&gt;</span><br><span class="line">设置了垂直方向上的margin也不会生效，设置垂直方向的padding和border也不会影响外部</span><br><span class="line">&lt;/p&gt;</span><br></pre></td></tr></table></figure><p>IFC的规则</p><p><a href="https://segmentfault.com/a/1190000004246731" target="_blank" rel="noopener">https://segmentfault.com/a/1190000004246731</a></p><p><a href="#">https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Visual_formatting_model</a></p><h4 id="回顾与总结："><a href="#回顾与总结：" class="headerlink" title="回顾与总结："></a>回顾与总结：</h4><p>1.行内元素和块级元素等基础知识总结。</p><p>2.定位规则有三种：1.普通流，2.浮动布局，3.绝对定位。</p><p>3.BFC乃至Formatting Context 最重要的特性就是<strong>内部独立，不受外部影响</strong>。可以用来解决<strong>高度崩塌</strong>，<strong>清浮动</strong>，<strong>margin重叠</strong>，<strong>两栏自适应</strong>等常见问题。</p><h4 id="常见的面试问题与细节思考："><a href="#常见的面试问题与细节思考：" class="headerlink" title="常见的面试问题与细节思考："></a>常见的面试问题与细节思考：</h4><p>1.position的四种属性有啥区别</p><p>2.BFC是什么</p><p>3.怎么清除浮动</p><p>4.两栏自适应和多栏自适应的实现方式</p><p>5.水平居中和垂直居中的实现方式</p><p>现在可以回答上来了吧。</p>]]></content>
      
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>通过伪元素来得到一些常见的icon</title>
      <link href="/2017/03/18/%E9%80%9A%E8%BF%87%E4%BC%AA%E5%85%83%E7%B4%A0%E6%9D%A5%E5%BE%97%E5%88%B0%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9A%84icon/"/>
      <url>/2017/03/18/%E9%80%9A%E8%BF%87%E4%BC%AA%E5%85%83%E7%B4%A0%E6%9D%A5%E5%BE%97%E5%88%B0%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9A%84icon/</url>
      
        <content type="html"><![CDATA[<p>通过伪元素<code>:before</code>和<code>:after</code>来得到一些常用的icon<br><a id="more"></a></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">// caret</span><br><span class="line"><span class="selector-class">.icon_caret</span> &#123;</span><br><span class="line"><span class="attribute">display</span>: block;</span><br><span class="line"><span class="attribute">margin</span>: <span class="number">5px</span> <span class="number">0</span> <span class="number">0</span> <span class="number">5px</span>;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">line-height</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">font-size</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">border-width</span>: <span class="number">5px</span>;</span><br><span class="line"><span class="attribute">border-style</span>: solid;</span><br><span class="line"><span class="attribute">border-color</span>: <span class="number">#9d9d9d</span> transparent transparent transparent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// &gt;</span><br><span class="line"><span class="selector-class">.icon_gter</span>&#123;</span><br><span class="line"><span class="attribute">width</span>: .<span class="number">16rem</span>;</span><br><span class="line"><span class="attribute">height</span>: .<span class="number">16rem</span>;</span><br><span class="line"><span class="attribute">margin</span>: <span class="number">0</span> <span class="number">12px</span>;</span><br><span class="line"><span class="attribute">display</span>: block;</span><br><span class="line"><span class="attribute">position</span>: relative;</span><br><span class="line"><span class="attribute">margin-top</span>: <span class="number">0</span>;</span><br><span class="line">&amp;:after&#123;</span><br><span class="line"><span class="selector-tag">content</span>: "";</span><br><span class="line"><span class="selector-tag">width</span>: <span class="selector-class">.08rem</span>;</span><br><span class="line"><span class="selector-tag">height</span>: <span class="selector-class">.08rem</span>;</span><br><span class="line"><span class="selector-tag">border-width</span>: 1<span class="selector-tag">px</span>;</span><br><span class="line"><span class="selector-tag">border-style</span>: <span class="selector-tag">solid</span>;</span><br><span class="line"><span class="selector-tag">border-color</span>: <span class="selector-tag">transparent</span> <span class="selector-tag">transparent</span> <span class="selector-tag">rgba</span>(0,0,0,0<span class="selector-class">.3</span>) <span class="selector-tag">rgba</span>(0,0,0,0<span class="selector-class">.3</span>);</span><br><span class="line"><span class="selector-tag">-webkit-transform</span>: <span class="selector-tag">rotate</span>(<span class="selector-tag">-135deg</span>);</span><br><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">rotate</span>(<span class="selector-tag">-135deg</span>);</span><br><span class="line"><span class="selector-tag">position</span>: <span class="selector-tag">absolute</span>;</span><br><span class="line"><span class="selector-tag">left</span>: <span class="selector-class">.05rem</span>;</span><br><span class="line"><span class="selector-tag">top</span>: <span class="selector-class">.04rem</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// &lt;</span><br><span class="line"><span class="selector-class">.icon_lser</span>&#123;</span><br><span class="line"><span class="attribute">width</span>: .<span class="number">16rem</span>;</span><br><span class="line"><span class="attribute">height</span>: .<span class="number">16rem</span>;</span><br><span class="line"><span class="attribute">margin</span>: <span class="number">0</span> <span class="number">12px</span>;</span><br><span class="line"><span class="attribute">display</span>: block;</span><br><span class="line"><span class="attribute">position</span>: relative;</span><br><span class="line"><span class="attribute">margin-top</span>: <span class="number">0</span>;</span><br><span class="line">&amp;:after&#123;</span><br><span class="line"><span class="selector-tag">content</span>: "";</span><br><span class="line"><span class="selector-tag">width</span>: <span class="selector-class">.08rem</span>;</span><br><span class="line"><span class="selector-tag">height</span>: <span class="selector-class">.08rem</span>;</span><br><span class="line"><span class="selector-tag">border-width</span>: 1<span class="selector-tag">px</span>;</span><br><span class="line"><span class="selector-tag">border-style</span>: <span class="selector-tag">solid</span>;</span><br><span class="line"><span class="selector-tag">border-color</span>: <span class="selector-tag">transparent</span> <span class="selector-tag">transparent</span> <span class="selector-tag">rgba</span>(0,0,0,0<span class="selector-class">.3</span>) <span class="selector-tag">rgba</span>(0,0,0,0<span class="selector-class">.3</span>);</span><br><span class="line"><span class="selector-tag">-webkit-transform</span>: <span class="selector-tag">rotate</span>(<span class="selector-tag">-45deg</span>);</span><br><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">rotate</span>(<span class="selector-tag">-45deg</span>);</span><br><span class="line"><span class="selector-tag">position</span>: <span class="selector-tag">absolute</span>;</span><br><span class="line"><span class="selector-tag">left</span>: <span class="selector-class">.05rem</span>;</span><br><span class="line"><span class="selector-tag">top</span>: <span class="selector-class">.04rem</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.triangle</span>&#123;</span><br><span class="line"><span class="attribute">width</span>:<span class="number">0</span>;</span><br><span class="line"><span class="attribute">height</span>:<span class="number">0</span>;</span><br><span class="line"><span class="attribute">border-width</span>:<span class="number">20px</span>;</span><br><span class="line"><span class="attribute">border-style</span>:solid;</span><br><span class="line"><span class="attribute">border-color</span>:transparent transparent red transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意每个border-color对应一个三角形</p>]]></content>
      
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>git 操作及原理</title>
      <link href="/2017/03/12/git-%E6%93%8D%E4%BD%9C%E5%8F%8A%E5%8E%9F%E7%90%86/"/>
      <url>/2017/03/12/git-%E6%93%8D%E4%BD%9C%E5%8F%8A%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>最近全面整理下工作中遇到的git问题，了解了下git工作的原理。<br><a id="more"></a></p><h3 id="TODO概念解析"><a href="#TODO概念解析" class="headerlink" title="TODO概念解析"></a>TODO概念解析</h3><p>工作区，暂存区，远端</p><p>一些blob，tree，commit对象的内部概念</p><p>.git文件夹下的内容</p><p>git merge origin/other_branch时有时会自动merge<br>可以故意commit一个有冲突的再merge就可以显示merge的全部内容了</p><p>WIP：在进行中，避免被merge</p><p>参考书籍<a href="http://iissnan.com/progit/" target="_blank" rel="noopener">http://iissnan.com/progit/</a></p><h4 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h4><p>可以看到<code>.git/HEAD</code>中内容</p><p>当在master分支时，内容为<code>ref: refs/heads/master</code></p><p>当在master分支时，内容为<code>ref: refs/heads/master</code></p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出所有config</span></span><br><span class="line">git config --list</span><br><span class="line"></span><br><span class="line">git config --global user.name <span class="string">'Eva'</span></span><br><span class="line"></span><br><span class="line">git config --global user.email <span class="string">'eva@163.com'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 换行符转为crlf</span></span><br><span class="line">git config --global core.autocrlf ture</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置git last为显示上次提交信息，git last -p</span></span><br><span class="line">git config --global alias.last <span class="string">'log -1 HEAD'</span></span><br></pre></td></tr></table></figure><h3 id="生成私钥，添加在setting里"><a href="#生成私钥，添加在setting里" class="headerlink" title="生成私钥，添加在setting里"></a>生成私钥，添加在setting里</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># git clone时ssh的方式，这样就免去了每次提交输密码</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看私钥</span></span><br><span class="line"><span class="built_in">cd</span> ~/.ssh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成私钥</span></span><br><span class="line">ssh-keygen -t rsa -C <span class="string">"zhangchu@xiaomi.com"</span></span><br></pre></td></tr></table></figure><h3 id="新建repository"><a href="#新建repository" class="headerlink" title="新建repository"></a>新建repository</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cd d/workspace</span><br><span class="line"></span><br><span class="line">mkdir demo</span><br><span class="line"></span><br><span class="line">git init</span><br><span class="line"></span><br><span class="line">git remote add origin &apos;https://github.com/EvaLotus/EvaLotus.github.io&apos;</span><br><span class="line"></span><br><span class="line"># 第一次需要-u</span><br><span class="line">git push -u origin/master</span><br></pre></td></tr></table></figure><h3 id="commit"><a href="#commit" class="headerlink" title="commit"></a>commit</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"># 查看修改新增了哪些文件</span><br><span class="line">git status</span><br><span class="line"></span><br><span class="line"># 提交之前查看下修改了啥，不会列出新增的文件</span><br><span class="line">git diff</span><br><span class="line"></span><br><span class="line"># 具体文件修改了啥</span><br><span class="line">git diff a.txt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 丢弃所有修改</span><br><span class="line">git checkout -- .</span><br><span class="line"></span><br><span class="line"># 只是添加到暂存区下管理，被管理</span><br><span class="line">git add file.txt</span><br><span class="line"></span><br><span class="line">git add . //新增和修改的文件都会有，删除不会有，所有文件添加到暂存区</span><br><span class="line"></span><br><span class="line">git add -u //已经被添加的文件的修改</span><br><span class="line"></span><br><span class="line">git add -A //是上面两个功能的合集（git add --all的缩写）</span><br><span class="line"></span><br><span class="line">git add -f//强制add，把gitignore里的也会添加</span><br><span class="line"></span><br><span class="line"># 删除某文件</span><br><span class="line">git rm</span><br><span class="line">git rm --cached # 从tracked变成untracked</span><br><span class="line">git rm -f # 必须是tracked的才能使用，直接删除文件</span><br><span class="line"></span><br><span class="line">//暂存</span><br><span class="line"></span><br><span class="line">git stash</span><br><span class="line"></span><br><span class="line">git stash pop//恢复暂存</span><br><span class="line"></span><br><span class="line">git status//查看哪些没提交的</span><br><span class="line"></span><br><span class="line">git commit -m &quot;my 这里是注释&quot;</span><br><span class="line"></span><br><span class="line">git commit -am &quot;这里是注释&quot;//多个提交时用-a</span><br></pre></td></tr></table></figure><h3 id="回退"><a href="#回退" class="headerlink" title="回退"></a>回退</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">git log//先查看log</span><br><span class="line"></span><br><span class="line"># reset</span><br><span class="line">git reset --hard HEAD~~几个~就是回退几个版本，此处是本地回退</span><br><span class="line"></span><br><span class="line">git reset –hard HEAD^ //回退到上个版本</span><br><span class="line"></span><br><span class="line">git reset -hard HEAD~100//回退到上100个版本</span><br><span class="line"></span><br><span class="line"># revert</span><br><span class="line"></span><br><span class="line">git push -f origin master就是强制push到远端</span><br></pre></td></tr></table></figure><h3 id="Branch"><a href="#Branch" class="headerlink" title="Branch"></a>Branch</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">git branch -a //查看所有分支（包括远端和本地）</span><br><span class="line"># 查看本地分支</span><br><span class="line">git branch</span><br><span class="line"></span><br><span class="line"># 查看所有远端分支</span><br><span class="line">git branch -r</span><br><span class="line"></span><br><span class="line"># 查看本地已merged的分支</span><br><span class="line">git branch --merged</span><br><span class="line"></span><br><span class="line"># 查看本地未merged的分支</span><br><span class="line">git branch --no-merged</span><br><span class="line"></span><br><span class="line"># 新建分支，但是不切换到此分支</span><br><span class="line">git branch mybranch</span><br><span class="line"></span><br><span class="line"># 删除本地分支，可删除多个</span><br><span class="line">git branch -d mybranch1 mybranch2</span><br><span class="line"></span><br><span class="line"># 强制删除本地未merge分支</span><br><span class="line">git branch -D mybranch</span><br><span class="line"></span><br><span class="line"># 删除远端分支</span><br><span class="line">git push origin :mybranch</span><br><span class="line"># 或</span><br><span class="line">git push origin --delete mybranch</span><br></pre></td></tr></table></figure><h4 id="关于删除远端分支注意："><a href="#关于删除远端分支注意：" class="headerlink" title="关于删除远端分支注意："></a>关于删除远端分支注意：</h4><p>删除远端分支后<code>另一个用户</code>并不能获取到分支被删除了,<code>git branch -r</code>也依然能获取到被删除的分支</p><p>这说明，remotes/origin/* 这些远程跟踪分支，仅仅是远程分支的一个缓存，并且，不能通过git fetch 命令获取到分支删除的更新</p><p>可以通过<code>git remote show origin</code>来查看，会列出所有分支状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">branchA tracked</span><br><span class="line">refs/remotes/origin/deletedBranchA stale (use &apos;git remote prune&apos; to remove)</span><br><span class="line">refs/remotes/origin/deletedBranchB stale (use &apos;git remote prune&apos; to remove)</span><br></pre></td></tr></table></figure><p>被删除的分支<code>refs/remotes/origin/deletedBranch</code>状态是<code>stale</code>(陈旧的)</p><p>后面有提示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git remote prune origin</span><br><span class="line"># 或</span><br><span class="line">git fetch -p</span><br></pre></td></tr></table></figure><h3 id="Stash"><a href="#Stash" class="headerlink" title="Stash"></a>Stash</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 暂存</span><br><span class="line">git stash</span><br><span class="line"></span><br><span class="line"># 列出所有暂存</span><br><span class="line">git stash list</span><br><span class="line"></span><br><span class="line"># 列出上次暂存</span><br><span class="line">git stash show</span><br><span class="line"></span><br><span class="line"># 恢复暂存，删除list中的</span><br><span class="line">git stash pop stash@&#123;0&#125;</span><br><span class="line"></span><br><span class="line"># 只恢复暂存，list中不删除</span><br><span class="line">git stash apply stash@&#123;0&#125;</span><br></pre></td></tr></table></figure><h3 id="checkout"><a href="#checkout" class="headerlink" title="checkout"></a>checkout</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 在本地新建一个分支test并切换到此分支</span><br><span class="line">git checkout -b test</span><br><span class="line"></span><br><span class="line"># 切换已有的远端分支或本地分支</span><br><span class="line">git checkout test</span><br><span class="line"></span><br><span class="line"># 放弃工作区修改的某文件</span><br><span class="line">git checkout -- a.js</span><br><span class="line"></span><br><span class="line"># 放弃所有工作区文件的修改，未commit的，不影响未add的</span><br><span class="line">git checkout -- .</span><br></pre></td></tr></table></figure><h3 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">git checkout dev</span><br><span class="line"></span><br><span class="line">git merge origin/master //把master merge到 dev</span><br><span class="line"></span><br><span class="line">git push origin test //在远程仓库也新建一个分支test</span><br><span class="line"></span><br><span class="line"># cherry-pick</span><br><span class="line">git cherry-pick commitId</span><br><span class="line"></span><br><span class="line"># 和rebase的区别是？rebase的commit history会更干净一点</span><br><span class="line">git rabase</span><br></pre></td></tr></table></figure><h3 id="Reflog和log"><a href="#Reflog和log" class="headerlink" title="Reflog和log"></a>Reflog和log</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 只列出commit的log</span><br><span class="line">git log</span><br><span class="line"></span><br><span class="line"># 列出所有操作，包括pull，checkout</span><br><span class="line">git reflog</span><br><span class="line"></span><br><span class="line"># 查看是谁修改的</span><br><span class="line">git blame file</span><br></pre></td></tr></table></figure><p>git的HEAD是当前活跃分支游标</p><p>全局问题</p><p>git log</p><p>退出git log在英文状态下按Q</p><p>使用小乌龟的log来查看历史</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">git fetch //fetch和pull的区别，fetch不会自动merge更安全点</span><br><span class="line"></span><br><span class="line">git log //在英文状态下按Q退出</span><br><span class="line"></span><br><span class="line">git rm</span><br><span class="line"></span><br><span class="line">origin算是仓库名，可以命名为其他的</span><br><span class="line"></span><br><span class="line">git pull origin</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">关于git remote对应的都是仓库</span><br><span class="line"></span><br><span class="line">git的origin指向的是本地的代码库托管在github的版本</span><br><span class="line"></span><br><span class="line">git remote -v</span><br><span class="line"></span><br><span class="line">git remote存在的远端分支 origin</span><br><span class="line"></span><br><span class="line">git remote add 就是说可以创建多个远程仓库</span><br><span class="line"></span><br><span class="line">git remote rm repositoryName删除远程仓库</span><br><span class="line"></span><br><span class="line">git remote rename eva origin 重命名远程仓库</span><br><span class="line"></span><br><span class="line">git remote add https://github.com/EvaLotus/test.git 在本地仓库添加一个远程仓库，并将master跟踪到远程分支</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">git push origin mybranch:master把我的分支push到远端哪个分支上</span><br><span class="line"></span><br><span class="line">git push origin mybranch:staging</span><br></pre></td></tr></table></figure><p>gitlab网站上发出merge request</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 带*的表示当前分支</span><br><span class="line"># 回退到merge前</span><br><span class="line">git reset --merge</span><br></pre></td></tr></table></figure><ul><li>sourceTree请使用英文版的，不然太难用啦！！</li></ul><h4 id="gitlab中的权限管理"><a href="#gitlab中的权限管理" class="headerlink" title="gitlab中的权限管理"></a>gitlab中的权限管理</h4><p>只有owner在setting里可以邀请member，给member设置master的权限，否则是protected状态</p><h4 id="svn和git的区别"><a href="#svn和git的区别" class="headerlink" title="svn和git的区别"></a>svn和git的区别</h4><ul><li><p>SVN是集中式版本控制系统，版本库是集中放在中央服务器的，而干活的时候，用的都是自己的电脑，所以首先要从中央服务器哪里得到最新的版本，然后干活，干完后，需要把自己做完的活推送到中央服务器。集中式版本控制系统是必须联网才能工作，如果在局域网还可以，带宽够大，速度够快，如果在互联网下，如果网速慢的话，就纳闷了。</p></li><li><p>Git是分布式版本控制系统，那么它就没有中央服务器，每个人的电脑就是一个完整的版本库，这样，工作的时候就不需要联网了，因为版本都是在自己的电脑上。既然每个人的电脑都有一个完整的版本库，那多个人如何协作呢？比如说自己在电脑上改了文件A，其他人也在电脑上改了文件A，这时，你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。</p></li></ul><h3 id="基于-Git-Flow-的开发流程"><a href="#基于-Git-Flow-的开发流程" class="headerlink" title="基于 Git Flow 的开发流程"></a>基于 Git Flow 的开发流程</h3><h4 id="Git-Flow-分支模型"><a href="#Git-Flow-分支模型" class="headerlink" title="Git Flow 分支模型"></a>Git Flow 分支模型</h4><ul><li>master 分支 =&gt; 正式环境（最为稳定功能最为完整）</li><li>test 分支（release分支） =&gt; 测试环境（发布定期要上线的功能）</li><li>dev 分支 =&gt; 团队协作的发开环境（功能最新最全的分支）</li><li>hotfix 分支 =&gt; 修复线上代码的 bug</li><li>feature分支 =&gt; 某个功能点正在开发阶段</li><li><h4 id="开发阶段"><a href="#开发阶段" class="headerlink" title="开发阶段"></a>开发阶段</h4></li><li><p>开发 on your branch</p></li><li><p>gitlab上发起merge request</p></li><li><p>code review，accept merge request，delete branch</p></li></ul><h4 id="测试阶段"><a href="#测试阶段" class="headerlink" title="测试阶段"></a>测试阶段</h4><ol><li>完成新功能后，dev 分支提交到 test 分支（release分支），进行测试</li><li>有bug：创建hotfix 分支（修复后合并到 test 分支）</li></ol><h4 id="发布上线"><a href="#发布上线" class="headerlink" title="发布上线"></a>发布上线</h4><ol><li>release 分支合并进 master 和 develop</li><li>上线</li><li>线上环境小 bug：创建 hotfix 分支进行修改，大bug：版本回滚</li></ol><h4 id="分支命名"><a href="#分支命名" class="headerlink" title="分支命名"></a>分支命名</h4><p>参考：</p><ul><li>feature——按照功能点（而不是需求）命名；</li><li>test(release)——用发布时间命名，可以加上适当的前缀；</li><li>hotfix——GitLab 的 issue 编号或 bug 性质等。</li></ul><h4 id="Commit-Message格式"><a href="#Commit-Message格式" class="headerlink" title="Commit Message格式"></a>Commit Message格式</h4><p>star多的项目都有完善的文档体系和高覆盖的测试用例</p><h4 id="type"><a href="#type" class="headerlink" title="type"></a>type</h4><ul><li><p>feat：新功能（feature）</p></li><li><p>fix：修补bug</p></li><li><p>docs：文档（documentation）</p></li><li><p>style： 格式（不影响代码运行的变动）</p></li><li><p>refactor：重构（即不是新增功能，也不是修改bug的代码变动）</p></li><li><p>test：增加测试</p></li><li><p>chore：构建过程或辅助工具的变动</p></li></ul><h4 id="Scope"><a href="#Scope" class="headerlink" title="Scope"></a>Scope</h4><p>用来说明本次Commit影响的范围，即简要说明修改会涉及的部分。这个本来是选填项，但从AngularJS实际项目中可以看出基本上也成了必填项了。</p><p>用来简要描述本次改动，概述就好了，因为后面还会在Body里给出具体信息。并且最好遵循下面三条:</p><h4 id="Subject"><a href="#Subject" class="headerlink" title="Subject"></a>Subject</h4><ul><li><p>以动词开头，使用第一人称现在时，比如change，而不是changed或changes</p></li><li><p>首字母不要大写</p></li><li><p>结尾不用句号(.)</p></li></ul><h4 id="Body"><a href="#Body" class="headerlink" title="Body"></a>Body</h4><p>&lt;body&gt;里的内容是对上面subject里内容的展开，在此做更加详尽的描述，内容里应该包含修改动机和修改前后的对比。</p><h4 id="Revert"><a href="#Revert" class="headerlink" title="Revert"></a>Revert</h4><p>此外如果需要撤销之前的Commit，那么本次Commit Message中必须以revert：开头，后面紧跟前面描述的Header部分，格式不变。并且，Body部分的格式也是固定的，必须要记录撤销前Commit的SHA值。</p><p>git pull = git fetch +git merge</p><p>在git merge时会自动生成个merge的时间节点在commit记录里</p><h4 id="rebase和merge"><a href="#rebase和merge" class="headerlink" title="rebase和merge"></a>rebase和merge</h4><p>两者都是用来合并分支，细节处理上有些不一样</p><p>[rebase](<a href="https://mp.weixin.qq.com/s?__biz=MzAwNDYwNzU2MQ==&amp;mid=400938481&amp;idx=1&amp;sn=f4d92674ebf00c0a208936e6467c3da1&amp;scene=21#wechat_redirect%29\" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzAwNDYwNzU2MQ==∣=400938481&amp;idx=1&amp;sn=f4d92674ebf00c0a208936e6467c3da1&amp;scene=21#wechat_redirect\</a></p><h3 id="git迁移"><a href="#git迁移" class="headerlink" title="git迁移"></a>git迁移</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote set-url origin git@v9.git.n.xiaomi.com:infosec/midun_ui_web.git</span><br><span class="line">git remote set-url --push origin git@v9.git.n.xiaomi.com:infosec/midun_ui_web.git</span><br></pre></td></tr></table></figure><h3 id="git-hook自动部署"><a href="#git-hook自动部署" class="headerlink" title="git hook自动部署"></a>git hook自动部署</h3><p>ssh <a href="mailto:git@gitlab.com" target="_blank" rel="noopener">git@gitlab.com</a> -T</p><h4 id="git迁移-1"><a href="#git迁移-1" class="headerlink" title="git迁移"></a>git迁移</h4><p>#!/bin/bash<br>git checkout master<br>git pull origin master –all</p><p>for branch in <code>git branch -a | grep remotes | grep -v HEAD | grep -v master</code>; do<br>git branch –track ${branch#remotes/origin/} $branch<br>done</p><p>export new_repo=$1<br>git remote set-url origin $new_repo<br>git remote set-url –push origin $new_repo<br>git remote -v<br>git push -u origin –all<br>git push -u origin –tags</p><p>mind map</p><p><img src="/assets/git.png" alt=""></p>]]></content>
      
      
      
        <tags>
            
            <tag> tool </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>hexo+github pages 搭建 blog及防坑指南</title>
      <link href="/2016/12/18/hexo+github_pages%E6%90%AD%E5%BB%BAblog%E5%8F%8A%E9%98%B2%E5%9D%91%E6%8C%87%E5%8D%97/"/>
      <url>/2016/12/18/hexo+github_pages%E6%90%AD%E5%BB%BAblog%E5%8F%8A%E9%98%B2%E5%9D%91%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<p>在超哥的安利下，开始使用hexo+githubpages搭建自己的博客。对于前端同学来说，基于Node.js的hexo可谓是非常友好的选择。</p><p>前两天超哥很开心的敲下<code>hexo d</code>，过了两天整理文件时一不小心手贱删掉了项目，写了4年的博客全都没有啦，只能一个个copy出来，简直是喜闻乐见（超哥不要打我，逃～）</p><a id="more"></a><p>基本操作大家都可以在hexo详尽的文档中找到，但是一些文档之外的最佳实践，在此记录下。</p><h4 id="基本搭建操作"><a href="#基本搭建操作" class="headerlink" title="基本搭建操作"></a>基本搭建操作</h4><p>以下是搭建hexo博客基本操作，只是mark一下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装hexo命令行工具</span></span><br><span class="line">nmp i hexo-cli -g</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在此目录搭建博客，在github创建此项目</span></span><br><span class="line"><span class="built_in">cd</span> EvaLotus.github.io</span><br><span class="line"><span class="comment"># 新搭建的blog需要这一行</span></span><br><span class="line">hexo init</span><br><span class="line"><span class="comment"># 安装依赖</span></span><br><span class="line">npm install</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动服务，一个基本的博客就已经搭建好了</span></span><br><span class="line">hexo s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 选择喜欢的主题，如next，实在是太容易撞衫了，但是确实是极简主义的爱</span></span><br><span class="line"><span class="comment"># 将主题clone至themes目录下</span></span><br><span class="line"><span class="comment"># 每次换电脑重新clone项目都需要执行这一步哦</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/theme-next/hexo-theme-next themes/next</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在外层_confif.yml中改theme为next</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除generate的文件，切换主题时最好执行下，可以不用自己删掉public文件</span></span><br><span class="line">hexo clean****</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成public目录，可以在本地调试时使用</span></span><br><span class="line">hexo g</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果只是直接部署</span></span><br><span class="line">hexo d</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一篇博客</span></span><br><span class="line">hexo new <span class="string">'HelloWorld'</span></span><br></pre></td></tr></table></figure><p>很容易就搭建好了自己的博客，下面是一些常见问题的解决。</p><h4 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h4><p><strong>1.怎么能将github.io的域名改成自己申请的域名？</strong></p><p>首先你需要在万网或其他平台上买个域名，一般50元/年。购买完成后需要在购买域名的管理后台进行CNAME解析，目的是将gitubpages的地址比如<code>https://github.com/EvaLotus/EvaLotus.github.io</code>指向你购买的域名<code>evacoder.com</code>。<br>然后直接在github的project settings里，设置custom domain，这样就会自动在你的项目中增加一个CNAME文件，里面会记录你自己的域名。</p><p><strong>2.如何<code>hexo d</code>自动更新部署博客</strong></p><p>需要安装插件<code>npm i hexo-deployer-git --save</code>，在<code>_config.yml</code>中配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line">deploy:</span><br><span class="line"><span class="built_in">type</span>: git</span><br><span class="line">repo: git@github.com:EvaLotus/EvaLotus.github.io.git</span><br><span class="line">branch: master</span><br></pre></td></tr></table></figure><p>配置完成之后，每次<code>hexo d</code>都会自动将编译好的文件提交到master分支上，并部署完成。</p><p>还需要在配置_config.yml时一定要注意此类文件对缩进要求很严格，在sublime中编辑会有适当的颜色提醒你是否缩进正确。</p><p><strong>3.每次<code>hexo d</code>之后我的CNAME都没了怎么办？</strong></p><p>小伙伴们应该都发现了，<code>hexo d</code>之后并没有push source目录，只是push生成后的public中的文件，所以我们要注意，CNAME，README，Favicon.ico都应该放在source目录下，这样<code>hexo d</code>之后会直接copy到public的根目录下</p><p><strong>4.换电脑了或者像超哥那样误删了源文件怎么办？</strong></p><p>很多小伙伴应该都有同时在公司和在家修改博客的需求，一换电脑就懵逼，github上新clone下来的只有编译后的文件。</p><p>或者很久不写博客，整理文件时一不小心把源文件删掉了。</p><p>其实我们可以使用<strong>分支来管理我们的博客</strong>，简言之，master上存放生成的静态文件，hexo存放源文件。</p><p>操作之前我们要分清职责，既然hexo上只存放源文件，那么我们要配置合理的<code>.gitignore</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.DS_Store</span><br><span class="line">Thumbs.db</span><br><span class="line">db.json</span><br><span class="line">*.log</span><br><span class="line">node_modules/</span><br><span class="line">.deploy*/</span><br><span class="line"># public和themes文件在hexo分支上都应该不应该被提交，因为是我们自己写的</span><br><span class="line"># 但是themes中的_confif.yml我们需要copy一份在source目录下备用，以免换电脑之后丢失</span><br><span class="line"># 合理的管理分支和文件，不要给自己埋坑</span><br><span class="line">public/</span><br><span class="line">themes/</span><br></pre></td></tr></table></figure><p>操作上并不需要切换分支，按下面的步骤配置之后，每次操作都在hexo分支上修改，不用再管master分支了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 切出hexo分支</span></span><br><span class="line">git checkout -b hexo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以后都在此分支上修改，虽然hexo d可以帮你将生成的静态文件自动push到master</span></span><br><span class="line">git checkout master</span><br><span class="line">hexo d</span><br><span class="line"></span><br><span class="line"><span class="comment"># 但是每次修改之后一定要记得自己把hexo分支上的源文件的修改push一下！！</span></span><br><span class="line">git push origin/hexo</span><br><span class="line"></span><br><span class="line"><span class="comment"># Easy!</span></span><br><span class="line"><span class="comment"># 这样换电脑之后直接很快就可以获取到博客源文件了</span></span><br><span class="line">git <span class="built_in">clone</span> git@github.com:EvaLotus/EvaLotus.github.io.git</span><br><span class="line">git checkout hexo</span><br><span class="line">npm install</span><br><span class="line"><span class="comment"># 因为theme文件在gitignore下，所以每次还需要重新clone下，不然会遇到no layout的错误。</span></span><br><span class="line"><span class="comment"># 把source中的_confif.theme.yml copy回来</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/theme-next/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure><p>我的博客可能不是最好看的，但是一定是目录结构最清爽的！</p><p><strong>5.怎么维护博客呢？</strong><br>我之前都是在gitbook上做学习笔记，语言很随意，排版很混乱，这样并不利于知识的沉淀，不仅仅要自己理解，更要能陈述的让其他人一看就明白，像阮一峰老师那样，由浅入深，把复杂的只是说清楚。</p><p>现在把gitbook的笔记都整理成博客之后，也不敢把gitbook的笔记删掉，一旦遇到维护两份差不多的文档时，我们就要警惕，他们一定会差别越来越大，最后有一份会被放弃，要不然就是要花更多的时间来整理。</p><p>既然写blog可以让我们知识沉淀更深，那么就写在博客上吧。</p><p>但是直接在sublime中写markdown并不能所见即所得，我想到的办法是在gitbook中直接打开博客的source目录，这样既能所见即所得，又保持了唯一性，之后会把gitbook上零碎的知识整理成每个人都能看懂的文章。</p><p><strong>6.分享愉快的写博客体验</strong><br><code>hexo s</code>之后我们修改了markdown之后，再</p><p>其他问题可以直接去看<a href="https://hexo.io/zh-cn/docs/index.html" target="_blank" rel="noopener">hexo的文档</a>，已经灰常良心了！</p><p>搭建博客很简单，有很多漂亮的主题可供大家选择，但是博客的壳子并没有那么重要，最重要的是保持每天记录的习惯，分享高质量的内容。</p><p>如果遇到其他问题可以给我留言，一起来搭建自己的博客吧。</p>]]></content>
      
      
      
        <tags>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>HTML条件注释</title>
      <link href="/2016/12/10/HTML%E6%9D%A1%E4%BB%B6%E6%B3%A8%E9%87%8A/"/>
      <url>/2016/12/10/HTML%E6%9D%A1%E4%BB%B6%E6%B3%A8%E9%87%8A/</url>
      
        <content type="html"><![CDATA[<p>在ie8-下不加入某个功能，回想起那个遥远的年代，初次见到是在Bootstrap中，低版本ie需要加载html5shiv，用到了条件注释。<br>希望幸福的你们都不需要用到~</p><a id="more"></a><p>在ie8-就不要加载某个js，通过条件注释即可实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--[if !IE]&gt; 除IE外都可识别 &lt;![endif]--&gt;</span><br><span class="line">&lt;!--[if IE]&gt; 所有的IE可识别 &lt;![endif]--&gt;</span><br><span class="line">&lt;!--[if IE 8]&gt; 仅IE8可识别 &lt;![endif]--&gt;</span><br><span class="line">&lt;!--[if lt IE 6]&gt; IE6以及IE6以下（&lt;）版本可识别 &lt;![endif]--&gt;</span><br><span class="line">&lt;!--[if lte IE 7]&gt; IE7以及IE7以下（&lt;=）版本可识别 &lt;![endif]--&gt;</span><br><span class="line">&lt;!--[if gt IE 7]&gt; IE7以及IE7以上（&gt;）版本可识别 &lt;![endif]--&gt;</span><br><span class="line">&lt;!--[if gte IE 6]&gt; IE6以及IE6（&gt;=）以上版本可识别 &lt;![endif]--&gt;</span><br></pre></td></tr></table></figure><p>其实此标签是IE提供的，只有IE可以识别，所以在其他的浏览器中会被当做注释忽略掉。<br>IE10 之后不再支持条件注释，也就是说就会被当成一个普通的注释忽略掉。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 下面这段是 向下隐藏 语法，必须是IE且版本低于IE9--&gt;</span><br><span class="line">&lt;!--[if lt IE 9]&gt;</span><br><span class="line">&lt;script src=&quot;~/Scripts/jquery-1.9.1.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;![endif]--&gt;</span><br><span class="line">&lt;!-- 下面这段是 向下显示 语法，版本高于IE 9或不是IE时--&gt;</span><br><span class="line">&lt;!--[if gte IE 9]&gt;&lt;!--&gt;</span><br><span class="line">&lt;script src=&quot;~/Scripts/jquery-2.0.0.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;!--&lt;![endif]--&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「 CSS 」display属性居然有这么多</title>
      <link href="/2016/11/28/display%E5%B1%9E%E6%80%A7%E5%B1%85%E7%84%B6%E6%9C%89%E8%BF%99%E4%B9%88%E5%A4%9A/"/>
      <url>/2016/11/28/display%E5%B1%9E%E6%80%A7%E5%B1%85%E7%84%B6%E6%9C%89%E8%BF%99%E4%B9%88%E5%A4%9A/</url>
      
        <content type="html"><![CDATA[<p>思考一个简单的问题，如何用原生js实现元素的显示隐藏，也就是jQuery中show和hide方法。</p><p>你肯定觉得特别简单，隐藏的话，直接<code>el.style.display=&#39;none&#39;;</code></p><p>那显示呢？<code>el.style.display=&#39;block&#39;</code>？<br><a id="more"></a></p><p>display属性是css中最基本的属性。除了常用的<code>inline</code>，<code>inline-block</code>，<code>block</code>，<code>none</code>，其实display还有很多属性值。</p><p>这个属性决定了元素的显示类型，也指定了元素怎么生成盒模型。</p><p>分为外部显示类型和内部显示类型</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* &lt;display-outside&gt; values */</span></span><br><span class="line"><span class="comment">/* 在流式布局中的角色:行内元素还是块级元素 */</span></span><br><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">block</span>;</span><br><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">inline</span>;</span><br><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">run-in</span>; <span class="comment">/* 大多数浏览器都不支持 */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* &lt;display-inside&gt; values */</span></span><br><span class="line"><span class="comment">/* 元素内部内容的格式化上下文的类型 */</span></span><br><span class="line">display: flow; // ??</span><br><span class="line">display: ruby;// ??</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">flow-root</span>;</span><br><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">table</span>;<span class="comment">/* 内部是table布局 */</span></span><br><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">flex</span>;<span class="comment">/* 内部是flex布局 */</span></span><br><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">grid</span>;<span class="comment">/* 内部是grid布局 */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* &lt;display-outside&gt; plus &lt;display-inside&gt; values */</span></span><br><span class="line">display: block flow; // 可以写两个吗？</span><br><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">inline</span> <span class="selector-tag">table</span>;</span><br><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">flex</span> <span class="selector-tag">run-in</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* &lt;display-listitem&gt; values */</span></span><br><span class="line"><span class="comment">/* 将这个元素的外部显示类型变为 block，并将内部显示类型变为多个 list-item inline 盒。*/</span></span><br><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">list-item</span>;</span><br><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">list-item</span> <span class="selector-tag">block</span>;</span><br><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">list-item</span> <span class="selector-tag">inline</span>;</span><br><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">list-item</span> <span class="selector-tag">flow</span>;</span><br><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">list-item</span> <span class="selector-tag">flow-root</span>;</span><br><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">list-item</span> <span class="selector-tag">block</span> <span class="selector-tag">flow</span>;</span><br><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">list-item</span> <span class="selector-tag">block</span> <span class="selector-tag">flow-root</span>;</span><br><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">flow</span> <span class="selector-tag">list-item</span> <span class="selector-tag">block</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* &lt;display-internal&gt; values */</span></span><br><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">table-row-group</span>;</span><br><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">table-header-group</span>;</span><br><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">table-footer-group</span>;</span><br><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">table-row</span>;</span><br><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">table-cell</span>;</span><br><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">table-column-group</span>;</span><br><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">table-column</span>;</span><br><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">table-caption</span>;</span><br><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">ruby-base</span>;</span><br><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">ruby-text</span>;</span><br><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">ruby-base-container</span>;</span><br><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">ruby-text-container</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* &lt;display-box&gt; values */</span></span><br><span class="line"><span class="comment">/* 是否显示 */</span></span><br><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">contents</span>;</span><br><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">none</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* &lt;display-legacy&gt; values */</span></span><br><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">inline-block</span>;</span><br><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">inline-table</span>;</span><br><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">inline-flex</span>;</span><br><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">inline-grid</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Global values */</span></span><br><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">inherit</span>;</span><br><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">initial</span>;</span><br><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">unset</span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>meta全解释</title>
      <link href="/2016/11/18/meta%E5%85%A8%E8%A7%A3%E9%87%8A/"/>
      <url>/2016/11/18/meta%E5%85%A8%E8%A7%A3%E9%87%8A/</url>
      
        <content type="html"><![CDATA[<p>整理下HTML中常用的meta。<br><a id="more"></a></p><p><meta http-equiv="x-dns-prefetch-control" content="on">;</p><link rel="dns-prefetch" href="`[`http://bdimg.share.baidu.com`](http://bdimg.share.baidu.com)`"><p>dns-prefetch是具有此域名不需要点击就在后台解析，域名解析和内容载入是串行的网络操作</p><p>Chrome内置了DNS Prefetching技术, Firefox 3.5 也引入了这一特性，由于Chrome和Firefox 3.5本身对DNS预解析做了相应优化设置，所以设置DNS预解析的不良影响之一就是可能会降低Google Chrome浏览器及火狐Firefox 3.5浏览器的用户体验。</p><p>SEO作用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- H5标准声明，使用 HTML5 doctype，不区分大小写 --&gt;</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;!-- 标准的 lang 属性写法 --&gt;</span><br><span class="line">&lt;head lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;!-- 声明文档使用的字符编码 --&gt;</span><br><span class="line">&lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">&lt;!-- 强制浏览器的渲染方式，默认chrome，ie按最最新版本来渲染.chrome=1的意思是chrome frame不改变ie外观就可以使ie里变成chrome --&gt;</span><br><span class="line">&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1″ /&gt;</span><br><span class="line">&lt;!-- 页面描述 --&gt;</span><br><span class="line">&lt;meta name=&quot; description&quot; content=&quot;不超过150个字符&quot; /&gt;</span><br><span class="line">&lt;!-- 页面关键词 --&gt;</span><br><span class="line">&lt;meta name=&quot;keywords&quot; content=&quot;&quot; /&gt;</span><br><span class="line">&lt;!-- 网页作者 --&gt;</span><br><span class="line">&lt;meta name=&quot;author&quot; content=&quot;name, email@gmail.com&quot; /&gt;</span><br><span class="line">&lt;!-- 搜索引擎抓取 --&gt;</span><br><span class="line">&lt;meta name=&quot;robots&quot; content=&quot;index,follow&quot; /&gt;</span><br><span class="line">&lt;!-- 为移动设备添加 viewport --&gt;</span><br><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=1, maximum-scale=3, minimum-scale=1, user-scalable=no&quot;&gt;</span><br><span class="line">&lt;!-- 启用360浏览器的极速模式(webkit) --&gt;</span><br><span class="line">&lt;meta name=&quot;renderer&quot; content=&quot;webkit&quot;&gt;</span><br><span class="line">&lt;!-- 360提出的浏览器内核控制meta标签，页面渲染使用：webkit内核，ie兼容内核，ie标准内核 --&gt;</span><br><span class="line">&lt;!-- &lt;meta name=&quot;renderer&quot; content=&quot;webkit|ie-comp|ie-stand&quot;&gt; --&gt;</span><br><span class="line">禁止百度转码。百度转码可能会加上广告等，加上了百度也可能不遵守，最好都加上</span><br><span class="line">&lt;meta http-equiv=&quot;Cache-Control&quot; content=&quot;no-transform | no-siteapp&quot; /&gt;</span><br><span class="line">&lt;!-- uc强制竖屏 --&gt;</span><br><span class="line">&lt;meta name=&quot; screen-orientation&quot; content=&quot;portrait&quot;&gt;</span><br><span class="line">&lt;!-- QQ强制竖屏 --&gt;</span><br><span class="line">&lt;meta name=&quot;x5-orientation&quot; content=&quot;portrait&quot;&gt;</span><br><span class="line">&lt;!-- UC强制全屏 --&gt;</span><br><span class="line">&lt;meta name=&quot;full-screen&quot; content=&quot;yes&quot;&gt;</span><br><span class="line">&lt;!-- QQ强制全屏 --&gt;</span><br><span class="line">&lt;meta name=&quot;x5-fullscreen&quot; content=&quot;true&quot;&gt;</span><br><span class="line">&lt;!-- 设置页面不缓存 --&gt;</span><br><span class="line">&lt;meta http-equiv=&quot;expires&quot; content=&quot;0″&gt;</span><br><span class="line">&lt;meta http-equiv=&quot; pragma&quot; content=&quot;no-cache&quot;&gt;</span><br><span class="line">&lt;meta http-equiv=&quot;cache-control&quot; content=&quot;no-cache&quot;&gt;</span><br><span class="line">&lt;!-- 将页面中http升级为https访问 --&gt;</span><br><span class="line">&lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;upgrade-insecure-requests&quot;&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
