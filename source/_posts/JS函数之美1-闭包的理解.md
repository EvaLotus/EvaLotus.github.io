---
title: JS函数之美1-闭包的理解
date: 2018-02-18 13:12:19
tags: javascript
---
```js
function fn() {
var a = 1;
}
```

问：不改变fn的函数体，怎么把变量a的值变成2呢？

你肯定想说a都没return出来，我根本获取不到呀，怎么可能改a的值。

那么如果我把`a`return出来，你有办法修改a的值吗？
<!-- more -->

```js
function fn() {
var a = 1;
console.log(a);
return a;
}
// a++; a依然是私有变量,外部访问不到

var b=fn(); // 1
b++; // 2

var c=fn(); // 1 a的值依然没有改变
```

b++之后 a的值变化了吗？我感觉因为a是基本数据类型，存在堆内存里，b应该是指向a的，所以应该是修改成功了a的值，但是确实没办法验证。

因为你想要获取a的实时状态，只能通过fn来获取，但是var c=fn\(\)调用过后，a又被重新赋值了，所以没办法验证。

你可能觉得这个问题比较傻，局部变量的值怎么可能被改变呢？改了又有什么意义呢？

我就遇到过，iOS开发过程中前人封装了一个framework，只暴露了获取a的方法，实现却被打包了，framework打包前的代码也没有，无法修改函数体。但是遇到一个bug，必须要修改a的值才能解决。

我想了好久也想不出来办法，现在想想其实根本没必要费这个劲儿，只能去找前人找找打包framework之前的源码，改了a重新打包一遍。

类比js的场景，其实就相当于引了个第三方的加密混淆过的js，改了a的值你就能免费使用第三方的服务，但是人家是个私有局部变量，任你外面的代码写出花儿来，也没办法改变a的值。

那我们就应该放弃吗？可以得出私有局部变量的值是肯定不能改的结论吗？

来试试暴露出修改a的接口看看能不能成功。

```js
function f1() {
var a = 1;
return function() {
console.log(a);
return a++;
};
}
f1()(); // 1
f1()(); // 1
f1()(); // 1
```

很显然失败了。

调用一百次得到的值也都是a=1，其实很好理解，和上一个例子一样，每次调用都重新走了一下var a=1，重新声明了a的值。那如果想办法不调用a的重新声明呢？

```js
var f2=f1();
f2(); // 1
f2(); // 2
f2(); // 3
```

哇，居然真的成功了！得到的值果然符合我们的预期，但是a的值真的改变了吗？这个a还是原来的那个a吗？一脸懵逼，有点怀疑人生了。

在函数外也可以调用，难道a变成了全局变量吗？

```js
var a = 233;
function f1() {
var a = 1;
console.log(a); // 代码是一行一行执行的，走到这里一定会是1
return function() {
console.log(a);
return a++;
};
}
var f2 = f1();
f2(); // 1
f2(); // 2
f2(); // 3
```

看起来并没有，f2的操作还是围绕着局部变量a来进行的。可能相比于上一个例子，实际上一个例子也修改成功了只是无法验证而已。

静静的思考一下，开发者用局部变量而不是全局变量，就是为了不让别人不经过同意就随便改自己的代码。

其实说到底还是变量作用域的问题。

虽然变量名相同，但是在函数中，总是**从内到外**去寻找变量的声明，找到最近的声明就用最近的那个值，即使是undefined也是一样。

```js
var a = 333;
function fn() {
var a;
console.log(a); // undefined
return a;
}
```

再说说**变量提升**的问题。

其实这就是js中的闭包。闭包可以简单的理解成是**函数内部的函数**，核心作用是**读取到其他函数内部变量的函数**。

因为a被return出来，随时可能会被操作，不会在调用结束后马上被垃圾回收机制回收，而是被保存在内存中，内存消耗很大，，所以不能滥用闭包，否则会造成网页的性能问题。在IE中可能会导致内存泄漏的问题。解决方法是，在退出函数之前，将不使用的局部变量全部删除。

主要就是变量提升，变量作用域的问题。

如果改成es6，变成大括号作用域，那会有什么不同吗？

如果加上this呢？会让人更怀疑人生吗？

另一个重要的作用是：让这些变量的值始终保持在内存中。

闭包中的变量的生存周期很长。

```
function closure() {
var v = 1;

function f2() {
// 重点在这里，
return v++;
}
return f2;
// return function() {
// return v++;
// };
}

const result = closure();
console.log(result()); // 1
console.log(result()); // 2
console.log(result()); // 3
console.log(v); // error
```

改变函数内部变量的值。



f2始终在内存中？而f2依赖于f1，所以f1也始终存在内存中，不会在调用结束后被垃圾回收机制回收。

那如果改成匿名函数呢？匿名函数也是全局变量吗

```
// f是个匿名函数
var f=function(){}

function f(){}
```

两种声明函数方式的区别是很大的。

作用：

私有方法有利于限制代码的访问

管理全局命名空间

数据隐藏和封装
